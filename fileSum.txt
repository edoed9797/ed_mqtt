This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-17T10:58:11.785Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory and Files
================================================================
.classpath
.project
pom.xml
src/main/java/com/vending/api/controllers/AuthController.java
src/main/java/com/vending/api/controllers/BevandaController.java
src/main/java/com/vending/api/controllers/IstitutoController.java
src/main/java/com/vending/api/controllers/MacchinaController.java
src/main/java/com/vending/api/controllers/ManutenzioneController.java
src/main/java/com/vending/api/controllers/PublicController.java
src/main/java/com/vending/api/controllers/UtenteController.java
src/main/java/com/vending/api/middleware/AuthMiddleware.java
src/main/java/com/vending/api/middleware/CORSMiddleware.java
src/main/java/com/vending/api/middleware/LogMiddleware.java
src/main/java/com/vending/api/routes/Routes.java
src/main/java/com/vending/config.properties
src/main/java/com/vending/core/models/AdminLogin.java
src/main/java/com/vending/core/models/Bevanda.java
src/main/java/com/vending/core/models/Cialda.java
src/main/java/com/vending/core/models/Credenziale.java
src/main/java/com/vending/core/models/Istituto.java
src/main/java/com/vending/core/models/Macchina.java
src/main/java/com/vending/core/models/Manutenzione.java
src/main/java/com/vending/core/models/QuantitaCialde.java
src/main/java/com/vending/core/models/Ricavo.java
src/main/java/com/vending/core/models/StatoMacchina.java
src/main/java/com/vending/core/models/Transazione.java
src/main/java/com/vending/core/models/Utente.java
src/main/java/com/vending/core/repositories/AdminLoginRepository.java
src/main/java/com/vending/core/repositories/BevandaRepository.java
src/main/java/com/vending/core/repositories/CialdaRepository.java
src/main/java/com/vending/core/repositories/DatabaseConnection.java
src/main/java/com/vending/core/repositories/IstitutoRepository.java
src/main/java/com/vending/core/repositories/MacchinaRepository.java
src/main/java/com/vending/core/repositories/ManutenzioneRepository.java
src/main/java/com/vending/core/repositories/RicavoRepository.java
src/main/java/com/vending/core/repositories/TransazioneRepository.java
src/main/java/com/vending/core/repositories/UtenteRepository.java
src/main/java/com/vending/core/services/AdminLoginService.java
src/main/java/com/vending/core/services/BevandaService.java
src/main/java/com/vending/core/services/IstitutoService.java
src/main/java/com/vending/core/services/MacchinaService.java
src/main/java/com/vending/core/services/ManutenzioneService.java
src/main/java/com/vending/core/services/RicavoService.java
src/main/java/com/vending/core/services/TransazioneService.java
src/main/java/com/vending/core/services/UtenteService.java
src/main/java/com/vending/iot/bridge/BridgeConfig.java
src/main/java/com/vending/iot/bridge/MQTTBridge.java
src/main/java/com/vending/iot/bridge/TopicManager.java
src/main/java/com/vending/iot/machines/GestoreBevande.java
src/main/java/com/vending/iot/machines/GestoreCassa.java
src/main/java/com/vending/iot/machines/GestoreCialde.java
src/main/java/com/vending/iot/machines/GestoreManutenzione.java
src/main/java/com/vending/iot/machines/MacchinaPrincipale.java
src/main/java/com/vending/iot/monitor/AlertManager.java
src/main/java/com/vending/iot/monitor/Allarme.java
src/main/java/com/vending/iot/monitor/MonitorMacchine.java
src/main/java/com/vending/iot/monitor/StatoMacchina.java
src/main/java/com/vending/iot/mqtt/MessageHandler.java
src/main/java/com/vending/iot/mqtt/MQTTClient.java
src/main/java/com/vending/iot/mqtt/MQTTConfig.java
src/main/java/com/vending/Main.java
src/main/java/com/vending/MainV1.java
src/main/java/com/vending/security/auth/AuthenticationService.java
src/main/java/com/vending/security/auth/AuthorizationException.java
src/main/java/com/vending/security/auth/AuthorizationService.java
src/main/java/com/vending/security/auth/PasswordService.java
src/main/java/com/vending/security/config/SecurityConfig.java
src/main/java/com/vending/security/encryption/EncryptionService.java
src/main/java/com/vending/security/jwt/JWTService.java
src/main/java/com/vending/security/JWTUtil.java
src/main/java/com/vending/security/PasswordUtil.java
src/main/java/com/vending/ServiceRegistry.java
src/main/java/com/vending/utils/config/ConfigUtil.java
src/main/java/com/vending/utils/date/DateUtil.java
src/main/java/com/vending/utils/date/LocalDateTimeTypeAdapter.java
src/main/java/com/vending/utils/log/LogUtil.java
src/main/java/com/vending/utils/money/MoneyUtil.java
src/main/java/com/vending/utils/validation/ValidationUtil.java
src/main/resources/config.properties
src/main/resources/public/css/admin.css
src/main/resources/public/css/client.css
src/main/resources/public/css/reports.css
src/main/resources/public/css/style.css
src/main/resources/public/homepage.html
src/main/resources/public/index.html
src/main/resources/public/js/admin/dashboard.js
src/main/resources/public/js/admin/institutes.js
src/main/resources/public/js/admin/machines.js
src/main/resources/public/js/admin/maintenance.js
src/main/resources/public/js/admin/pods.js
src/main/resources/public/js/admin/reports.js
src/main/resources/public/js/client/beverageSelection.js
src/main/resources/public/js/client/machineSelection.js
src/main/resources/public/js/client/payment.js
src/main/resources/public/js/common/auth-utils.js
src/main/resources/public/js/common/authentication.js
src/main/resources/public/js/common/mqtt.js
src/main/resources/public/js/common/utils.js
src/main/resources/public/pages/admin/dash_admin.html
src/main/resources/public/pages/admin/dash_impiegati.html
src/main/resources/public/pages/admin/dashboard.html
src/main/resources/public/pages/admin/institutes.html
src/main/resources/public/pages/admin/machines.html
src/main/resources/public/pages/admin/maintenance.html
src/main/resources/public/pages/admin/MonitorMacchine.html
src/main/resources/public/pages/admin/pods.html
src/main/resources/public/pages/admin/reports.html
src/main/resources/public/pages/admin/reports1.html
src/main/resources/public/pages/client/beverageInterface.html
src/main/resources/public/pages/client/login.html
src/main/resources/public/pages/client/machineSelection.html
src/main/resources/public/pages/client/register.html

================
File: .classpath
================
<?xml version="1.0" encoding="UTF-8"?>
<classpath>
	<classpathentry excluding="**" kind="src" output="target/classes" path="src/main/resources">
		<attributes>
			<attribute name="maven.pomderived" value="true"/>
			<attribute name="optional" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry excluding="**" kind="src" output="target/test-classes" path="src/test/resources">
		<attributes>
			<attribute name="test" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
			<attribute name="optional" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-17">
		<attributes>
			<attribute name="maven.pomderived" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="con" path="org.eclipse.m2e.MAVEN2_CLASSPATH_CONTAINER">
		<attributes>
			<attribute name="maven.pomderived" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="src" path="target/generated-sources/annotations">
		<attributes>
			<attribute name="ignore_optional_problems" value="true"/>
			<attribute name="optional" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
			<attribute name="m2e-apt" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="src" output="target/classes" path="src/main/java">
		<attributes>
			<attribute name="optional" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="src" output="target/test-classes" path="src/test/java">
		<attributes>
			<attribute name="test" value="true"/>
			<attribute name="optional" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="src" output="target/test-classes" path="target/generated-test-sources/test-annotations">
		<attributes>
			<attribute name="optional" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
			<attribute name="ignore_optional_problems" value="true"/>
			<attribute name="m2e-apt" value="true"/>
			<attribute name="test" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="output" path="target/classes"/>
</classpath>

================
File: .project
================
<?xml version="1.0" encoding="UTF-8"?>
<projectDescription>
	<name>mqtt_20019309</name>
	<comment></comment>
	<projects>
	</projects>
	<buildSpec>
		<buildCommand>
			<name>org.eclipse.jdt.core.javabuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.eclipse.m2e.core.maven2Builder</name>
			<arguments>
			</arguments>
		</buildCommand>
	</buildSpec>
	<natures>
		<nature>org.eclipse.jdt.core.javanature</nature>
		<nature>org.eclipse.m2e.core.maven2Nature</nature>
	</natures>
	<filteredResources>
		<filter>
			<id>1735039323762</id>
			<name></name>
			<type>30</type>
			<matcher>
				<id>org.eclipse.core.resources.regexFilterMatcher</id>
				<arguments>node_modules|\.git|__CREATED_BY_JAVA_LANGUAGE_SERVER__</arguments>
			</matcher>
		</filter>
	</filteredResources>
</projectDescription>

================
File: db_dump.sql
================
-- MySQL dump 10.13  Distrib 8.0.38, for Win64 (x86_64)
--
-- Host: localhost    Database: pissir
-- ------------------------------------------------------
-- Server version	8.0.39

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `adminlogin`
--

DROP TABLE IF EXISTS `adminlogin`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `adminlogin` (
  `ID_AdminLogin` int NOT NULL,
  `ID_Utente` int DEFAULT NULL,
  `Username` varchar(255) DEFAULT NULL,
  `PasswordHash` varchar(255) DEFAULT NULL,
  `UltimoAccesso` datetime DEFAULT NULL,
  PRIMARY KEY (`ID_AdminLogin`),
  UNIQUE KEY `ID_Utente` (`ID_Utente`),
  UNIQUE KEY `Username` (`Username`),
  KEY `idx_username` (`Username`),
  CONSTRAINT `adminlogin_ibfk_1` FOREIGN KEY (`ID_Utente`) REFERENCES `utente` (`ID_Utente`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `adminlogin`
--

LOCK TABLES `adminlogin` WRITE;
/*!40000 ALTER TABLE `adminlogin` DISABLE KEYS */;
/*!40000 ALTER TABLE `adminlogin` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bevanda`
--

DROP TABLE IF EXISTS `bevanda`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `bevanda` (
  `ID_Bevanda` int NOT NULL,
  `Nome` varchar(255) DEFAULT NULL,
  `Prezzo` decimal(10,2) DEFAULT NULL,
  PRIMARY KEY (`ID_Bevanda`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bevanda`
--

LOCK TABLES `bevanda` WRITE;
/*!40000 ALTER TABLE `bevanda` DISABLE KEYS */;
INSERT INTO `bevanda` VALUES (1,'Espresso',0.70),(2,'Cappuccino',1.00),(3,'Te al limone',0.60),(4,'Cioccolata calda',1.20),(5,'Caffè al ginseng',1.00),(6,'Caffè d\'orzo',0.65),(7,'Te nero',0.80),(8,'Latte macchiato',1.10),(9,'Camomilla',0.90),(10,'Mocaccino',1.30);
/*!40000 ALTER TABLE `bevanda` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bevandahacialda`
--

DROP TABLE IF EXISTS `bevandahacialda`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `bevandahacialda` (
  `ID_BevandaHaCialda` int NOT NULL,
  `ID_Bevanda` int DEFAULT NULL,
  `ID_Cialda` int DEFAULT NULL,
  PRIMARY KEY (`ID_BevandaHaCialda`),
  KEY `ID_Bevanda` (`ID_Bevanda`),
  KEY `ID_Cialda` (`ID_Cialda`),
  CONSTRAINT `bevandahacialda_ibfk_1` FOREIGN KEY (`ID_Bevanda`) REFERENCES `bevanda` (`ID_Bevanda`),
  CONSTRAINT `bevandahacialda_ibfk_2` FOREIGN KEY (`ID_Cialda`) REFERENCES `cialda` (`ID_Cialda`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bevandahacialda`
--

LOCK TABLES `bevandahacialda` WRITE;
/*!40000 ALTER TABLE `bevandahacialda` DISABLE KEYS */;
INSERT INTO `bevandahacialda` VALUES (1,1,1),(2,1,2),(3,2,1),(4,3,3),(5,4,4),(6,5,5),(7,6,7),(8,7,8),(9,8,9),(10,9,10),(11,10,1),(12,10,4),(13,2,9),(14,1,6),(15,3,6);
/*!40000 ALTER TABLE `bevandahacialda` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Temporary view structure for view `bevandecialdeecosti`
--

DROP TABLE IF EXISTS `bevandecialdeecosti`;
/*!50001 DROP VIEW IF EXISTS `bevandecialdeecosti`*/;
SET @saved_cs_client     = @@character_set_client;
/*!50503 SET character_set_client = utf8mb4 */;
/*!50001 CREATE VIEW `bevandecialdeecosti` AS SELECT 
 1 AS `ID_Bevanda`,
 1 AS `NomeBevanda`,
 1 AS `Prezzo`,
 1 AS `Cialde`*/;
SET character_set_client = @saved_cs_client;

--
-- Table structure for table `cialda`
--

DROP TABLE IF EXISTS `cialda`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `cialda` (
  `ID_Cialda` int NOT NULL,
  `Nome` varchar(255) DEFAULT NULL,
  `TipoCialda` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`ID_Cialda`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cialda`
--

LOCK TABLES `cialda` WRITE;
/*!40000 ALTER TABLE `cialda` DISABLE KEYS */;
INSERT INTO `cialda` VALUES (1,'Arabica','Caffè'),(2,'Robusta','Caffè'),(3,'Te verde','Tè'),(4,'Cioccolato','Cacao'),(5,'Ginseng','Caffè'),(6,'Zucchero','Additivo'),(7,'Orzo','Caffè'),(8,'Te nero','Tè'),(9,'Latte','Additivo'),(10,'Camomilla','Tisana');
/*!40000 ALTER TABLE `cialda` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Temporary view structure for view `disponibilitacialde`
--

DROP TABLE IF EXISTS `disponibilitacialde`;
/*!50001 DROP VIEW IF EXISTS `disponibilitacialde`*/;
SET @saved_cs_client     = @@character_set_client;
/*!50503 SET character_set_client = utf8mb4 */;
/*!50001 CREATE VIEW `disponibilitacialde` AS SELECT 
 1 AS `ID_Macchina`,
 1 AS `NomeIstituto`,
 1 AS `NomeCialda`,
 1 AS `Quantita`,
 1 AS `QuantitaMassima`,
 1 AS `DaRifornire`*/;
SET character_set_client = @saved_cs_client;

--
-- Table structure for table `istituto`
--

DROP TABLE IF EXISTS `istituto`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `istituto` (
  `ID_Istituto` int NOT NULL,
  `Nome` varchar(255) DEFAULT NULL,
  `Indirizzo` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`ID_Istituto`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `istituto`
--

LOCK TABLES `istituto` WRITE;
/*!40000 ALTER TABLE `istituto` DISABLE KEYS */;
INSERT INTO `istituto` VALUES (1,'Liceo Scientifico Galileo Ferraris','Corso Montevecchio 67, Torino'),(2,'IIS Baldessano-Roccati','Viale Garibaldi 7, Carmagnola'),(3,'Liceo Classico Cavour','Corso Tassoni 15, Torino'),(4,'IIS Majorana','Via Frattini 11, Torino'),(5,'Liceo Artistico Cottini','Via Castelgomberto 20, Torino'),(6,'IIS Avogadro','Corso San Maurizio 8, Torino'),(7,'Liceo Linguistico Gioberti','Via Sant Ottavio 9, Torino'),(8,'ITIS Pininfarina','Via Ponchielli 16, Moncalieri');
/*!40000 ALTER TABLE `istituto` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `macchina`
--

DROP TABLE IF EXISTS `macchina`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `macchina` (
  `ID_Macchina` int NOT NULL,
  `ID_Istituto` int DEFAULT NULL,
  `Stato` int DEFAULT NULL,
  `CassaAttuale` decimal(10,2) DEFAULT NULL,
  `CassaMassima` decimal(10,2) DEFAULT NULL,
  PRIMARY KEY (`ID_Macchina`),
  KEY `ID_Istituto` (`ID_Istituto`),
  KEY `Stato` (`Stato`),
  CONSTRAINT `macchina_ibfk_1` FOREIGN KEY (`ID_Istituto`) REFERENCES `istituto` (`ID_Istituto`),
  CONSTRAINT `macchina_ibfk_2` FOREIGN KEY (`Stato`) REFERENCES `statomacchina` (`ID_StatoMacchina`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `macchina`
--

LOCK TABLES `macchina` WRITE;
/*!40000 ALTER TABLE `macchina` DISABLE KEYS */;
INSERT INTO `macchina` VALUES (1,1,1,150.50,500.00),(2,2,1,75.25,300.00),(3,3,2,0.00,400.00),(4,4,1,200.75,600.00),(5,5,3,0.00,500.00),(6,6,1,100.00,400.00),(7,7,4,50.00,300.00),(8,8,1,180.00,550.00),(9,1,5,0.00,450.00),(10,2,1,90.00,350.00);
/*!40000 ALTER TABLE `macchina` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `macchinahabevanda`
--

DROP TABLE IF EXISTS `macchinahabevanda`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `macchinahabevanda` (
  `ID_MacchinaHaBevanda` int NOT NULL,
  `ID_Macchina` int DEFAULT NULL,
  `ID_Bevanda` int DEFAULT NULL,
  PRIMARY KEY (`ID_MacchinaHaBevanda`),
  KEY `ID_Macchina` (`ID_Macchina`),
  KEY `ID_Bevanda` (`ID_Bevanda`),
  CONSTRAINT `macchinahabevanda_ibfk_1` FOREIGN KEY (`ID_Macchina`) REFERENCES `macchina` (`ID_Macchina`),
  CONSTRAINT `macchinahabevanda_ibfk_2` FOREIGN KEY (`ID_Bevanda`) REFERENCES `bevanda` (`ID_Bevanda`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `macchinahabevanda`
--

LOCK TABLES `macchinahabevanda` WRITE;
/*!40000 ALTER TABLE `macchinahabevanda` DISABLE KEYS */;
INSERT INTO `macchinahabevanda` VALUES (1,1,1),(2,1,2),(3,2,1),(4,2,3),(5,3,4),(6,4,5),(7,4,1),(8,5,2),(9,6,6),(10,7,7),(11,8,8),(12,9,9),(13,10,10),(14,1,3),(15,2,4);
/*!40000 ALTER TABLE `macchinahabevanda` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Temporary view structure for view `macchinenegliistituti`
--

DROP TABLE IF EXISTS `macchinenegliistituti`;
/*!50001 DROP VIEW IF EXISTS `macchinenegliistituti`*/;
SET @saved_cs_client     = @@character_set_client;
/*!50503 SET character_set_client = utf8mb4 */;
/*!50001 CREATE VIEW `macchinenegliistituti` AS SELECT 
 1 AS `ID_Macchina`,
 1 AS `NomeIstituto`,
 1 AS `Indirizzo`,
 1 AS `StatoMacchina`,
 1 AS `CassaAttuale`,
 1 AS `CassaMassima`*/;
SET character_set_client = @saved_cs_client;

--
-- Table structure for table `quantitacialde`
--

DROP TABLE IF EXISTS `quantitacialde`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `quantitacialde` (
  `ID_QuantitaCialde` int NOT NULL,
  `ID_Macchina` int DEFAULT NULL,
  `ID_Cialda` int DEFAULT NULL,
  `Quantita` int DEFAULT NULL,
  `QuantitaMassima` int DEFAULT NULL,
  PRIMARY KEY (`ID_QuantitaCialde`),
  KEY `ID_Macchina` (`ID_Macchina`),
  KEY `ID_Cialda` (`ID_Cialda`),
  CONSTRAINT `quantitacialde_ibfk_1` FOREIGN KEY (`ID_Macchina`) REFERENCES `macchina` (`ID_Macchina`),
  CONSTRAINT `quantitacialde_ibfk_2` FOREIGN KEY (`ID_Cialda`) REFERENCES `cialda` (`ID_Cialda`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `quantitacialde`
--

LOCK TABLES `quantitacialde` WRITE;
/*!40000 ALTER TABLE `quantitacialde` DISABLE KEYS */;
INSERT INTO `quantitacialde` VALUES (1,1,1,50,100),(2,1,2,30,100),(3,2,3,40,80),(4,3,4,0,60),(5,4,5,25,50),(6,5,6,100,200),(7,6,7,35,70),(8,7,8,20,60),(9,8,9,15,40),(10,9,10,30,80),(11,10,1,45,90),(12,1,6,150,300);
/*!40000 ALTER TABLE `quantitacialde` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Temporary view structure for view `ricavigiornalieri`
--

DROP TABLE IF EXISTS `ricavigiornalieri`;
/*!50001 DROP VIEW IF EXISTS `ricavigiornalieri`*/;
SET @saved_cs_client     = @@character_set_client;
/*!50503 SET character_set_client = utf8mb4 */;
/*!50001 CREATE VIEW `ricavigiornalieri` AS SELECT 
 1 AS `ID_Macchina`,
 1 AS `NomeIstituto`,
 1 AS `Data`,
 1 AS `RicavoGiornaliero`*/;
SET character_set_client = @saved_cs_client;

--
-- Table structure for table `ricavo`
--

DROP TABLE IF EXISTS `ricavo`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `ricavo` (
  `ID_Ricavo` int NOT NULL,
  `ID_Macchina` int DEFAULT NULL,
  `Importo` decimal(10,2) DEFAULT NULL,
  `DataOra` datetime DEFAULT NULL,
  PRIMARY KEY (`ID_Ricavo`),
  KEY `ID_Macchina` (`ID_Macchina`),
  CONSTRAINT `ricavo_ibfk_1` FOREIGN KEY (`ID_Macchina`) REFERENCES `macchina` (`ID_Macchina`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ricavo`
--

LOCK TABLES `ricavo` WRITE;
/*!40000 ALTER TABLE `ricavo` DISABLE KEYS */;
INSERT INTO `ricavo` VALUES (1,1,75.50,'2023-11-10 20:00:00'),(2,2,50.25,'2023-11-10 20:00:00'),(3,4,100.75,'2023-11-10 20:00:00'),(4,6,45.00,'2024-05-10 20:00:00'),(5,8,80.00,'2024-09-25 20:00:00'),(6,10,60.50,'2024-09-25 20:00:00');
/*!40000 ALTER TABLE `ricavo` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `statomacchina`
--

DROP TABLE IF EXISTS `statomacchina`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `statomacchina` (
  `ID_StatoMacchina` int NOT NULL,
  `Descrizione` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`ID_StatoMacchina`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `statomacchina`
--

LOCK TABLES `statomacchina` WRITE;
/*!40000 ALTER TABLE `statomacchina` DISABLE KEYS */;
INSERT INTO `statomacchina` VALUES (1,'Attiva'),(2,'In manutenzione'),(3,'Fuori servizio');
/*!40000 ALTER TABLE `statomacchina` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `transazione`
--

DROP TABLE IF EXISTS `transazione`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `transazione` (
  `ID_Transazione` int NOT NULL,
  `ID_Macchina` int DEFAULT NULL,
  `ID_Bevanda` int DEFAULT NULL,
  `Importo` decimal(10,2) DEFAULT NULL,
  `DataOra` datetime DEFAULT NULL,
  PRIMARY KEY (`ID_Transazione`),
  KEY `ID_Macchina` (`ID_Macchina`),
  KEY `ID_Bevanda` (`ID_Bevanda`),
  CONSTRAINT `transazione_ibfk_1` FOREIGN KEY (`ID_Macchina`) REFERENCES `macchina` (`ID_Macchina`),
  CONSTRAINT `transazione_ibfk_2` FOREIGN KEY (`ID_Bevanda`) REFERENCES `bevanda` (`ID_Bevanda`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `transazione`
--

LOCK TABLES `transazione` WRITE;
/*!40000 ALTER TABLE `transazione` DISABLE KEYS */;
INSERT INTO `transazione` VALUES (1,1,1,0.50,'2023-11-10 08:30:00'),(2,2,2,1.00,'2023-11-10 09:15:00'),(3,4,3,0.80,'2023-11-10 10:00:00'),(4,1,4,1.20,'2023-11-10 11:30:00'),(5,2,5,1.00,'2024-01-20 14:00:00'),(6,6,6,0.70,'2024-01-20 15:30:00'),(7,8,7,0.80,'2024-04-18 16:45:00'),(8,10,8,1.10,'2024-04-18 17:20:00'),(9,1,9,0.90,'2024-09-25 18:00:00'),(10,4,10,1.30,'2024-09-25 19:30:00');
/*!40000 ALTER TABLE `transazione` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Temporary view structure for view `transazionirecenti`
--

DROP TABLE IF EXISTS `transazionirecenti`;
/*!50001 DROP VIEW IF EXISTS `transazionirecenti`*/;
SET @saved_cs_client     = @@character_set_client;
/*!50503 SET character_set_client = utf8mb4 */;
/*!50001 CREATE VIEW `transazionirecenti` AS SELECT 
 1 AS `ID_Transazione`,
 1 AS `ID_Macchina`,
 1 AS `NomeIstituto`,
 1 AS `NomeBevanda`,
 1 AS `Importo`,
 1 AS `DataOra`*/;
SET character_set_client = @saved_cs_client;

--
-- Table structure for table `utente`
--

DROP TABLE IF EXISTS `utente`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `utente` (
  `ID_Utente` int NOT NULL,
  `Nome` varchar(255) DEFAULT NULL,
  `Ruolo` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`ID_Utente`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `utente`
--

LOCK TABLES `utente` WRITE;
/*!40000 ALTER TABLE `utente` DISABLE KEYS */;
INSERT INTO `utente` VALUES (1,'Anna Neri','Tecnico'),(2,'Paolo Gialli','Amministratore'),(3,'Chiara Viola','Operatore');
/*!40000 ALTER TABLE `utente` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Final view structure for view `bevandecialdeecosti`
--

/*!50001 DROP VIEW IF EXISTS `bevandecialdeecosti`*/;
/*!50001 SET @saved_cs_client          = @@character_set_client */;
/*!50001 SET @saved_cs_results         = @@character_set_results */;
/*!50001 SET @saved_col_connection     = @@collation_connection */;
/*!50001 SET character_set_client      = utf8mb4 */;
/*!50001 SET character_set_results     = utf8mb4 */;
/*!50001 SET collation_connection      = utf8mb4_0900_ai_ci */;
/*!50001 CREATE ALGORITHM=UNDEFINED */
/*!50013 DEFINER=`root`@`localhost` SQL SECURITY DEFINER */
/*!50001 VIEW `bevandecialdeecosti` AS select `b`.`ID_Bevanda` AS `ID_Bevanda`,`b`.`Nome` AS `NomeBevanda`,`b`.`Prezzo` AS `Prezzo`,group_concat(`c`.`Nome` separator ', ') AS `Cialde` from ((`bevanda` `b` join `bevandahacialda` `bhc` on((`b`.`ID_Bevanda` = `bhc`.`ID_Bevanda`))) join `cialda` `c` on((`bhc`.`ID_Cialda` = `c`.`ID_Cialda`))) group by `b`.`ID_Bevanda` */;
/*!50001 SET character_set_client      = @saved_cs_client */;
/*!50001 SET character_set_results     = @saved_cs_results */;
/*!50001 SET collation_connection      = @saved_col_connection */;

--
-- Final view structure for view `disponibilitacialde`
--

/*!50001 DROP VIEW IF EXISTS `disponibilitacialde`*/;
/*!50001 SET @saved_cs_client          = @@character_set_client */;
/*!50001 SET @saved_cs_results         = @@character_set_results */;
/*!50001 SET @saved_col_connection     = @@collation_connection */;
/*!50001 SET character_set_client      = utf8mb4 */;
/*!50001 SET character_set_results     = utf8mb4 */;
/*!50001 SET collation_connection      = utf8mb4_0900_ai_ci */;
/*!50001 CREATE ALGORITHM=UNDEFINED */
/*!50013 DEFINER=`root`@`localhost` SQL SECURITY DEFINER */
/*!50001 VIEW `disponibilitacialde` AS select `m`.`ID_Macchina` AS `ID_Macchina`,`i`.`Nome` AS `NomeIstituto`,`c`.`Nome` AS `NomeCialda`,`qc`.`Quantita` AS `Quantita`,`qc`.`QuantitaMassima` AS `QuantitaMassima`,(`qc`.`QuantitaMassima` - `qc`.`Quantita`) AS `DaRifornire` from (((`quantitacialde` `qc` join `macchina` `m` on((`qc`.`ID_Macchina` = `m`.`ID_Macchina`))) join `istituto` `i` on((`m`.`ID_Istituto` = `i`.`ID_Istituto`))) join `cialda` `c` on((`qc`.`ID_Cialda` = `c`.`ID_Cialda`))) */;
/*!50001 SET character_set_client      = @saved_cs_client */;
/*!50001 SET character_set_results     = @saved_cs_results */;
/*!50001 SET collation_connection      = @saved_col_connection */;

--
-- Final view structure for view `macchinenegliistituti`
--

/*!50001 DROP VIEW IF EXISTS `macchinenegliistituti`*/;
/*!50001 SET @saved_cs_client          = @@character_set_client */;
/*!50001 SET @saved_cs_results         = @@character_set_results */;
/*!50001 SET @saved_col_connection     = @@collation_connection */;
/*!50001 SET character_set_client      = utf8mb4 */;
/*!50001 SET character_set_results     = utf8mb4 */;
/*!50001 SET collation_connection      = utf8mb4_0900_ai_ci */;
/*!50001 CREATE ALGORITHM=UNDEFINED */
/*!50013 DEFINER=`root`@`localhost` SQL SECURITY DEFINER */
/*!50001 VIEW `macchinenegliistituti` AS select `m`.`ID_Macchina` AS `ID_Macchina`,`i`.`Nome` AS `NomeIstituto`,`i`.`Indirizzo` AS `Indirizzo`,`sm`.`Descrizione` AS `StatoMacchina`,`m`.`CassaAttuale` AS `CassaAttuale`,`m`.`CassaMassima` AS `CassaMassima` from ((`macchina` `m` join `istituto` `i` on((`m`.`ID_Istituto` = `i`.`ID_Istituto`))) join `statomacchina` `sm` on((`m`.`Stato` = `sm`.`ID_StatoMacchina`))) */;
/*!50001 SET character_set_client      = @saved_cs_client */;
/*!50001 SET character_set_results     = @saved_cs_results */;
/*!50001 SET collation_connection      = @saved_col_connection */;

--
-- Final view structure for view `ricavigiornalieri`
--

/*!50001 DROP VIEW IF EXISTS `ricavigiornalieri`*/;
/*!50001 SET @saved_cs_client          = @@character_set_client */;
/*!50001 SET @saved_cs_results         = @@character_set_results */;
/*!50001 SET @saved_col_connection     = @@collation_connection */;
/*!50001 SET character_set_client      = utf8mb4 */;
/*!50001 SET character_set_results     = utf8mb4 */;
/*!50001 SET collation_connection      = utf8mb4_0900_ai_ci */;
/*!50001 CREATE ALGORITHM=UNDEFINED */
/*!50013 DEFINER=`root`@`localhost` SQL SECURITY DEFINER */
/*!50001 VIEW `ricavigiornalieri` AS select `m`.`ID_Macchina` AS `ID_Macchina`,`i`.`Nome` AS `NomeIstituto`,cast(`r`.`DataOra` as date) AS `Data`,sum(`r`.`Importo`) AS `RicavoGiornaliero` from ((`ricavo` `r` join `macchina` `m` on((`r`.`ID_Macchina` = `m`.`ID_Macchina`))) join `istituto` `i` on((`m`.`ID_Istituto` = `i`.`ID_Istituto`))) group by `m`.`ID_Macchina`,`i`.`Nome`,cast(`r`.`DataOra` as date) */;
/*!50001 SET character_set_client      = @saved_cs_client */;
/*!50001 SET character_set_results     = @saved_cs_results */;
/*!50001 SET collation_connection      = @saved_col_connection */;

--
-- Final view structure for view `transazionirecenti`
--

/*!50001 DROP VIEW IF EXISTS `transazionirecenti`*/;
/*!50001 SET @saved_cs_client          = @@character_set_client */;
/*!50001 SET @saved_cs_results         = @@character_set_results */;
/*!50001 SET @saved_col_connection     = @@collation_connection */;
/*!50001 SET character_set_client      = utf8mb4 */;
/*!50001 SET character_set_results     = utf8mb4 */;
/*!50001 SET collation_connection      = utf8mb4_0900_ai_ci */;
/*!50001 CREATE ALGORITHM=UNDEFINED */
/*!50013 DEFINER=`root`@`localhost` SQL SECURITY DEFINER */
/*!50001 VIEW `transazionirecenti` AS select `t`.`ID_Transazione` AS `ID_Transazione`,`m`.`ID_Macchina` AS `ID_Macchina`,`i`.`Nome` AS `NomeIstituto`,`b`.`Nome` AS `NomeBevanda`,`t`.`Importo` AS `Importo`,`t`.`DataOra` AS `DataOra` from (((`transazione` `t` join `macchina` `m` on((`t`.`ID_Macchina` = `m`.`ID_Macchina`))) join `istituto` `i` on((`m`.`ID_Istituto` = `i`.`ID_Istituto`))) join `bevanda` `b` on((`t`.`ID_Bevanda` = `b`.`ID_Bevanda`))) order by `t`.`DataOra` desc limit 100 */;
/*!50001 SET character_set_client      = @saved_cs_client */;
/*!50001 SET character_set_results     = @saved_cs_results */;
/*!50001 SET collation_connection      = @saved_col_connection */;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2025-01-06 19:49:41

================
File: pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.vending</groupId>
    <artifactId>Progetto_Pissir</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <spark.version>2.9.4</spark.version>
        <paho.version>1.2.5</paho.version>
        <mysql.version>8.0.33</mysql.version>
        <gson.version>2.10.1</gson.version>
        <slf4j.version>2.0.9</slf4j.version>
        <junit.version>5.10.0</junit.version>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <!-- Spark Core for REST API -->
        <dependency>
            <groupId>com.sparkjava</groupId>
            <artifactId>spark-core</artifactId>
            <version>${spark.version}</version>
        </dependency>

        <!-- MQTT Client -->
        <dependency>
            <groupId>org.eclipse.paho</groupId>
            <artifactId>org.eclipse.paho.client.mqttv3</artifactId>
            <version>${paho.version}</version>
        </dependency>

        <!-- MySQL Connector -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>${mysql.version}</version>
        </dependency>

        <!-- JSON Processing -->
        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
            <version>${gson.version}</version>
        </dependency>

        <!-- Logging -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>${slf4j.version}</version>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-simple</artifactId>
            <version>${slf4j.version}</version>
        </dependency>

        <!-- Testing -->
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-api</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>

        <!-- JWT for Authentication -->
        <dependency>
            <groupId>com.auth0</groupId>
            <artifactId>java-jwt</artifactId>
            <version>4.4.0</version>
        </dependency>

        <!-- BCrypt for Password Hashing -->
        <dependency>
            <groupId>org.mindrot</groupId>
            <artifactId>jbcrypt</artifactId>
            <version>0.4</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>${maven.compiler.source}</source>
                    <target>${maven.compiler.target}</target>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.5.0</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <transformers>
                                <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                                    <mainClass>com.vending.Application</mainClass>
                                </transformer>
                            </transformers>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>

================
File: src/main/java/com/vending/api/controllers/AuthController.java
================
package com.vending.api.controllers;

import com.google.gson.Gson;
import com.vending.core.models.Utente;
import com.vending.core.services.UtenteService;
import com.vending.security.jwt.JWTService;
import spark.Request;
import spark.Response;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;


/**
 * Controller responsabile della gestione delle richieste HTTP relative all'autenticazione.
 * Questa classe gestisce le operazioni di autenticazione e registrazione degli utenti attraverso endpoint REST.
 * 
 * <p>Il controller utilizza {@link UtenteService} per le operazioni di gestione utenti,
 * {@link JWTService} per la generazione dei token JWT e Gson per la serializzazione/deserializzazione JSON.</p>
 */

public class AuthController {
    private final UtenteService utenteService;
    private final Gson gson;
    private final JWTService jwtService;


    /**
     * Costruisce un nuovo AuthController con il servizio utente specificato.
     * Inizializza Gson per l'elaborazione JSON e JWTService per la gestione dei token.
     *
     * @param utenteService Il servizio che gestisce le operazioni relative agli utenti
     */

    public AuthController(UtenteService utenteService) {
        this.utenteService = utenteService;
        this.gson = new Gson();
        this.jwtService = new JWTService();
    }


    /**
     * Gestisce le richieste di login degli utenti autenticando le credenziali e generando token JWT.
     * 
     * <p>Si aspetta un corpo della richiesta JSON contenente:
     * <ul>
     *     <li>username: String</li>
     *     <li>password: String</li>
     * </ul>
     * </p>
     *
     * <p>Restituisce:
     * <ul>
     *     <li>Successo (200): JSON contenente token JWT e ruolo utente</li>
     *     <li>Non autorizzato (401): Messaggio di errore per credenziali non valide</li>
     *     <li>Errore server (500): Messaggio di errore per errori interni del server</li>
     * </ul>
     * </p>
     *
     * @param req L'oggetto richiesta HTTP contenente le credenziali di login
     * @param res L'oggetto risposta HTTP
     * @return Risposta JSON contenente il token JWT e il ruolo o un messaggio di errore
     */

    public Object login(Request req, Response res) {
        try {
            @SuppressWarnings("unchecked")
            Map<String, String> body = gson.fromJson(req.body(), Map.class);
            String username = body.get("username");
            String password = body.get("password");

            Utente utente = utenteService.autenticaUtente(username, password);
            if (utente != null) {
                String token = jwtService.generaToken(utente);
                Map<String, String> response = new HashMap<>();
                response.put("token", token);
                response.put("ruolo", utente.getRuolo());
                
                res.status(200);
                return gson.toJson(response);
            } else {
                res.status(401);
                return gson.toJson(Map.of("errore", "Credenziali non valide"));
            }
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", e.getMessage()));
        }
    }

    /**
    * Verifica la validità di un token JWT.
    * 
    * @param req la richiesta HTTP contenente il token da verificare
    * @param res la risposta HTTP
    * @return stato di validità del token
    */
   public Object verificaToken(Request req, Response res) {
       try {
           String token = req.headers("Authorization");
           
           if (token == null || !token.startsWith("Bearer ")) {
               res.status(401);
               return gson.toJson(Map.of("errore", "Token mancante o non valido"));
           }

           token = token.substring(7); // Rimuove "Bearer "
           boolean isValid = jwtService.verificaToken(token);
           
           if (!isValid) {
               res.status(401);
               return gson.toJson(Map.of("errore", "Token non valido"));
           }

           res.type("application/json");
           return gson.toJson(Map.of("valido", true));

       } catch (Exception e) {
           res.status(500);
           return gson.toJson(Map.of("errore", "Errore nella verifica del token"));
       }
   }
   
   /**
    * Aggiorna (refresh) un token JWT esistente.
    * 
    * @param req la richiesta HTTP contenente il token da aggiornare
    * @param res la risposta HTTP
    * @return nuovo token JWT
    */
   public Object refreshToken(Request req, Response res) {
       try {
           String token = req.headers("Authorization");
           
           if (token == null || !token.startsWith("Bearer ")) {
               res.status(401);
               return gson.toJson(Map.of("errore", "Token mancante o non valido"));
           }

           token = token.substring(7);
           
           if (!jwtService.verificaToken(token)) {
               res.status(401);
               return gson.toJson(Map.of("errore", "Token non valido"));
           }

           int userId = jwtService.getUtenteIdDaToken(token);
           Optional<Utente> utente = utenteService.getUtenteById(userId);
           
           if (utente == null) {
               res.status(401);
               return gson.toJson(Map.of("errore", "Utente non trovato"));
           }

           String nuovoToken = jwtService.generaToken(utente.get());
           
           res.type("application/json");
           return gson.toJson(Map.of("token", nuovoToken));

       } catch (Exception e) {
           res.status(500);
           return gson.toJson(Map.of("errore", "Errore nel refresh del token"));
       }
   }

    
    /**
     * Gestisce le richieste di registrazione degli utenti creando nuovi account.
     * 
     * <p>Si aspetta un corpo della richiesta JSON contenente i dettagli dell'utente conformi al modello {@link Utente}.</p>
     *
     * <p>Restituisce:
     * <ul>
     *     <li>Creato (201): JSON dell'utente appena creato</li>
     *     <li>Errore server (500): Messaggio di errore per errori interni del server</li>
     * </ul>
     * </p>
     *
     * @param req L'oggetto richiesta HTTP contenente i dettagli del nuovo utente
     * @param res L'oggetto risposta HTTP
     * @return Risposta JSON contenente i dettagli dell'utente creato o un messaggio di errore
     */
    
    public Object registrazione(Request req, Response res) {
        try {
            Utente utente = gson.fromJson(req.body(), Utente.class);
            Utente nuovoUtente = utenteService.creaUtente(utente);
            res.status(201);
            return gson.toJson(nuovoUtente);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", e.getMessage()));
        }
    }
}

================
File: src/main/java/com/vending/api/controllers/BevandaController.java
================
package com.vending.api.controllers;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.vending.core.models.Bevanda;
import com.vending.core.services.BevandaService;
import spark.Request;
import spark.Response;

import java.lang.reflect.Type;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Controller per la gestione delle richieste HTTP relative alle bevande.
 */
public class BevandaController {
    private final BevandaService bevandaService;
    private final Gson gson;

    /**
     * Costruttore del controller.
     *
     * @param bevandaService servizio per la gestione delle bevande
     */
    public BevandaController(BevandaService bevandaService) {
        this.bevandaService = bevandaService;
        this.gson = new Gson();
    }

    /**
     * Recupera tutte le bevande.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return lista JSON delle bevande
     */
    public Object getAll(Request req, Response res) {
        try {
            List<Bevanda> bevande = bevandaService.getTutteBevande();
            res.type("application/json");
            return gson.toJson(bevande);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero delle bevande: " + e.getMessage()));
        }
    }

    /**
     * Recupera una bevanda tramite ID.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return JSON della bevanda
     */
    public Object getById(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            Optional<Bevanda> bevanda = bevandaService.getBevandaById(id);
            
            if (bevanda.isPresent()) {
                res.type("application/json");
                return gson.toJson(bevanda.get());
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Bevanda non trovata"));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero della bevanda: " + e.getMessage()));
        }
    }

    /**
     * Crea una nuova bevanda.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return JSON della bevanda creata
     */
    public Object create(Request req, Response res) {
        try {
            Type requestType = new TypeToken<Map<String, Object>>(){}.getType();
            Map<String, Object> requestData = gson.fromJson(req.body(), requestType);

            String nome = (String) requestData.get("nome");
            Double prezzo = ((Number) requestData.get("prezzo")).doubleValue();
            @SuppressWarnings("unchecked")
            List<Integer> cialdeIds = (List<Integer>) requestData.get("cialdeIds");

            if (nome == null || prezzo == null || cialdeIds == null) {
                res.status(400);
                return gson.toJson(Map.of("errore", "Parametri mancanti"));
            }

            Bevanda nuovaBevanda = bevandaService.creaBevanda(nome, prezzo, cialdeIds);
            res.status(201);
            res.type("application/json");
            return gson.toJson(nuovaBevanda);
        } catch (IllegalArgumentException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", e.getMessage()));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nella creazione della bevanda: " + e.getMessage()));
        }
    }

    /**
     * Aggiorna una bevanda esistente.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return JSON della bevanda aggiornata
     */
    public Object update(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            Type requestType = new TypeToken<Map<String, Object>>(){}.getType();
            Map<String, Object> requestData = gson.fromJson(req.body(), requestType);

            String nome = (String) requestData.get("nome");
            Double prezzo = requestData.get("prezzo") != null ? 
                ((Number) requestData.get("prezzo")).doubleValue() : null;
            @SuppressWarnings("unchecked")
            List<Integer> cialdeIds = (List<Integer>) requestData.get("cialdeIds");

            try {
                Bevanda bevandaAggiornata = bevandaService.aggiornaBevanda(id, nome, prezzo, cialdeIds);
                res.type("application/json");
                return gson.toJson(bevandaAggiornata);
            } catch (IllegalArgumentException e) {
                res.status(404);
                return gson.toJson(Map.of("errore", e.getMessage()));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'aggiornamento della bevanda: " + e.getMessage()));
        }
    }

    /**
     * Elimina una bevanda.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return risposta vuota o errore
     */
    public Object delete(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            if (bevandaService.eliminaBevanda(id)) {
                res.status(204);
                return "";
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Bevanda non trovata"));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'eliminazione della bevanda: " + e.getMessage()));
        }
    }

    /**
     * Aggiunge una cialda a una bevanda.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return risposta vuota o errore
     */
    @SuppressWarnings("unused")
    public Object aggiungiCialda(Request req, Response res) {
        try {
            int bevandaId = Integer.parseInt(req.params(":id"));
            Type requestType = new TypeToken<Map<String, Object>>(){}.getType();
            Map<String, Object> requestData = gson.fromJson(req.body(), requestType);
            
            Integer cialdaId = ((Number) requestData.get("cialdaId")).intValue();
            if (cialdaId == null) {
                res.status(400);
                return gson.toJson(Map.of("errore", "ID cialda mancante"));
            }

            bevandaService.aggiungiCialda(bevandaId, cialdaId);
            res.status(204);
            return "";
        } catch (IllegalArgumentException e) {
            res.status(404);
            return gson.toJson(Map.of("errore", e.getMessage()));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'aggiunta della cialda: " + e.getMessage()));
        }
    }

    /**
     * Rimuove una cialda da una bevanda.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return risposta vuota o errore
     */
    public Object rimuoviCialda(Request req, Response res) {
        try {
            int bevandaId = Integer.parseInt(req.params(":id"));
            int cialdaId = Integer.parseInt(req.params(":cialdaId"));

            bevandaService.rimuoviCialda(bevandaId, cialdaId);
            res.status(204);
            return "";
        } catch (IllegalArgumentException e) {
            res.status(404);
            return gson.toJson(Map.of("errore", e.getMessage()));
        } catch (IllegalStateException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", e.getMessage()));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nella rimozione della cialda: " + e.getMessage()));
        }
    }
}

================
File: src/main/java/com/vending/api/controllers/IstitutoController.java
================
package com.vending.api.controllers;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.vending.core.models.Istituto;
import com.vending.core.models.Macchina;
import com.vending.core.repositories.IstitutoRepository;
import com.vending.core.repositories.MacchinaRepository;
import spark.Request;
import spark.Response;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Controller per la gestione delle richieste HTTP relative agli istituti.
 */
public class IstitutoController {
    private final IstitutoRepository istitutoRepository;
    private final MacchinaRepository macchinaRepository;
    private final Gson gson;

    /**
     * Costruttore del controller.
     *
     * @param istitutoRepository repository per gli istituti
     * @param macchinaRepository repository per le macchine
     */
    public IstitutoController(IstitutoRepository istitutoRepository, MacchinaRepository macchinaRepository) {
        this.istitutoRepository = istitutoRepository;
        this.macchinaRepository = macchinaRepository;
        this.gson = new Gson();
    }

    /**
     * Recupera tutti gli istituti.
     */
    public Object getAll(Request req, Response res) {
        try {
            List<Istituto> istituti = istitutoRepository.findAll();
            res.type("application/json");
            return gson.toJson(istituti);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero degli istituti: " + e.getMessage()));
        }
    }

    /**
     * Recupera un istituto tramite ID.
     */
    public Object getById(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            Optional<Istituto> istituto = istitutoRepository.findById(id);
            
            if (istituto.isPresent()) {
                Map<String, Object> response = new HashMap<>();
                response.put("istituto", istituto.get());
                response.put("macchineAttive", istitutoRepository.contaMacchineAttive(id));
                
                res.type("application/json");
                return gson.toJson(response);
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Istituto non trovato"));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero dell'istituto: " + e.getMessage()));
        }
    }

    /**
     * Crea un nuovo istituto.
     */
    public Object create(Request req, Response res) {
        try {
            Type requestType = new TypeToken<Map<String, String>>(){}.getType();
            Map<String, String> requestData = gson.fromJson(req.body(), requestType);

            String nome = requestData.get("nome");
            String indirizzo = requestData.get("indirizzo");

            if (nome == null || nome.trim().isEmpty() || indirizzo == null || indirizzo.trim().isEmpty()) {
                res.status(400);
                return gson.toJson(Map.of("errore", "Nome e indirizzo sono obbligatori"));
            }

            if (istitutoRepository.existsByNome(nome)) {
                res.status(400);
                return gson.toJson(Map.of("errore", "Esiste già un istituto con questo nome"));
            }

            Istituto istituto = new Istituto();
            istituto.setNome(nome);
            istituto.setIndirizzo(indirizzo);

            Istituto created = istitutoRepository.save(istituto);
            res.status(201);
            res.type("application/json");
            return gson.toJson(created);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nella creazione dell'istituto: " + e.getMessage()));
        }
    }

    /**
     * Aggiorna un istituto esistente.
     */
    public Object update(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            Optional<Istituto> esistente = istitutoRepository.findById(id);
            
            if (esistente.isEmpty()) {
                res.status(404);
                return gson.toJson(Map.of("errore", "Istituto non trovato"));
            }

            Type requestType = new TypeToken<Map<String, String>>(){}.getType();
            Map<String, String> requestData = gson.fromJson(req.body(), requestType);

            Istituto istituto = esistente.get();
            String nuovoNome = requestData.get("nome");
            String nuovoIndirizzo = requestData.get("indirizzo");

            if (nuovoNome != null && !nuovoNome.equals(istituto.getNome())) {
                if (istitutoRepository.existsByNome(nuovoNome)) {
                    res.status(400);
                    return gson.toJson(Map.of("errore", "Esiste già un istituto con questo nome"));
                }
                istituto.setNome(nuovoNome);
            }

            if (nuovoIndirizzo != null) {
                istituto.setIndirizzo(nuovoIndirizzo);
            }

            Istituto updated = istitutoRepository.update(istituto);
            res.type("application/json");
            return gson.toJson(updated);
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'aggiornamento dell'istituto: " + e.getMessage()));
        }
    }

    /**
     * Elimina un istituto.
     */
    public Object delete(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            try {
                boolean deleted = istitutoRepository.delete(id);
                if (deleted) {
                    res.status(204);
                    return "";
                } else {
                    res.status(404);
                    return gson.toJson(Map.of("errore", "Istituto non trovato"));
                }
            } catch (IllegalStateException e) {
                res.status(400);
                return gson.toJson(Map.of("errore", e.getMessage()));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'eliminazione dell'istituto: " + e.getMessage()));
        }
    }
}

================
File: src/main/java/com/vending/api/controllers/MacchinaController.java
================
package com.vending.api.controllers;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.vending.core.models.Macchina;
import com.vending.core.repositories.MacchinaRepository;
import spark.Request;
import spark.Response;

import java.lang.reflect.Type;
import java.util.List;
import java.util.Map;

/**
 * Controller per la gestione delle richieste HTTP relative alle macchine distributrici.
 */
public class MacchinaController {
    private final MacchinaRepository macchinaRepository;
    private final Gson gson;

    /**
     * Costruttore del controller.
     *
     * @param macchinaRepository repository per le macchine
     */
    public MacchinaController(MacchinaRepository macchinaRepository) {
        this.macchinaRepository = macchinaRepository;
        this.gson = new Gson();
    }

    /**
     * Recupera tutte le macchine.
     */
    public Object getAll(Request req, Response res) {
        try {
            List<Macchina> macchine = macchinaRepository.findAll();
            res.type("application/json");
            return gson.toJson(macchine);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero delle macchine: " + e.getMessage()));
        }
    }

    /**
     * Recupera una macchina tramite ID.
     */
    public Object getById(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            Macchina macchina = macchinaRepository.findById(id);
            
            if (macchina != null) {
                res.type("application/json");
                return gson.toJson(macchina);
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero della macchina: " + e.getMessage()));
        }
    }

    /**
     * Recupera le macchine di un istituto.
     */
    public Object getByIstituto(Request req, Response res) {
        try {
            int istitutoId = Integer.parseInt(req.params(":istitutoId"));
            List<Macchina> macchine = macchinaRepository.findByIstitutoId(istitutoId);
            
            res.type("application/json");
            return gson.toJson(macchine);
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID istituto non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero delle macchine: " + e.getMessage()));
        }
    }

    /**
     * Crea una nuova macchina.
     */
    public Object create(Request req, Response res) {
        try {
            Type requestType = new TypeToken<Map<String, Object>>(){}.getType();
            Map<String, Object> requestData = gson.fromJson(req.body(), requestType);
            
            Macchina macchina = new Macchina();
            macchina.setIstitutoId(((Number) requestData.get("istitutoId")).intValue());
            macchina.setStatoId(1); // Stato iniziale: Attiva
            macchina.setCassaAttuale(0.0);
            macchina.setCassaMassima(((Number) requestData.get("cassaMassima")).doubleValue());

            Macchina nuovaMacchina = macchinaRepository.save(macchina);
            res.status(201);
            res.type("application/json");
            return gson.toJson(nuovaMacchina);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nella creazione della macchina: " + e.getMessage()));
        }
    }

    /**
     * Aggiorna lo stato di una macchina.
     */
    public Object updateStato(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            Type requestType = new TypeToken<Map<String, Object>>(){}.getType();
            Map<String, Object> requestData = gson.fromJson(req.body(), requestType);
            
            int nuovoStatoId = ((Number) requestData.get("statoId")).intValue();
            if (nuovoStatoId < 1 || nuovoStatoId > 3) {
                res.status(400);
                return gson.toJson(Map.of("errore", "Stato non valido"));
            }

            boolean aggiornato = macchinaRepository.aggiornaStato(id, nuovoStatoId);
            if (aggiornato) {
                return gson.toJson(macchinaRepository.findById(id));
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'aggiornamento dello stato: " + e.getMessage()));
        }
    }

    /**
     * Elimina una macchina.
     */
    public Object delete(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            boolean deleted = macchinaRepository.delete(id);
            if (deleted) {
                res.status(204);
                return "";
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'eliminazione della macchina: " + e.getMessage()));
        }
    }
}

================
File: src/main/java/com/vending/api/controllers/ManutenzioneController.java
================
package com.vending.api.controllers;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.vending.core.models.Manutenzione;
import com.vending.core.repositories.ManutenzioneRepository;
import spark.Request;
import spark.Response;

import java.lang.reflect.Type;
import java.util.List;
import java.util.Map;

/**
 * Controller per la gestione delle richieste HTTP relative alle manutenzioni.
 */
public class ManutenzioneController {
    private final ManutenzioneRepository manutenzioneRepository;
    private final Gson gson;

    /**
     * Costruttore del controller.
     *
     * @param manutenzioneRepository repository per le manutenzioni
     */
    public ManutenzioneController(ManutenzioneRepository manutenzioneRepository) {
        this.manutenzioneRepository = manutenzioneRepository;
        this.gson = new Gson();
    }

    /**
     * Recupera tutte le manutenzioni in corso.
     */
    public Object getManutenzioni(Request req, Response res) {
        try {
            List<Manutenzione> manutenzioni = manutenzioneRepository.findAll();
            res.type("application/json");
            return gson.toJson(manutenzioni);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero delle manutenzioni: " + e.getMessage()));
        }
    }

    /**
     * Recupera le manutenzioni di un istituto.
     */
    public Object getManutenzioniIstituto(Request req, Response res) {
        try {
            int istitutoId = Integer.parseInt(req.params(":istitutoId"));
            List<Manutenzione> manutenzioni = manutenzioneRepository.findByIstitutoId(istitutoId);
            res.type("application/json");
            return gson.toJson(manutenzioni);
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID istituto non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero delle manutenzioni: " + e.getMessage()));
        }
    }

    /**
     * Recupera le manutenzioni assegnate a un tecnico.
     */
    public Object getManutenzioniTecnico(Request req, Response res) {
        try {
            int tecnicoId = Integer.parseInt(req.params(":tecnicoId"));
            List<Manutenzione> manutenzioni = manutenzioneRepository.findByTecnicoId(tecnicoId);
            res.type("application/json");
            return gson.toJson(manutenzioni);
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID tecnico non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero delle manutenzioni: " + e.getMessage()));
        }
    }

    /**
     * Inizia una nuova manutenzione.
     */
    public Object iniziaManutenzione(Request req, Response res) {
        try {
            Type requestType = new TypeToken<Map<String, Object>>(){}.getType();
            Map<String, Object> requestData = gson.fromJson(req.body(), requestType);

            int macchinaId = ((Number) requestData.get("macchinaId")).intValue();
            int tecnicoId = ((Number) requestData.get("tecnicoId")).intValue();

            if (macchinaId <= 0 || tecnicoId <= 0) {
                res.status(400);
                return gson.toJson(Map.of("errore", "ID macchina o tecnico non validi"));
            }

            Manutenzione manutenzione = new Manutenzione();
            manutenzione.setMacchinaId(macchinaId);
            manutenzione.setTecnicoId(tecnicoId);

            Manutenzione nuovaManutenzione = manutenzioneRepository.iniziaManutenzione(manutenzione);
            res.status(201);
            res.type("application/json");
            return gson.toJson(nuovaManutenzione);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'avvio della manutenzione: " + e.getMessage()));
        }
    }

    /**
     * Completa una manutenzione.
     */
    public Object completaManutenzione(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));

            return manutenzioneRepository.findById(id)
                .map(manutenzione -> {
                    try {
                        Manutenzione manutenzioneCompletata = manutenzioneRepository.completaManutenzione(manutenzione);
                        res.type("application/json");
                        return gson.toJson(manutenzioneCompletata);
                    } catch (Exception e) {
                        res.status(500);
                        return gson.toJson(Map.of("errore", "Errore nel completamento della manutenzione: " + e.getMessage()));
                    }
                })
                .orElseGet(() -> {
                    res.status(404);
                    return gson.toJson(Map.of("errore", "Manutenzione non trovata"));
                });
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel completamento della manutenzione: " + e.getMessage()));
        }
    }

    /**
     * Imposta una macchina come fuori servizio.
     */
    public Object setFuoriServizio(Request req, Response res) {
        try {
            int macchinaId = Integer.parseInt(req.params(":id"));
            if (manutenzioneRepository.setFuoriServizio(macchinaId)) {
                res.status(204);
                return "";
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'impostazione fuori servizio: " + e.getMessage()));
        }
    }
}

================
File: src/main/java/com/vending/api/middleware/AuthMiddleware.java
================
package com.vending.api.middleware;

import com.google.gson.Gson;
import com.vending.security.jwt.JWTService;
import spark.Request;
import spark.Response;

import java.util.Map;

public class AuthMiddleware {
    private final JWTService jwtService;
    private final Gson gson;

    public AuthMiddleware() {
        this.jwtService = new JWTService();
        this.gson = new Gson();
    }

    public boolean autenticazione(Request req, Response res) {
        String authHeader = req.headers("Authorization");
        
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            res.status(401);
            res.body(gson.toJson(Map.of("errore", "Token di autorizzazione mancante")));
            return false;
        }

        String token = authHeader.substring(7);
        try {
            if (!jwtService.verificaToken(token)) {
                res.status(401);
                res.body(gson.toJson(Map.of("errore", "Token non valido")));
                return false;
            }
            return true;
        } catch (Exception e) {
            res.status(401);
            res.body(gson.toJson(Map.of("errore", "Token non valido")));
            return false;
        }
    }

    public boolean autorizzazioneAdmin(Request req, Response res) {
        String authHeader = req.headers("Authorization");
        String token = authHeader.substring(7);
        
        try {
            String ruolo = jwtService.getRuoloDaToken(token);
            if (!"ADMIN".equals(ruolo)) {
                res.status(403);
                res.body(gson.toJson(Map.of("errore", "Accesso non autorizzato")));
                return false;
            }
            return true;
        } catch (Exception e) {
            res.status(403);
            res.body(gson.toJson(Map.of("errore", "Accesso non autorizzato")));
            return false;
        }
    }
}

================
File: src/main/java/com/vending/api/middleware/CORSMiddleware.java
================
package com.vending.api.middleware;

import spark.Request;
import spark.Response;

public class CORSMiddleware {
    public void applicaCORS(Request req, Response res) {
        res.header("Access-Control-Allow-Origin", "*");
        res.header("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,OPTIONS");
        res.header("Access-Control-Allow-Headers", "Content-Type,Authorization,X-Requested-With,Content-Length,Accept,Origin");
        res.header("Access-Control-Allow-Credentials", "true");
    }

    public void gestisciOpzioniPreflight(Request req, Response res) {
        String accessControlRequestHeaders = req.headers("Access-Control-Request-Headers");
        if (accessControlRequestHeaders != null) {
            res.header("Access-Control-Allow-Headers", accessControlRequestHeaders);
        }

        String accessControlRequestMethod = req.headers("Access-Control-Request-Method");
        if (accessControlRequestMethod != null) {
            res.header("Access-Control-Allow-Methods", accessControlRequestMethod);
        }
    }
}

================
File: src/main/java/com/vending/api/middleware/LogMiddleware.java
================
package com.vending.api.middleware;

import com.vending.utils.log.LogUtil;
import spark.Request;
import spark.Response;

public class LogMiddleware {
    public void logRequest(Request req, Response res) {
        String logMessage = String.format(
            "Request: %s %s - Status: %d - IP: %s",
            req.requestMethod(),
            req.pathInfo(),
            res.status(),
            req.ip()
        );
        LogUtil.info(logMessage);
    }

    public void logError(Request req, Exception e) {
        String errorMessage = String.format(
            "Error in %s %s: %s",
            req.requestMethod(),
            req.pathInfo(),
            e.getMessage()
        );
        LogUtil.error(errorMessage, e);
    }
}

================
File: src/main/java/com/vending/api/routes/Routes.java
================
package com.vending.api.routes;

import com.vending.api.controllers.*;
import com.vending.api.middleware.*;
import static spark.Spark.*;

/**
 * Configurazione delle rotte dell'applicazione.
 * Gestisce il routing delle richieste HTTP ai rispettivi controller
 * e applica i middleware necessari per autenticazione, logging e CORS.
 */
public class Routes {
    private final IstitutoController istitutoController;
    private final MacchinaController macchinaController;
    private final BevandaController bevandaController;
    private final ManutenzioneController manutenzioneController;
    private final AuthMiddleware authMiddleware;
    private final LogMiddleware logMiddleware;
    private final CORSMiddleware corsMiddleware;

    /**
     * Costruttore che inizializza i controller e i middleware necessari.
     *
     * @param istitutoController controller per la gestione degli istituti
     * @param macchinaController controller per la gestione delle macchine distributrici
     * @param bevandaController controller per la gestione delle bevande
     * @param manutenzioneController controller per la gestione delle manutenzioni
     */
    public Routes(IstitutoController istitutoController,
                 MacchinaController macchinaController,
                 BevandaController bevandaController,
                 ManutenzioneController manutenzioneController) {
        this.istitutoController = istitutoController;
        this.macchinaController = macchinaController;
        this.bevandaController = bevandaController;
        this.manutenzioneController = manutenzioneController;
        this.authMiddleware = new AuthMiddleware();
        this.logMiddleware = new LogMiddleware();
        this.corsMiddleware = new CORSMiddleware();
        
        setupRoutes();
    }

    /**
     * Configura tutte le rotte dell'applicazione.
     * Le rotte sono organizzate per entità (istituti, macchine, bevande, manutenzioni)
     * e protette da autenticazione. Alcune operazioni richiedono privilegi amministrativi.
     *
     * Pattern delle rotte:
     * - GET    /api/{entità}          - recupera tutti gli elementi
     * - GET    /api/{entità}/:id      - recupera un elemento specifico
     * - POST   /api/{entità}          - crea un nuovo elemento (richiede admin)
     * - PUT    /api/{entità}/:id      - aggiorna un elemento (richiede admin)
     * - DELETE /api/{entità}/:id      - elimina un elemento (richiede admin)
     */
    private void setupRoutes() {
        // Configurazione CORS
        before((request, response) -> {
            corsMiddleware.applicaCORS(request, response);
        });

        // Logging di tutte le richieste
        after((request, response) -> {
            logMiddleware.logRequest(request, response);
        });
        
        // Rotte protette sotto /api
        path("/api", () -> {
            // Autenticazione richiesta per tutte le rotte /api
            before("/*", authMiddleware::autenticazione);

            // Rotte per la gestione degli istituti
            configureIstitutoRoutes();

            // Rotte per la gestione delle macchine distributrici
            configureMacchinaRoutes();

            // Rotte per la gestione delle bevande
            configureBevandaRoutes();

            // Rotte per la gestione delle manutenzioni
            configureManutenzioneRoutes();
        });
        
        // Gestione centralizzata degli errori
        configureErrorHandling();
    }

    /**
     * Configura le rotte per la gestione degli istituti.
     * Tutte le operazioni di modifica richiedono privilegi amministrativi.
     */
    private void configureIstitutoRoutes() {
        get("/istituti", istitutoController::getAll);
        get("/istituti/:id", istitutoController::getById);
        post("/istituti", (req, res) -> {
            authMiddleware.autorizzazioneAdmin(req, res);
            return istitutoController.create(req, res);
        });
        put("/istituti/:id", (req, res) -> {
            authMiddleware.autorizzazioneAdmin(req, res);
            return istitutoController.update(req, res);
        });
        delete("/istituti/:id", (req, res) -> {
            authMiddleware.autorizzazioneAdmin(req, res);
            return istitutoController.delete(req, res);
        });
    }

    /**
     * Configura le rotte per la gestione delle macchine distributrici.
     * Le operazioni di creazione, modifica e eliminazione richiedono privilegi amministrativi.
     */
    private void configureMacchinaRoutes() {
        get("/macchine", macchinaController::getAll);
        get("/macchine/:id", macchinaController::getById);
        get("/macchine/istituto/:istitutoId", macchinaController::getByIstituto);
        post("/macchine", (req, res) -> {
            authMiddleware.autorizzazioneAdmin(req, res);
            return macchinaController.create(req, res);
        });
        put("/macchine/:id/stato", macchinaController::updateStato);
        delete("/macchine/:id", (req, res) -> {
            authMiddleware.autorizzazioneAdmin(req, res);
            return macchinaController.delete(req, res);
        });
    }

    /**
     * Configura le rotte per la gestione delle bevande.
     * Le operazioni di modifica richiedono privilegi amministrativi.
     */
    private void configureBevandaRoutes() {
        get("/bevande", bevandaController::getAll);
        get("/bevande/:id", bevandaController::getById);
        post("/bevande", (req, res) -> {
            authMiddleware.autorizzazioneAdmin(req, res);
            return bevandaController.create(req, res);
        });
        put("/bevande/:id", (req, res) -> {
            authMiddleware.autorizzazioneAdmin(req, res);
            return bevandaController.update(req, res);
        });
        delete("/bevande/:id", (req, res) -> {
            authMiddleware.autorizzazioneAdmin(req, res);
            return bevandaController.delete(req, res);
        });
        put("/bevande/:id/cialde", (req, res) -> {
            authMiddleware.autorizzazioneAdmin(req, res);
            return bevandaController.aggiungiCialda(req, res);
        });
        delete("/bevande/:id/cialde/:cialdaId", (req, res) -> {
            authMiddleware.autorizzazioneAdmin(req, res);
            return bevandaController.rimuoviCialda(req, res);
        });
    }

    /**
     * Configura le rotte per la gestione delle manutenzioni.
     * Include rotte per la visualizzazione delle manutenzioni per istituto e tecnico,
     * e operazioni di gestione dello stato delle manutenzioni.
     */
    private void configureManutenzioneRoutes() {
        get("/manutenzioni", manutenzioneController::getManutenzioni);
        get("/manutenzioni/istituto/:istitutoId", manutenzioneController::getManutenzioniIstituto);
        get("/manutenzioni/tecnico/:tecnicoId", manutenzioneController::getManutenzioniTecnico);
        post("/manutenzioni", manutenzioneController::iniziaManutenzione);
        put("/manutenzioni/:id/completa", manutenzioneController::completaManutenzione);
        put("/manutenzioni/:id/fuori-servizio", manutenzioneController::setFuoriServizio);
    }
    
    /**
     * Configura la gestione centralizzata degli errori.
     * Tutti gli errori non gestiti vengono catturati, loggati e restituiti come JSON.
     */
    private void configureErrorHandling() {
        exception(Exception.class, (e, req, res) -> {
            res.status(500);
            res.type("application/json");
            res.body("{\"errore\": \"" + e.getMessage() + "\"}");
            logMiddleware.logError(req, e);
        });
    }
}

================
File: src/main/java/com/vending/core/models/AdminLogin.java
================
package com.vending.core.models;

import java.time.LocalDateTime;
import org.mindrot.jbcrypt.BCrypt;

/**
 * Classe che rappresenta le credenziali di accesso amministrativo al sistema.
 * Questa classe riflette la struttura della tabella 'adminlogin' nel database
 * e gestisce l'autenticazione degli utenti amministrativi.
 */
public class AdminLogin {
    private int id;
    private int utenteId;
    private String username;
    private String passwordHash;
    private LocalDateTime ultimoAccesso;
    private Utente utente;  // Relazione con l'entità Utente

    /**
     * Costruttore predefinito.
     */
    public AdminLogin() {
        this.ultimoAccesso = LocalDateTime.now();
    }

    /**
     * Costruttore con parametri principali.
     *
     * @param utenteId ID dell'utente associato
     * @param username Nome utente per l'accesso
     * @param password Password in chiaro che verrà crittografata
     */
    public AdminLogin(int utenteId, String username, String password) {
        this();
        this.utenteId = utenteId;
        this.username = username;
        setPassword(password);
    }

    /**
     * Restituisce l'ID univoco del login amministrativo.
     *
     * @return ID del login
     */
    public int getId() {
        return id;
    }

    /**
     * Imposta l'ID del login amministrativo.
     *
     * @param id Nuovo ID da impostare
     */
    public void setId(int id) {
        this.id = id;
    }

    /**
     * Restituisce l'ID dell'utente associato.
     *
     * @return ID dell'utente
     */
    public int getUtenteId() {
        return utenteId;
    }

    /**
     * Imposta l'ID dell'utente associato.
     *
     * @param utenteId Nuovo ID dell'utente
     */
    public void setUtenteId(int utenteId) {
        this.utenteId = utenteId;
    }

    /**
     * Restituisce il nome utente per l'accesso.
     *
     * @return Nome utente
     */
    public String getUsername() {
        return username;
    }

    /**
     * Imposta il nome utente per l'accesso.
     *
     * @param username Nuovo nome utente
     */
    public void setUsername(String username) {
        this.username = username;
    }

    /**
     * Restituisce l'hash della password.
     *
     * @return Hash della password
     */
    public String getPasswordHash() {
        return passwordHash;
    }

    /**
     * Imposta direttamente l'hash della password.
     * Utile per operazioni di caricamento dal database o sincronizzazione.
     * 
     * @param passwordHash Hash della password da impostare
     */
    public void setPasswordHash(String passwordHash) {
        this.passwordHash = passwordHash;
    }

    /**
     * Imposta e cripta la password.
     * La password viene sottoposta a hashing prima del salvataggio.
     *
     * @param password Password in chiaro da crittografare
     */
    public void setPassword(String password) {
        if (password != null && !password.isEmpty()) {
            this.passwordHash = BCrypt.hashpw(password, BCrypt.gensalt(12));
        }
    }

    /**
     * Restituisce la data e ora dell'ultimo accesso.
     *
     * @return Data e ora dell'ultimo accesso
     */
    public LocalDateTime getUltimoAccesso() {
        return ultimoAccesso;
    }

    /**
     * Imposta la data e ora dell'ultimo accesso.
     *
     * @param ultimoAccesso Nuova data e ora dell'ultimo accesso
     */
    public void setUltimoAccesso(LocalDateTime ultimoAccesso) {
        this.ultimoAccesso = ultimoAccesso;
    }

    /**
     * Restituisce l'utente associato a questo login.
     *
     * @return Oggetto Utente associato
     */
    public Utente getUtente() {
        return utente;
    }

    /**
     * Imposta l'utente associato a questo login.
     *
     * @param utente Nuovo utente da associare
     */
    public void setUtente(Utente utente) {
        this.utente = utente;
        if (utente != null) {
            this.utenteId = utente.getId();
        }
    }

    /**
     * Verifica se la password fornita corrisponde all'hash memorizzato.
     *
     * @param plainTextPassword Password in chiaro da verificare
     * @return true se la password è corretta
     */
    public boolean verificaPassword(String plainTextPassword) {
        if (plainTextPassword == null || plainTextPassword.isEmpty() || passwordHash == null) {
            return false;
        }
        return BCrypt.checkpw(plainTextPassword, passwordHash);
    }

    /**
     * Aggiorna l'ultimo accesso al momento corrente.
     */
    public void aggiornaUltimoAccesso() {
        this.ultimoAccesso = LocalDateTime.now();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        AdminLogin that = (AdminLogin) o;
        return id == that.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }

    @Override
    public String toString() {
        return "AdminLogin{" +
               "id=" + id +
               ", utenteId=" + utenteId +
               ", username='" + username + '\'' +
               ", ultimoAccesso=" + ultimoAccesso +
               '}';
    }
}

================
File: src/main/java/com/vending/core/models/Bevanda.java
================
package com.vending.core.models;

import java.util.ArrayList;
import java.util.List;

/**
 * Modello che rappresenta una bevanda disponibile nei distributori automatici.
 * Questa classe riflette la struttura della tabella 'bevanda' nel database
 * e gestisce le relazioni con le cialde attraverso la tabella 'bevandahacialda'.
 */
public class Bevanda {
    private int id;
    private String nome;
    private double prezzo;
    private List<Cialda> cialde;
    private String composizioneCialde; // Campo per la vista BevandeCialdeECosti

    /**
     * Costruttore predefinito.
     * Inizializza la lista delle cialde associate alla bevanda.
     */
    public Bevanda() {
        this.cialde = new ArrayList<>();
    }

    /**
     * Costruttore con parametri principali.
     *
     * @param nome Nome della bevanda
     * @param prezzo Prezzo della bevanda
     */
    public Bevanda(String nome, double prezzo) {
        this();
        this.nome = nome;
        this.prezzo = prezzo;
    }

    /**
     * Restituisce l'ID univoco della bevanda.
     *
     * @return ID della bevanda
     */
    public int getId() {
        return id;
    }

    /**
     * Imposta l'ID della bevanda.
     *
     * @param id Nuovo ID da impostare
     */
    public void setId(int id) {
        this.id = id;
    }

    /**
     * Restituisce il nome della bevanda.
     *
     * @return Nome della bevanda
     */
    public String getNome() {
        return nome;
    }

    /**
     * Imposta il nome della bevanda.
     *
     * @param nome Nuovo nome da impostare
     */
    public void setNome(String nome) {
        this.nome = nome;
    }

    /**
     * Restituisce il prezzo della bevanda.
     *
     * @return Prezzo della bevanda in double
     */
    public double getPrezzo() {
        return prezzo;
    }

    /**
     * Imposta il prezzo della bevanda.
     *
     * @param prezzo Nuovo prezzo da impostare
     */
    public void setPrezzo(double prezzo) {
        this.prezzo = prezzo;
    }

    /**
     * Restituisce la lista delle cialde necessarie per preparare la bevanda.
     *
     * @return Lista delle cialde associate
     */
    public List<Cialda> getCialde() {
        return cialde;
    }

    /**
     * Imposta la lista delle cialde necessarie per la bevanda.
     *
     * @param cialde Nuova lista di cialde
     */
    public void setCialde(List<Cialda> cialde) {
        this.cialde = cialde;
    }

    /**
     * Restituisce la descrizione della composizione delle cialde.
     * Questo campo viene popolato dalla vista BevandeCialdeECosti.
     *
     * @return Stringa contenente l'elenco delle cialde
     */
    public String getComposizioneCialde() {
        return composizioneCialde;
    }

    /**
     * Imposta la descrizione della composizione delle cialde.
     *
     * @param composizioneCialde Nuova descrizione della composizione
     */
    public void setComposizioneCialde(String composizioneCialde) {
        this.composizioneCialde = composizioneCialde;
    }

    /**
     * Verifica se la bevanda è disponibile in base alla presenza delle cialde necessarie.
     *
     * @param quantitaCialde Mappa delle quantità di cialde disponibili
     * @return true se tutte le cialde necessarie sono disponibili in quantità sufficiente
     */
    public boolean isDisponibile(List<QuantitaCialde> quantitaCialde) {
        for (Cialda cialda : cialde) {
            boolean cialdaDisponibile = quantitaCialde.stream()
                .anyMatch(qc -> qc.getCialdaId() == cialda.getId() && qc.getQuantita() > 0);
            if (!cialdaDisponibile) {
                return false;
            }
        }
        return true;
    }

    /**
     * Aggiunge una cialda alla lista delle cialde necessarie per la bevanda.
     * Verifica che la cialda non sia già presente prima di aggiungerla.
     *
     * @param cialda Cialda da aggiungere
     */
    public void aggiungiCialda(Cialda cialda) {
        if (!cialde.contains(cialda)) {
            cialde.add(cialda);
        }
    }

    /**
     * Rimuove una cialda dalla lista delle cialde necessarie per la bevanda.
     *
     * @param cialda Cialda da rimuovere
     */
    public void rimuoviCialda(Cialda cialda) {
        cialde.remove(cialda);
    }

    /**
     * Calcola il numero totale di cialde necessarie per preparare la bevanda.
     *
     * @return Numero totale di cialde richieste
     */
    public int getNumeroCialdeNecessarie() {
        return cialde.size();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bevanda bevanda = (Bevanda) o;
        return id == bevanda.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }
}

================
File: src/main/java/com/vending/core/models/Cialda.java
================
package com.vending.core.models;

/**
 * Modello che rappresenta una cialda utilizzata nelle macchine distributrici.
 * Questa classe riflette la struttura della tabella 'cialda' nel database
 * e viene utilizzata nelle relazioni con le bevande attraverso la tabella 'bevandahacialda'.
 */
public class Cialda {
    private int id;
    private String nome;
    private String tipoCialda;

    /**
     * Costruttore predefinito.
     * Inizializza una nuova istanza di Cialda senza parametri.
     */
    public Cialda() {}

    /**
     * Costruttore con parametri principali.
     *
     * @param nome Nome della cialda
     * @param tipoCialda Tipo della cialda (es. Caffè, Tè, Tisana, Additivo)
     */
    public Cialda(String nome, String tipoCialda) {
        this.nome = nome;
        this.tipoCialda = tipoCialda;
    }

    /**
     * Restituisce l'ID univoco della cialda.
     *
     * @return ID della cialda
     */
    public int getId() {
        return id;
    }

    /**
     * Imposta l'ID della cialda.
     *
     * @param id Nuovo ID da impostare
     */
    public void setId(int id) {
        this.id = id;
    }

    /**
     * Restituisce il nome della cialda.
     *
     * @return Nome della cialda
     */
    public String getNome() {
        return nome;
    }

    /**
     * Imposta il nome della cialda.
     *
     * @param nome Nuovo nome da impostare
     */
    public void setNome(String nome) {
        this.nome = nome;
    }

    /**
     * Restituisce il tipo della cialda.
     * I tipi possibili includono: Caffè, Tè, Tisana, Additivo, ecc.
     *
     * @return Tipo della cialda
     */
    public String getTipoCialda() {
        return tipoCialda;
    }

    /**
     * Imposta il tipo della cialda.
     *
     * @param tipoCialda Nuovo tipo da impostare
     */
    public void setTipoCialda(String tipoCialda) {
        this.tipoCialda = tipoCialda;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Cialda cialda = (Cialda) o;
        return id == cialda.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }

    @Override
    public String toString() {
        return "Cialda{" +
               "id=" + id +
               ", nome='" + nome + '\'' +
               ", tipoCialda='" + tipoCialda + '\'' +
               '}';
    }
}

================
File: src/main/java/com/vending/core/models/Istituto.java
================
package com.vending.core.models;

import java.util.ArrayList;
import java.util.List;

/**
 * Modello che rappresenta un istituto dove sono installate le macchine distributrici.
 * Questa classe riflette la struttura della tabella 'istituto' nel database
 * e gestisce la relazione one-to-many con le macchine.
 */
public class Istituto {
    private int ID_istituto;
    private String nome;
    private String indirizzo;
    private List<Macchina> macchine;

    /**
     * Costruttore predefinito.
     * Inizializza la lista delle macchine associate all'istituto.
     */
    public Istituto() {
        this.macchine = new ArrayList<>();
    }

    /**
     * Costruttore con parametri principali.
     *
     * @param nome Nome dell'istituto
     * @param indirizzo Indirizzo completo dell'istituto
     */
    public Istituto(String nome, String indirizzo) {
        this();
        this.nome = nome;
        this.indirizzo = indirizzo;
    }

    /**
     * Restituisce l'ID univoco dell'istituto.
     *
     * @return ID dell'istituto
     */
    public int getId() {
        return ID_istituto;
    }

    /**
     * Imposta l'ID dell'istituto.
     *
     * @param id Nuovo ID da impostare
     */
    public void setId(int id) {
        this.ID_istituto = id;
    }

    /**
     * Restituisce il nome dell'istituto.
     *
     * @return Nome dell'istituto
     */
    public String getNome() {
        return nome;
    }

    /**
     * Imposta il nome dell'istituto.
     *
     * @param nome Nuovo nome da impostare
     */
    public void setNome(String nome) {
        this.nome = nome;
    }

    /**
     * Restituisce l'indirizzo dell'istituto.
     *
     * @return Indirizzo completo dell'istituto
     */
    public String getIndirizzo() {
        return indirizzo;
    }

    /**
     * Imposta l'indirizzo dell'istituto.
     *
     * @param indirizzo Nuovo indirizzo da impostare
     */
    public void setIndirizzo(String indirizzo) {
        this.indirizzo = indirizzo;
    }

    /**
     * Restituisce la lista delle macchine installate nell'istituto.
     *
     * @return Lista delle macchine associate
     */
    public List<Macchina> getMacchine() {
        return macchine;
    }

    /**
     * Imposta la lista delle macchine installate nell'istituto.
     *
     * @param macchine Nuova lista di macchine
     */
    public void setMacchine(List<Macchina> macchine) {
        this.macchine = macchine;
    }

    /**
     * Aggiunge una macchina alla lista delle macchine dell'istituto.
     *
     * @param macchina Macchina da aggiungere
     */
    public void aggiungiMacchina(Macchina macchina) {
        macchine.add(macchina);
    }

    /**
     * Rimuove una macchina dalla lista delle macchine dell'istituto.
     *
     * @param macchina Macchina da rimuovere
     */
    public void rimuoviMacchina(Macchina macchina) {
        macchine.remove(macchina);
    }

    /**
     * Conta il numero di macchine attive nell'istituto.
     *
     * @return Numero di macchine con stato "Attiva"
     */
    public long contaMacchineAttive() {
        return macchine.stream()
                .filter(m -> m.getStatoId() == 1) // 1 = Attiva nella tabella statomacchina
                .count();
    }

    /**
     * Verifica se l'istituto ha almeno una macchina installata.
     *
     * @return true se l'istituto ha almeno una macchina
     */
    public boolean haMacchine() {
        return !macchine.isEmpty();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Istituto istituto = (Istituto) o;
        return ID_istituto == istituto.ID_istituto;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(ID_istituto);
    }

    @Override
    public String toString() {
        return "Istituto{" +
               "ID_istituto=" + ID_istituto +
               ", nome='" + nome + '\'' +
               ", indirizzo='" + indirizzo + '\'' +
               ", numeroMacchine=" + macchine.size() +
               '}';
    }
}

================
File: src/main/java/com/vending/core/models/Macchina.java
================
package com.vending.core.models;

import java.util.ArrayList;
import java.util.List;

/**
 * Modello che rappresenta una macchina distributrice automatica.
 * Si basa sulla struttura del database definita nella tabella 'macchina'
 * e nelle sue relazioni.
 */
public class Macchina {
    private int id;
    private int istitutoId;
    private String nomeIstituto;
    private int statoId;
    private String statoDescrizione;
    private double cassaAttuale;
    private double cassaMassima;
    private double creditoAttuale;
    private List<QuantitaCialde> cialde;
    private List<Bevanda> bevande;

    /**
     * Costruttore predefinito che inizializza le liste e imposta i valori predefiniti.
     * Lo stato predefinito è 1 (Attiva) come definito nella tabella 'statomacchina'.
     */
    public Macchina() {
        this.cialde = new ArrayList<>();
        this.bevande = new ArrayList<>();
        this.creditoAttuale = 0.0;
        this.statoId = 1; // Stato "Attiva" come da tabella statomacchina
        this.cassaAttuale = 0.0;
    }

    // Getters e Setters
    /**
     * @return ID univoco della macchina
     */
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }

    /**
     * @return ID dell'istituto dove è installata la macchina
     */
    public int getIstitutoId() { return istitutoId; }
    public void setIstitutoId(int istitutoId) { this.istitutoId = istitutoId; }

    /**
     * @return Nome dell'istituto dove è installata la macchina
     */
    public String getNomeIstituto() { return nomeIstituto; }
    public void setNomeIstituto(String nomeIstituto) { this.nomeIstituto = nomeIstituto; }

    /**
     * @return ID dello stato della macchina dalla tabella 'statomacchina'
     */
    public int getStatoId() { return statoId; }
    public void setStatoId(int statoId) { this.statoId = statoId; }

    /**
     * @return Descrizione testuale dello stato della macchina
     */
    public String getStatoDescrizione() { return statoDescrizione; }
    public void setStatoDescrizione(String statoDescrizione) { this.statoDescrizione = statoDescrizione; }

    /**
     * @return Ammontare corrente in cassa
     */
    public double getCassaAttuale() { return cassaAttuale; }
    public void setCassaAttuale(double cassaAttuale) { this.cassaAttuale = cassaAttuale; }

    /**
     * @return Capacità  massima della cassa
     */
    public double getCassaMassima() { return cassaMassima; }
    public void setCassaMassima(double cassaMassima) { this.cassaMassima = cassaMassima; }

    /**
     * @return Credito attualmente inserito dall'utente
     */
    public double getCreditoAttuale() { return creditoAttuale; }
    public void setCreditoAttuale(double creditoAttuale) { this.creditoAttuale = creditoAttuale; }

    /**
     * @return Lista delle quantità  di cialde disponibili
     */
    public List<QuantitaCialde> getCialde() { return cialde; }
    public void setCialde(List<QuantitaCialde> cialde) { this.cialde = cialde; }

    /**
     * @return Lista delle bevande disponibili
     */
    public List<Bevanda> getBevande() { return bevande; }
    public void setBevande(List<Bevanda> bevande) { this.bevande = bevande; }

    
    /**
     * Verifica se la macchina può accettare un determinato importo.
     * 
     * @param importo Importo da verificare
     * @return true se l'importo può essere accettato
     */
    public boolean puoAccettareDenaro(double importo) {
        if(cassaAttuale+creditoAttuale+importo > cassaMassima) {
            return false;
        }
        else {
            return true;
        }
    }

    /**
     * Verifica se c'è credito sufficiente per una erogazione.
     * 
     * @param importo Importo da verificare
     * @return true se il credito è sufficiente
     */
    public boolean hasCreditorSufficiente(double importo) {
        if(creditoAttuale >= importo) {
            return true;
        }
        else {
            return false;
        }
    }

    /**
     * Verifica se la cassa ha raggiunto la capacità  massima.
     * 
     * @return true se la cassa è piena
     */
    public boolean isCassaPiena() {
        if(cassaAttuale == cassaMassima) {
            return true;
        }
        else {
            return false;
        }
    }

    /**
     * Verifica se la macchina è attiva e operativa.
     * 
     * @return true se la macchina è attiva
     */
    public boolean isAttiva() {
        return statoId == 1; // 1 = Attiva nella tabella statomacchina
    }

    /**
     * Aggiunge una bevanda alla lista delle bevande disponibili.
     * 
     * @param bevanda Bevanda da aggiungere
     */
    public void aggiungiBevanda(Bevanda bevanda) {
        bevande.add(bevanda);
    }

    /**
     * Aggiunge una quantità  di cialde alla lista.
     * 
     * @param cialda QuantitaCialde da aggiungere
     */
    public void aggiungiCialda(QuantitaCialde cialda) {
        cialde.add(cialda);
    }
}

================
File: src/main/java/com/vending/core/models/Manutenzione.java
================
package com.vending.core.models;

import java.time.LocalDateTime;
import java.util.List;
import java.util.ArrayList;

/**
 * Modello che rappresenta una richiesta di manutenzione per una macchina distributrice.
 * La classe gestisce le informazioni relative agli interventi di manutenzione,
 * integrando i dati dello stato della macchina e delle necessità di rifornimento.
 */
public class Manutenzione {
    private int id;
    private int macchinaId;
    private String nomeIstituto;  // Dal JOIN con la tabella istituto
    private int statoId;          // Riferimento a statomacchina
    private String statoDescrizione; // Dalla tabella statomacchina
    private LocalDateTime dataRichiesta;
    private LocalDateTime dataCompletamento;
    private int tecnicoId;        // Riferimento alla tabella utente
    private String nomeTecnico;   // Dal JOIN con la tabella utente
    private String note;
    private double cassaAttuale;  // Dalla tabella macchina
    private double cassaMassima;  // Dalla tabella macchina
    private List<QuantitaCialde> cialdeDaRifornire;

    /**
     * Costruttore predefinito.
     * Inizializza una nuova richiesta di manutenzione con data corrente.
     */
    public Manutenzione() {
        this.dataRichiesta = LocalDateTime.now();
        this.statoId = 2;  // Stato "In manutenzione" dalla tabella statomacchina
        this.cialdeDaRifornire = new ArrayList<>();
    }

    /**
     * Costruttore con parametri principali.
     *
     * @param macchinaId ID della macchina che richiede manutenzione
     * @param statoId ID dello stato dalla tabella statomacchina
     */
    public Manutenzione(int macchinaId, int statoId) {
        this();
        this.macchinaId = macchinaId;
        this.statoId = statoId;
    }

    /**
     * Restituisce l'ID della manutenzione.
     *
     * @return ID della manutenzione
     */
    public int getId() {
        return id;
    }

    /**
     * Imposta l'ID della manutenzione.
     *
     * @param id Nuovo ID da impostare
     */
    public void setId(int id) {
        this.id = id;
    }

    /**
     * Restituisce l'ID della macchina in manutenzione.
     *
     * @return ID della macchina
     */
    public int getMacchinaId() {
        return macchinaId;
    }

    /**
     * Imposta l'ID della macchina in manutenzione.
     *
     * @param macchinaId Nuovo ID della macchina
     */
    public void setMacchinaId(int macchinaId) {
        this.macchinaId = macchinaId;
    }

    /**
     * Restituisce il nome dell'istituto dove si trova la macchina.
     *
     * @return Nome dell'istituto
     */
    public String getNomeIstituto() {
        return nomeIstituto;
    }

    /**
     * Imposta il nome dell'istituto.
     *
     * @param nomeIstituto Nuovo nome dell'istituto
     */
    public void setNomeIstituto(String nomeIstituto) {
        this.nomeIstituto = nomeIstituto;
    }

    /**
     * Restituisce l'ID dello stato della manutenzione.
     *
     * @return ID dello stato
     */
    public int getStatoId() {
        return statoId;
    }

    /**
     * Imposta l'ID dello stato della manutenzione.
     *
     * @param statoId Nuovo ID dello stato
     */
    public void setStatoId(int statoId) {
        this.statoId = statoId;
    }

    /**
     * Restituisce la descrizione dello stato.
     *
     * @return Descrizione dello stato
     */
    public String getStatoDescrizione() {
        return statoDescrizione;
    }

    /**
     * Imposta la descrizione dello stato.
     *
     * @param statoDescrizione Nuova descrizione dello stato
     */
    public void setStatoDescrizione(String statoDescrizione) {
        this.statoDescrizione = statoDescrizione;
    }

    /**
     * Restituisce la data di richiesta della manutenzione.
     *
     * @return Data di richiesta
     */
    public LocalDateTime getDataRichiesta() {
        return dataRichiesta;
    }

    /**
     * Imposta la data di richiesta della manutenzione.
     *
     * @param dataRichiesta Nuova data di richiesta
     */
    public void setDataRichiesta(LocalDateTime dataRichiesta) {
        this.dataRichiesta = dataRichiesta;
    }

    /**
     * Restituisce la data di completamento della manutenzione.
     *
     * @return Data di completamento
     */
    public LocalDateTime getDataCompletamento() {
        return dataCompletamento;
    }

    /**
     * Imposta la data di completamento della manutenzione.
     *
     * @param dataCompletamento Nuova data di completamento
     */
    public void setDataCompletamento(LocalDateTime dataCompletamento) {
        this.dataCompletamento = dataCompletamento;
    }

    /**
     * Restituisce l'ID del tecnico assegnato.
     *
     * @return ID del tecnico
     */
    public int getTecnicoId() {
        return tecnicoId;
    }

    /**
     * Imposta l'ID del tecnico assegnato.
     *
     * @param tecnicoId Nuovo ID del tecnico
     */
    public void setTecnicoId(int tecnicoId) {
        this.tecnicoId = tecnicoId;
    }

    /**
     * Restituisce il nome del tecnico assegnato.
     *
     * @return Nome del tecnico
     */
    public String getNomeTecnico() {
        return nomeTecnico;
    }

    /**
     * Imposta il nome del tecnico assegnato.
     *
     * @param nomeTecnico Nuovo nome del tecnico
     */
    public void setNomeTecnico(String nomeTecnico) {
        this.nomeTecnico = nomeTecnico;
    }

    /**
     * Restituisce le note della manutenzione.
     *
     * @return Note della manutenzione
     */
    public String getNote() {
        return note;
    }

    /**
     * Imposta le note della manutenzione.
     *
     * @param note Nuove note da impostare
     */
    public void setNote(String note) {
        this.note = note;
    }

    /**
     * Restituisce la lista delle cialde da rifornire.
     *
     * @return Lista delle cialde da rifornire
     */
    public List<QuantitaCialde> getCialdeDaRifornire() {
        return cialdeDaRifornire;
    }

    /**
     * Imposta la lista delle cialde da rifornire.
     *
     * @param cialdeDaRifornire Nuova lista delle cialde da rifornire
     */
    public void setCialdeDaRifornire(List<QuantitaCialde> cialdeDaRifornire) {
        this.cialdeDaRifornire = cialdeDaRifornire;
    }

    /**
     * Verifica se la macchina è in manutenzione.
     *
     * @return true se la macchina è in manutenzione
     */
    public boolean isInManutenzione() {
        return statoId == 2; // 2 = In manutenzione nella tabella statomacchina
    }

    /**
     * Verifica se la macchina è fuori servizio.
     *
     * @return true se la macchina è fuori servizio
     */
    public boolean isFuoriServizio() {
        return statoId == 3; // 3 = Fuori servizio nella tabella statomacchina
    }

    /**
     * Calcola la durata della manutenzione in minuti.
     *
     * @return Durata in minuti, -1 se la manutenzione non è completata
     */
    public long getDurataInMinuti() {
        if (dataCompletamento == null) {
            return -1;
        }
        return java.time.Duration.between(dataRichiesta, dataCompletamento).toMinutes();
    }

    /**
     * Completa la manutenzione impostando lo stato a "Attiva".
     *
     * @param note Note di completamento
     */
    public void completaManutenzione(String note) {
        this.statoId = 1; // 1 = Attiva nella tabella statomacchina
        this.dataCompletamento = LocalDateTime.now();
        this.note = note;
    }

    /**
     * Verifica se la manutenzione è stata completata.
     * Una manutenzione si considera completata quando ha una data di completamento impostata.
     *
     * @return true se la manutenzione è completata, false altrimenti
     */
    public boolean isCompletata() {
        if(statoId == 1 && dataCompletamento != null) {
            return true;
        }else {
            return false;
        }
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Manutenzione that = (Manutenzione) o;
        return id == that.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }

    @Override
    public String toString() {
        return "Manutenzione{" +
               "id=" + id +
               ", macchinaId=" + macchinaId +
               ", nomeIstituto='" + nomeIstituto + '\'' +
               ", statoDescrizione='" + statoDescrizione + '\'' +
               ", dataRichiesta=" + dataRichiesta +
               ", tecnico='" + nomeTecnico + '\'' +
               '}';
    }
}

================
File: src/main/java/com/vending/core/models/QuantitaCialde.java
================
package com.vending.core.models;

/**
 * Modello che rappresenta la quantità di cialde disponibili in una macchina.
 * Questa classe riflette la struttura della tabella 'quantitacialde' nel database
 * e gestisce le relazioni con le tabelle 'macchina' e 'cialda'.
 */
public class QuantitaCialde {
    private int id;
    private int macchinaId;
    private int cialdaId;
    private String nomeCialda;    // Dal JOIN con la tabella cialda
    private String tipoCialda;    // Dal JOIN con la tabella cialda
    private int quantita;
    private int quantitaMassima;
    private int sogliaMinima;     // Calcolato come 20% della quantità massima

    /**
     * Costruttore predefinito.
     */
    public QuantitaCialde() {
        this.sogliaMinima = 0;
    }

    /**
     * Costruttore con parametri principali.
     *
     * @param macchinaId ID della macchina
     * @param cialdaId ID della cialda
     * @param quantita Quantità attuale di cialde
     * @param quantitaMassima Quantità massima di cialde
     */
    public QuantitaCialde(int macchinaId, int cialdaId, int quantita, int quantitaMassima) {
        this.macchinaId = macchinaId;
        this.cialdaId = cialdaId;
        this.quantita = quantita;
        this.quantitaMassima = quantitaMassima;
        this.sogliaMinima = calcolaSogliaMinima();
    }

    /**
     * Restituisce l'ID univoco del record.
     *
     * @return ID del record di quantità cialde
     */
    public int getId() {
        return id;
    }

    /**
     * Imposta l'ID del record.
     *
     * @param id Nuovo ID da impostare
     */
    public void setId(int id) {
        this.id = id;
    }

    /**
     * Restituisce l'ID della macchina.
     *
     * @return ID della macchina
     */
    public int getMacchinaId() {
        return macchinaId;
    }

    /**
     * Imposta l'ID della macchina.
     *
     * @param macchinaId Nuovo ID della macchina
     */
    public void setMacchinaId(int macchinaId) {
        this.macchinaId = macchinaId;
    }

    /**
     * Restituisce l'ID della cialda.
     *
     * @return ID della cialda
     */
    public int getCialdaId() {
        return cialdaId;
    }

    /**
     * Imposta l'ID della cialda.
     *
     * @param cialdaId Nuovo ID della cialda
     */
    public void setCialdaId(int cialdaId) {
        this.cialdaId = cialdaId;
    }

    /**
     * Restituisce il nome della cialda.
     *
     * @return Nome della cialda
     */
    public String getNomeCialda() {
        return nomeCialda;
    }

    /**
     * Imposta il nome della cialda.
     *
     * @param nomeCialda Nuovo nome della cialda
     */
    public void setNomeCialda(String nomeCialda) {
        this.nomeCialda = nomeCialda;
    }

    /**
     * Restituisce il tipo della cialda.
     *
     * @return Tipo della cialda
     */
    public String getTipoCialda() {
        return tipoCialda;
    }

    /**
     * Imposta il tipo della cialda.
     *
     * @param tipoCialda Nuovo tipo della cialda
     */
    public void setTipoCialda(String tipoCialda) {
        this.tipoCialda = tipoCialda;
    }

    /**
     * Restituisce la quantità attuale di cialde.
     *
     * @return Quantità attuale
     */
    public int getQuantita() {
        return quantita;
    }

    /**
     * Imposta la quantità di cialde.
     *
     * @param quantita Nuova quantità da impostare
     */
    public void setQuantita(int quantita) {
        this.quantita = quantita;
    }

    /**
     * Restituisce la quantità massima di cialde.
     *
     * @return Quantità massima
     */
    public int getQuantitaMassima() {
        return quantitaMassima;
    }

    /**
     * Imposta la quantità massima di cialde e ricalcola la soglia minima.
     *
     * @param quantitaMassima Nuova quantità massima
     */
    public void setQuantitaMassima(int quantitaMassima) {
        this.quantitaMassima = quantitaMassima;
        this.sogliaMinima = calcolaSogliaMinima();
    }

    /**
     * Restituisce la soglia minima di cialde.
     *
     * @return Soglia minima
     */
    public int getSogliaMinima() {
        return sogliaMinima;
    }

    /**
     * Calcola la soglia minima come 20% della quantità massima.
     *
     * @return Soglia minima calcolata
     */
    private int calcolaSogliaMinima() {
        return (int) (quantitaMassima * 0.2);
    }

    /**
     * Verifica se è necessario il rifornimento delle cialde.
     *
     * @return true se la quantità è sotto la soglia minima
     */
    public boolean necessitaRifornimento() {
        return quantita <= sogliaMinima;
    }

    /**
     * Verifica se c'è una quantità sufficiente di cialde.
     *
     * @param quantitaRichiesta Quantità necessaria
     * @return true se la quantità disponibile è sufficiente
     */
    public boolean haQuantitaSufficiente(int quantitaRichiesta) {
        return quantita >= quantitaRichiesta;
    }

    /**
     * Decrementa la quantità di cialde di una unità.
     */
    public void decrementaQuantita() {
        if (quantita > 0) {
            quantita--;
        }
    }

    /**
     * Riempie il contenitore di cialde alla quantità massima.
     */
    public void rifornisci() {
        this.quantita = this.quantitaMassima;
    }

    /**
     * Calcola la quantità di cialde da rifornire.
     *
     * @return Quantità necessaria per il rifornimento completo
     */
    public int getQuantitaDaRifornire() {
        return quantitaMassima - quantita;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        QuantitaCialde that = (QuantitaCialde) o;
        return id == that.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }

    @Override
    public String toString() {
        return "QuantitaCialde{" +
               "id=" + id +
               ", macchinaId=" + macchinaId +
               ", nomeCialda='" + nomeCialda + '\'' +
               ", quantita=" + quantita +
               ", quantitaMassima=" + quantitaMassima +
               ", necessitaRifornimento=" + necessitaRifornimento() +
               '}';
    }
}

================
File: src/main/java/com/vending/core/models/Ricavo.java
================
package com.vending.core.models;

import java.time.LocalDateTime;

/**
 * Modello che rappresenta un ricavo da una macchina distributrice.
 * Questa classe riflette la struttura della tabella 'ricavo' nel database
 * e include informazioni aggiuntive dall'istituto associato.
 */
public class Ricavo {
    private int id;
    private int macchinaId;
    private String nomeIstituto;    // Dal JOIN con la tabella istituto
    private double importo;
    private LocalDateTime dataOra;
    private String indirizzoIstituto; // Dal JOIN con la tabella istituto
    private double ricavoGiornaliero; // Dalla vista ricavigiornalieri

    /**
     * Costruttore predefinito.
     * Inizializza la data e ora al momento corrente.
     */
    public Ricavo() {
        this.dataOra = LocalDateTime.now();
    }

    /**
     * Costruttore con parametri principali.
     *
     * @param macchinaId ID della macchina che ha generato il ricavo
     * @param importo Importo del ricavo
     */
    public Ricavo(int macchinaId, double importo) {
        this();
        this.macchinaId = macchinaId;
        this.importo = importo;
    }

    /**
     * Restituisce l'ID univoco del ricavo.
     *
     * @return ID del ricavo
     */
    public int getId() {
        return id;
    }

    /**
     * Imposta l'ID del ricavo.
     *
     * @param id Nuovo ID da impostare
     */
    public void setId(int id) {
        this.id = id;
    }

    /**
     * Restituisce l'ID della macchina che ha generato il ricavo.
     *
     * @return ID della macchina
     */
    public int getMacchinaId() {
        return macchinaId;
    }

    /**
     * Imposta l'ID della macchina.
     *
     * @param macchinaId Nuovo ID della macchina
     */
    public void setMacchinaId(int macchinaId) {
        this.macchinaId = macchinaId;
    }

    /**
     * Restituisce il nome dell'istituto dove si trova la macchina.
     *
     * @return Nome dell'istituto
     */
    public String getNomeIstituto() {
        return nomeIstituto;
    }

    /**
     * Imposta il nome dell'istituto.
     *
     * @param nomeIstituto Nuovo nome dell'istituto
     */
    public void setNomeIstituto(String nomeIstituto) {
        this.nomeIstituto = nomeIstituto;
    }

    /**
     * Restituisce l'importo del ricavo.
     *
     * @return Importo del ricavo
     */
    public double getImporto() {
        return importo;
    }

    /**
     * Imposta l'importo del ricavo.
     *
     * @param importo Nuovo importo da impostare
     */
    public void setImporto(double importo) {
        this.importo = importo;
    }

    /**
     * Restituisce la data e ora del ricavo.
     *
     * @return Data e ora del ricavo
     */
    public LocalDateTime getDataOra() {
        return dataOra;
    }

    /**
     * Imposta la data e ora del ricavo.
     *
     * @param dataOra Nuova data e ora da impostare
     */
    public void setDataOra(LocalDateTime dataOra) {
        this.dataOra = dataOra;
    }

    /**
     * Restituisce l'indirizzo dell'istituto.
     *
     * @return Indirizzo dell'istituto
     */
    public String getIndirizzoIstituto() {
        return indirizzoIstituto;
    }

    /**
     * Imposta l'indirizzo dell'istituto.
     *
     * @param indirizzoIstituto Nuovo indirizzo dell'istituto
     */
    public void setIndirizzoIstituto(String indirizzoIstituto) {
        this.indirizzoIstituto = indirizzoIstituto;
    }

    /**
     * Restituisce il ricavo giornaliero totale.
     *
     * @return Ricavo giornaliero
     */
    public double getRicavoGiornaliero() {
        return ricavoGiornaliero;
    }

    /**
     * Imposta il ricavo giornaliero totale.
     *
     * @param ricavoGiornaliero Nuovo ricavo giornaliero
     */
    public void setRicavoGiornaliero(double ricavoGiornaliero) {
        this.ricavoGiornaliero = ricavoGiornaliero;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Ricavo ricavo = (Ricavo) o;
        return id == ricavo.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }

    @Override
    public String toString() {
        return "Ricavo{" +
               "id=" + id +
               ", macchinaId=" + macchinaId +
               ", nomeIstituto='" + nomeIstituto + '\'' +
               ", importo=" + importo +
               ", dataOra=" + dataOra +
               '}';
    }
}

================
File: src/main/java/com/vending/core/models/StatoMacchina.java
================
package com.vending.core.models;

/**
 * Modello che rappresenta lo stato possibile di una macchina distributrice.
 * Questa classe riflette la struttura della tabella 'statomacchina' nel database,
 * che definisce gli stati possibili per le macchine distributrici.
 */
public class StatoMacchina {
    private int id;
    private String descrizione;
    
    /**
     * Costanti che rappresentano gli stati predefiniti dal database.
     */
    public static final int STATO_ATTIVA = 1;
    public static final int STATO_IN_MANUTENZIONE = 2;
    public static final int STATO_FUORI_SERVIZIO = 3;

    /**
     * Costruttore predefinito.
     */
    public StatoMacchina() {}

    /**
     * Costruttore con parametri principali.
     *
     * @param id ID dello stato
     * @param descrizione Descrizione dello stato
     */
    public StatoMacchina(int id, String descrizione) {
        this.id = id;
        this.descrizione = descrizione;
    }

    /**
     * Restituisce l'ID univoco dello stato.
     *
     * @return ID dello stato
     */
    public int getId() {
        return id;
    }

    /**
     * Imposta l'ID dello stato.
     *
     * @param id Nuovo ID da impostare
     */
    public void setId(int id) {
        this.id = id;
    }

    /**
     * Restituisce la descrizione dello stato.
     *
     * @return Descrizione dello stato
     */
    public String getDescrizione() {
        return descrizione;
    }

    /**
     * Imposta la descrizione dello stato.
     *
     * @param descrizione Nuova descrizione da impostare
     */
    public void setDescrizione(String descrizione) {
        this.descrizione = descrizione;
    }

    /**
     * Verifica se lo stato corrisponde a "Attiva".
     *
     * @return true se la macchina è attiva
     */
    public boolean isAttiva() {
        return id == STATO_ATTIVA;
    }

    /**
     * Verifica se lo stato corrisponde a "In manutenzione".
     *
     * @return true se la macchina è in manutenzione
     */
    public boolean isInManutenzione() {
        return id == STATO_IN_MANUTENZIONE;
    }

    /**
     * Verifica se lo stato corrisponde a "Fuori servizio".
     *
     * @return true se la macchina è fuori servizio
     */
    public boolean isFuoriServizio() {
        return id == STATO_FUORI_SERVIZIO;
    }

    /**
     * Verifica se la macchina può erogare bevande in questo stato.
     *
     * @return true se la macchina può erogare bevande
     */
    public boolean puoErogareBevande() {
        return isAttiva();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        StatoMacchina that = (StatoMacchina) o;
        return id == that.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }

    @Override
    public String toString() {
        return "StatoMacchina{" +
               "id=" + id +
               ", descrizione='" + descrizione + '\'' +
               '}';
    }
}

================
File: src/main/java/com/vending/core/models/Transazione.java
================
package com.vending.core.models;

import java.time.LocalDateTime;

/**
 * Modello che rappresenta una transazione di vendita di una bevanda.
 * Questa classe riflette la struttura della tabella 'transazione' nel database
 * e include informazioni aggiuntive dalle tabelle correlate e dalla vista 'transazionirecenti'.
 */
public class Transazione {
    private int id;
    private int macchinaId;
    private String nomeIstituto;    // Dal JOIN con la tabella istituto
    private int bevandaId;
    private String nomeBevanda;     // Dal JOIN con la tabella bevanda
    private Double importo;
    private LocalDateTime dataOra;

    /**
     * Costruttore predefinito.
     * Inizializza la data e ora al momento corrente.
     */
    public Transazione() {
        this.dataOra = LocalDateTime.now();
    }

    /**
     * Costruttore con parametri principali.
     *
     * @param macchinaId ID della macchina che ha eseguito la transazione
     * @param bevandaId ID della bevanda erogata
     * @param importo Importo della transazione
     */
    public Transazione(int macchinaId, int bevandaId, Double importo) {
        this();
        this.macchinaId = macchinaId;
        this.bevandaId = bevandaId;
        this.importo = importo;
    }

    /**
     * Restituisce l'ID univoco della transazione.
     *
     * @return ID della transazione
     */
    public int getId() {
        return id;
    }

    /**
     * Imposta l'ID della transazione.
     *
     * @param id Nuovo ID da impostare
     */
    public void setId(int id) {
        this.id = id;
    }

    /**
     * Restituisce l'ID della macchina che ha eseguito la transazione.
     *
     * @return ID della macchina
     */
    public int getMacchinaId() {
        return macchinaId;
    }

    /**
     * Imposta l'ID della macchina.
     *
     * @param macchinaId Nuovo ID della macchina
     */
    public void setMacchinaId(int macchinaId) {
        this.macchinaId = macchinaId;
    }

    /**
     * Restituisce il nome dell'istituto dove si trova la macchina.
     *
     * @return Nome dell'istituto
     */
    public String getNomeIstituto() {
        return nomeIstituto;
    }

    /**
     * Imposta il nome dell'istituto.
     *
     * @param nomeIstituto Nuovo nome dell'istituto
     */
    public void setNomeIstituto(String nomeIstituto) {
        this.nomeIstituto = nomeIstituto;
    }

    /**
     * Restituisce l'ID della bevanda erogata.
     *
     * @return ID della bevanda
     */
    public int getBevandaId() {
        return bevandaId;
    }

    /**
     * Imposta l'ID della bevanda.
     *
     * @param bevandaId Nuovo ID della bevanda
     */
    public void setBevandaId(int bevandaId) {
        this.bevandaId = bevandaId;
    }

    /**
     * Restituisce il nome della bevanda erogata.
     *
     * @return Nome della bevanda
     */
    public String getNomeBevanda() {
        return nomeBevanda;
    }

    /**
     * Imposta il nome della bevanda.
     *
     * @param nomeBevanda Nuovo nome della bevanda
     */
    public void setNomeBevanda(String nomeBevanda) {
        this.nomeBevanda = nomeBevanda;
    }

    /**
     * Restituisce l'importo della transazione.
     *
     * @return Importo della transazione
     */
    public Double getImporto() {
        return importo;
    }

    /**
     * Imposta l'importo della transazione.
     *
     * @param importo Nuovo importo da impostare
     */
    public void setImporto(Double importo) {
        this.importo = importo;
    }

    /**
     * Restituisce la data e ora della transazione.
     *
     * @return Data e ora della transazione
     */
    public LocalDateTime getDataOra() {
        return dataOra;
    }

    /**
     * Imposta la data e ora della transazione.
     *
     * @param dataOra Nuova data e ora da impostare
     */
    public void setDataOra(LocalDateTime dataOra) {
        this.dataOra = dataOra;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Transazione that = (Transazione) o;
        return id == that.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }

    @Override
    public String toString() {
        return "Transazione{" +
               "id=" + id +
               ", macchinaId=" + macchinaId +
               ", nomeIstituto='" + nomeIstituto + '\'' +
               ", nomeBevanda='" + nomeBevanda + '\'' +
               ", importo=" + importo +
               ", dataOra=" + dataOra +
               '}';
    }
}

================
File: src/main/java/com/vending/core/models/Utente.java
================
package com.vending.core.models;

import org.mindrot.jbcrypt.BCrypt;
import java.time.LocalDateTime;

/**
 * Classe che rappresenta un utente del sistema di distribuzione automatica.
 * Questa classe riflette la struttura delle tabelle 'utente' e 'adminlogin' nel database,
 * gestendo le informazioni dell'utente e la sicurezza delle credenziali attraverso BCrypt.
 */
public class Utente {
    private int id;
    private String nome;
    private String ruolo;
    private String username;        // Da adminlogin
    private String passwordHash;    // Da adminlogin
    private LocalDateTime ultimoAccesso; // Da adminlogin

    /**
     * Costruttore predefinito.
     */
    public Utente() {}

    /**
     * Costruttore con parametri principali.
     *
     * @param nome Nome completo dell'utente
     * @param ruolo Ruolo dell'utente (Amministratore, Tecnico, Operatore)
     * @param username Nome utente per l'accesso
     * @param password Password in chiaro che verrà crittografata
     */
    public Utente(String nome, String ruolo, String username, String password) {
        this.nome = nome;
        this.ruolo = ruolo;
        this.username = username;
        setPassword(password);
    }

    /**
     * Restituisce l'ID univoco dell'utente.
     *
     * @return ID dell'utente
     */
    public int getId() {
        return id;
    }

    /**
     * Imposta l'ID dell'utente.
     *
     * @param id Nuovo ID da impostare
     */
    public void setId(int id) {
        this.id = id;
    }

    /**
     * Restituisce il nome dell'utente.
     *
     * @return Nome completo dell'utente
     */
    public String getNome() {
        return nome;
    }

    /**
     * Imposta il nome dell'utente.
     *
     * @param nome Nuovo nome da impostare
     */
    public void setNome(String nome) {
        this.nome = nome;
    }

    /**
     * Restituisce il ruolo dell'utente.
     *
     * @return Ruolo dell'utente nel sistema
     */
    public String getRuolo() {
        return ruolo;
    }

    /**
     * Imposta il ruolo dell'utente.
     *
     * @param ruolo Nuovo ruolo da impostare
     */
    public void setRuolo(String ruolo) {
        this.ruolo = ruolo;
    }

    /**
     * Restituisce il nome utente per l'accesso.
     *
     * @return Nome utente
     */
    public String getUsername() {
        return username;
    }

    /**
     * Imposta il nome utente per l'accesso.
     *
     * @param username Nuovo nome utente da impostare
     */
    public void setUsername(String username) {
        this.username = username;
    }

    /**
     * Restituisce l'hash della password.
     *
     * @return Hash della password
     */
    public String getPasswordHash() {
        return passwordHash;
    }

    /**
     * Imposta e cripta la password dell'utente.
     * La password viene sottoposta a hashing prima del salvataggio.
     *
     * @param password Password in chiaro da crittografare
     */
    public void setPassword(String password) {
        if (password != null && !password.isEmpty()) {
            this.passwordHash = getPasswordHash(password);
        }
    }

    /**
     * Restituisce la data e ora dell'ultimo accesso.
     *
     * @return Data e ora dell'ultimo accesso
     */
    public LocalDateTime getUltimoAccesso() {
        return ultimoAccesso;
    }

    /**
     * Imposta la data e ora dell'ultimo accesso.
     *
     * @param ultimoAccesso Nuova data e ora dell'ultimo accesso
     */
    public void setUltimoAccesso(LocalDateTime ultimoAccesso) {
        this.ultimoAccesso = ultimoAccesso;
    }

    /**
     * Verifica se l'utente è un amministratore.
     *
     * @return true se l'utente è un amministratore
     */
    public boolean isAmministratore() {
        return "Amministratore".equals(ruolo);
    }

    /**
     * Verifica se l'utente è un tecnico.
     *
     * @return true se l'utente è un tecnico
     */
    public boolean isTecnico() {
        return "Tecnico".equals(ruolo);
    }

    /**
     * Verifica se l'utente è un operatore.
     *
     * @return true se l'utente è un operatore
     */
    public boolean isOperatore() {
        return "Operatore".equals(ruolo);
    }

    /**
     * Genera un hash sicuro della password usando BCrypt.
     *
     * @param password Password in chiaro da crittografare
     * @return Hash della password
     * @throws IllegalArgumentException se la password è null o vuota
     */
    public static String getPasswordHash(String password) {
        if (password == null || password.isEmpty()) {
            throw new IllegalArgumentException("La password non può essere null o vuota");
        }
        return BCrypt.hashpw(password, BCrypt.gensalt(12));
    }

    /**
     * Verifica se la password fornita corrisponde all'hash memorizzato.
     *
     * @param plainTextPassword Password in chiaro da verificare
     * @return true se la password è corretta
     */
    public boolean verifyPassword(String plainTextPassword) {
        if (plainTextPassword == null || plainTextPassword.isEmpty() || passwordHash == null) {
            return false;
        }
        return BCrypt.checkpw(plainTextPassword, passwordHash);
    }

    /**
     * Aggiorna l'ultimo accesso dell'utente al momento corrente.
     */
    public void aggiornaUltimoAccesso() {
        this.ultimoAccesso = LocalDateTime.now();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Utente utente = (Utente) o;
        return id == utente.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }

    @Override
    public String toString() {
        return "Utente{" +
               "id=" + id +
               ", nome='" + nome + '\'' +
               ", ruolo='" + ruolo + '\'' +
               ", username='" + username + '\'' +
               ", ultimoAccesso=" + ultimoAccesso +
               '}';
    }
}

================
File: src/main/java/com/vending/core/repositories/AdminLoginRepository.java
================
package com.vending.core.repositories;

import com.vending.core.models.AdminLogin;
import com.vending.core.models.Utente;
import java.sql.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Repository per la gestione dei dati di accesso amministrativo nel database.
 * Gestisce le operazioni CRUD per la tabella 'adminlogin'.
 */
public class AdminLoginRepository {
    private final DatabaseConnection dbConnection;
    private final UtenteRepository utenteRepository;

    /**
     * Costruttore del repository.
     *
     * @param utenteRepository repository per l'accesso ai dati degli utenti
     */
    public AdminLoginRepository(UtenteRepository utenteRepository) {
        this.dbConnection = DatabaseConnection.getInstance();
        this.utenteRepository = utenteRepository;
    }

    /**
     * Trova tutti gli accessi amministrativi.
     *
     * @return lista di tutti gli accessi
     */
    public List<AdminLogin> findAll() {
        List<AdminLogin> adminLogins = new ArrayList<>();
        String sql = "SELECT * FROM adminlogin";
        
        try (Connection conn = dbConnection.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            
            while (rs.next()) {
                AdminLogin adminLogin = mapResultSetToAdminLogin(rs);
                caricaUtente(adminLogin);
                adminLogins.add(adminLogin);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero degli accessi amministrativi", e);
        }
        return adminLogins;
    }

    /**
     * Trova un accesso amministrativo tramite ID.
     *
     * @param id ID dell'accesso amministrativo
     * @return Optional contenente l'accesso se trovato
     */
    public Optional<AdminLogin> findById(int id) {
        String sql = "SELECT * FROM adminlogin WHERE ID_AdminLogin = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                AdminLogin adminLogin = mapResultSetToAdminLogin(rs);
                caricaUtente(adminLogin);
                return Optional.of(adminLogin);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero dell'accesso amministrativo", e);
        }
        return Optional.empty();
    }

    /**
     * Trova un accesso amministrativo tramite username.
     *
     * @param username username da cercare
     * @return Optional contenente l'accesso se trovato
     */
    public Optional<AdminLogin> findByUsername(String username) {
        String sql = "SELECT * FROM adminlogin WHERE Username = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, username);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                AdminLogin adminLogin = mapResultSetToAdminLogin(rs);
                caricaUtente(adminLogin);
                return Optional.of(adminLogin);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero dell'accesso amministrativo", e);
        }
        return Optional.empty();
    }

    /**
     * Trova un accesso amministrativo tramite ID utente.
     *
     * @param utenteId ID dell'utente
     * @return Optional contenente l'accesso se trovato
     */
    public Optional<AdminLogin> findByUtenteId(int utenteId) {
        String sql = "SELECT * FROM adminlogin WHERE ID_Utente = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, utenteId);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                AdminLogin adminLogin = mapResultSetToAdminLogin(rs);
                caricaUtente(adminLogin);
                return Optional.of(adminLogin);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero dell'accesso amministrativo", e);
        }
        return Optional.empty();
    }

    /**
     * Salva un nuovo accesso amministrativo.
     *
     * @param adminLogin accesso amministrativo da salvare
     * @return accesso amministrativo salvato con ID generato
     */
    public AdminLogin save(AdminLogin adminLogin) {
        String sql = "INSERT INTO adminlogin (ID_Utente, Username, PasswordHash, UltimoAccesso) " +
                    "VALUES (?, ?, ?, ?)";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            
            stmt.setInt(1, adminLogin.getUtenteId());
            stmt.setString(2, adminLogin.getUsername());
            stmt.setString(3, adminLogin.getPasswordHash());
            stmt.setTimestamp(4, Timestamp.valueOf(adminLogin.getUltimoAccesso()));
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("La creazione dell'accesso amministrativo è fallita");
            }
            
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    adminLogin.setId(generatedKeys.getInt(1));
                    return adminLogin;
                } else {
                    throw new SQLException("La creazione dell'accesso amministrativo è fallita, nessun ID ottenuto");
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il salvataggio dell'accesso amministrativo", e);
        }
    }

    /**
     * Aggiorna un accesso amministrativo esistente.
     *
     * @param adminLogin accesso amministrativo da aggiornare
     * @return accesso amministrativo aggiornato
     */
    public AdminLogin update(AdminLogin adminLogin) {
        String sql = "UPDATE adminlogin SET Username = ?, PasswordHash = ?, UltimoAccesso = ? " +
                    "WHERE ID_AdminLogin = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, adminLogin.getUsername());
            stmt.setString(2, adminLogin.getPasswordHash());
            stmt.setTimestamp(3, Timestamp.valueOf(adminLogin.getUltimoAccesso()));
            stmt.setInt(4, adminLogin.getId());
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("L'aggiornamento dell'accesso amministrativo è fallito");
            }
            
            return adminLogin;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'aggiornamento dell'accesso amministrativo", e);
        }
    }

    /**
     * Elimina un accesso amministrativo.
     *
     * @param id ID dell'accesso amministrativo da eliminare
     * @return true se l'eliminazione ha successo
     */
    public boolean delete(int id) {
        String sql = "DELETE FROM adminlogin WHERE ID_AdminLogin = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            int affectedRows = stmt.executeUpdate();
            
            return affectedRows > 0;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'eliminazione dell'accesso amministrativo", e);
        }
    }

    /**
     * Converte un ResultSet in un oggetto AdminLogin.
     */
    private AdminLogin mapResultSetToAdminLogin(ResultSet rs) throws SQLException {
        AdminLogin adminLogin = new AdminLogin();
        adminLogin.setId(rs.getInt("ID_AdminLogin"));
        adminLogin.setUtenteId(rs.getInt("ID_Utente"));
        adminLogin.setUsername(rs.getString("Username"));
        adminLogin.setPasswordHash(rs.getString("PasswordHash"));
        Timestamp timestamp = rs.getTimestamp("UltimoAccesso");
        if (timestamp != null) {
            adminLogin.setUltimoAccesso(timestamp.toLocalDateTime());
        }
        return adminLogin;
    }

    /**
     * Carica l'utente associato all'accesso amministrativo.
     */
    private void caricaUtente(AdminLogin adminLogin) {
        utenteRepository.findById(adminLogin.getUtenteId())
                .ifPresent(adminLogin::setUtente);
    }
}

================
File: src/main/java/com/vending/core/repositories/BevandaRepository.java
================
package com.vending.core.repositories;

import com.vending.core.models.Bevanda;
import com.vending.core.models.Cialda;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Repository per la gestione delle bevande nel database.
 * Gestisce le operazioni CRUD per la tabella 'bevanda' e le relazioni
 * con la tabella 'bevandahacialda'.
 */
public class BevandaRepository {
    private final DatabaseConnection dbConnection;
    private final CialdaRepository cialdaRepository;

    /**
     * Costruttore del repository.
     *
     * @param cialdaRepository repository per l'accesso ai dati delle cialde
     */
    public BevandaRepository(CialdaRepository cialdaRepository) {
        this.dbConnection = DatabaseConnection.getInstance();
        this.cialdaRepository = cialdaRepository;
    }

    /**
     * Trova tutte le bevande disponibili.
     *
     * @return lista di tutte le bevande con le relative cialde
     */
    public List<Bevanda> findAll() {
        List<Bevanda> bevande = new ArrayList<>();
        String sql = "SELECT * FROM bevanda";
        
        try (Connection conn = dbConnection.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            
            while (rs.next()) {
                Bevanda bevanda = mapResultSetToBevanda(rs);
                caricaCialde(bevanda);
                bevande.add(bevanda);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero delle bevande", e);
        }
        return bevande;
    }

    /**
     * Trova una bevanda tramite ID.
     *
     * @param id ID della bevanda
     * @return Optional contenente la bevanda se trovata
     */
    public Optional<Bevanda> findById(int id) {
        String sql = "SELECT * FROM bevanda WHERE ID_Bevanda = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                Bevanda bevanda = mapResultSetToBevanda(rs);
                caricaCialde(bevanda);
                return Optional.of(bevanda);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero della bevanda", e);
        }
        return Optional.empty();
    }

    /**
     * Trova le bevande disponibili per una specifica macchina.
     *
     * @param macchinaId ID della macchina
     * @return lista delle bevande disponibili per la macchina
     */
    public List<Bevanda> findByMacchinaId(int macchinaId) {
        List<Bevanda> bevande = new ArrayList<>();
        String sql = "SELECT b.* FROM bevanda b " +
                    "JOIN macchinahabevanda mhb ON b.ID_Bevanda = mhb.ID_Bevanda " +
                    "WHERE mhb.ID_Macchina = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, macchinaId);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                Bevanda bevanda = mapResultSetToBevanda(rs);
                caricaCialde(bevanda);
                bevande.add(bevanda);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero delle bevande della macchina", e);
        }
        return bevande;
    }

    /**
     * Salva una nuova bevanda.
     *
     * @param bevanda bevanda da salvare
     * @return bevanda salvata con ID generato
     */
    public Bevanda save(Bevanda bevanda) {
        String sql = "INSERT INTO bevanda (Nome, Prezzo) VALUES (?, ?)";
        
        try (Connection conn = dbConnection.getConnection()) {
            conn.setAutoCommit(false);
            try (PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
                stmt.setString(1, bevanda.getNome());
                stmt.setDouble(2, bevanda.getPrezzo());
                
                int affectedRows = stmt.executeUpdate();
                if (affectedRows == 0) {
                    throw new SQLException("La creazione della bevanda è fallita");
                }
                
                try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        bevanda.setId(generatedKeys.getInt(1));
                        salvaCialde(conn, bevanda);
                        conn.commit();
                        return bevanda;
                    } else {
                        throw new SQLException("La creazione della bevanda è fallita, nessun ID ottenuto");
                    }
                }
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il salvataggio della bevanda", e);
        }
    }

    /**
     * Aggiorna una bevanda esistente.
     *
     * @param bevanda bevanda da aggiornare
     * @return bevanda aggiornata
     */
    public Bevanda update(Bevanda bevanda) {
        String sql = "UPDATE bevanda SET Nome = ?, Prezzo = ? WHERE ID_Bevanda = ?";
        
        try (Connection conn = dbConnection.getConnection()) {
            conn.setAutoCommit(false);
            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setString(1, bevanda.getNome());
                stmt.setDouble(2, bevanda.getPrezzo());
                stmt.setInt(3, bevanda.getId());
                
                int affectedRows = stmt.executeUpdate();
                if (affectedRows == 0) {
                    throw new SQLException("L'aggiornamento della bevanda è fallito");
                }
                
                aggiornaCialde(conn, bevanda);
                conn.commit();
                return bevanda;
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'aggiornamento della bevanda", e);
        }
    }

    /**
     * Elimina una bevanda.
     *
     * @param id ID della bevanda da eliminare
     * @return true se l'eliminazione ha successo
     */
    public boolean delete(int id) {
        String sql = "DELETE FROM bevanda WHERE ID_Bevanda = ?";
        
        try (Connection conn = dbConnection.getConnection()) {
            conn.setAutoCommit(false);
            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                eliminaCialde(conn, id);
                
                stmt.setInt(1, id);
                int affectedRows = stmt.executeUpdate();
                
                conn.commit();
                return affectedRows > 0;
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'eliminazione della bevanda", e);
        }
    }

    /**
     * Converte un ResultSet in un oggetto Bevanda.
     */
    private Bevanda mapResultSetToBevanda(ResultSet rs) throws SQLException {
        Bevanda bevanda = new Bevanda();
        bevanda.setId(rs.getInt("ID_Bevanda"));
        bevanda.setNome(rs.getString("Nome"));
        bevanda.setPrezzo(rs.getDouble("Prezzo"));
        return bevanda;
    }

    /**
     * Carica le cialde associate alla bevanda.
     */
    private void caricaCialde(Bevanda bevanda) throws SQLException {
        String sql = "SELECT c.* FROM cialda c " +
                    "JOIN bevandahacialda bhc ON c.ID_Cialda = bhc.ID_Cialda " +
                    "WHERE bhc.ID_Bevanda = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, bevanda.getId());
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                Cialda cialda = new Cialda();
                cialda.setId(rs.getInt("ID_Cialda"));
                cialda.setNome(rs.getString("Nome"));
                cialda.setTipoCialda(rs.getString("TipoCialda"));
                bevanda.getCialde().add(cialda);
            }
        }
    }

    /**
     * Salva le associazioni tra bevanda e cialde.
     */
    private void salvaCialde(Connection conn, Bevanda bevanda) throws SQLException {
        String sql = "INSERT INTO bevandahacialda (ID_Bevanda, ID_Cialda) VALUES (?, ?)";
        
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            for (Cialda cialda : bevanda.getCialde()) {
                stmt.setInt(1, bevanda.getId());
                stmt.setInt(2, cialda.getId());
                stmt.addBatch();
            }
            stmt.executeBatch();
        }
    }

    /**
     * Aggiorna le associazioni tra bevanda e cialde.
     */
    private void aggiornaCialde(Connection conn, Bevanda bevanda) throws SQLException {
        String deleteSQL = "DELETE FROM bevandahacialda WHERE ID_Bevanda = ?";
        try (PreparedStatement stmt = conn.prepareStatement(deleteSQL)) {
            stmt.setInt(1, bevanda.getId());
            stmt.executeUpdate();
        }
        salvaCialde(conn, bevanda);
    }

    /**
     * Elimina tutte le associazioni tra bevanda e cialde.
     */
    private void eliminaCialde(Connection conn, int bevandaId) throws SQLException {
        String sql = "DELETE FROM bevandahacialda WHERE ID_Bevanda = ?";
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, bevandaId);
            stmt.executeUpdate();
        }
    }
}

================
File: src/main/java/com/vending/core/repositories/CialdaRepository.java
================
package com.vending.core.repositories;

import com.vending.core.models.Cialda;
import com.vending.core.models.QuantitaCialde;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Repository per la gestione delle cialde nel database.
 * Gestisce le operazioni CRUD per la tabella 'cialda' e le relazioni
 * con la tabella 'quantitacialde'.
 */
public class CialdaRepository {
    private final DatabaseConnection dbConnection;

    /**
     * Costruttore del repository.
     */
    public CialdaRepository() {
        this.dbConnection = DatabaseConnection.getInstance();
    }

    /**
     * Trova tutte le cialde disponibili.
     *
     * @return lista di tutte le cialde
     */
    public List<Cialda> findAll() {
        List<Cialda> cialde = new ArrayList<>();
        String sql = "SELECT * FROM cialda";
        
        try (Connection conn = dbConnection.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            
            while (rs.next()) {
                cialde.add(mapResultSetToCialda(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero delle cialde", e);
        }
        return cialde;
    }

    /**
     * Trova una cialda tramite ID.
     *
     * @param id ID della cialda
     * @return Optional contenente la cialda se trovata
     */
    public Optional<Cialda> findById(int id) {
        String sql = "SELECT * FROM cialda WHERE ID_Cialda = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return Optional.of(mapResultSetToCialda(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero della cialda", e);
        }
        return Optional.empty();
    }

    /**
     * Trova le cialde di un determinato tipo.
     *
     * @param tipoCialda tipo di cialda da cercare
     * @return lista delle cialde del tipo specificato
     */
    public List<Cialda> findByTipo(String tipoCialda) {
        List<Cialda> cialde = new ArrayList<>();
        String sql = "SELECT * FROM cialda WHERE TipoCialda = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, tipoCialda);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                cialde.add(mapResultSetToCialda(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero delle cialde per tipo", e);
        }
        return cialde;
    }

    /**
     * Trova la quantità disponibile di una cialda in una macchina.
     *
     * @param idCialda ID della cialda
     * @param idMacchina ID della macchina
     * @return Optional contenente la quantità di cialde se trovata
     */
    public Optional<QuantitaCialde> getQuantitaDisponibileByMacchina(int idCialda, int idMacchina) {
        String sql = "SELECT qc.*, c.Nome as NomeCialda, c.TipoCialda " +
                    "FROM quantitacialde qc " +
                    "JOIN cialda c ON qc.ID_Cialda = c.ID_Cialda " +
                    "WHERE qc.ID_Cialda = ? AND qc.ID_Macchina = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, idCialda);
            stmt.setInt(2, idMacchina);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return Optional.of(mapResultSetToQuantitaCialde(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero della quantità cialde", e);
        }
        return Optional.empty();
    }

    /**
     * Salva una nuova cialda.
     *
     * @param cialda cialda da salvare
     * @return cialda salvata con ID generato
     */
    public Cialda save(Cialda cialda) {
        String sql = "INSERT INTO cialda (Nome, TipoCialda) VALUES (?, ?)";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            
            stmt.setString(1, cialda.getNome());
            stmt.setString(2, cialda.getTipoCialda());
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("La creazione della cialda è fallita");
            }
            
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    cialda.setId(generatedKeys.getInt(1));
                    return cialda;
                } else {
                    throw new SQLException("La creazione della cialda è fallita, nessun ID ottenuto");
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il salvataggio della cialda", e);
        }
    }

    /**
     * Aggiorna una cialda esistente.
     *
     * @param cialda cialda da aggiornare
     * @return cialda aggiornata
     */
    public Cialda update(Cialda cialda) {
        String sql = "UPDATE cialda SET Nome = ?, TipoCialda = ? WHERE ID_Cialda = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, cialda.getNome());
            stmt.setString(2, cialda.getTipoCialda());
            stmt.setInt(3, cialda.getId());
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("L'aggiornamento della cialda è fallito");
            }
            return cialda;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'aggiornamento della cialda", e);
        }
    }

    /**
     * Elimina una cialda.
     *
     * @param id ID della cialda da eliminare
     * @return true se l'eliminazione ha successo
     */
    public boolean delete(int id) {
        String sql = "DELETE FROM cialda WHERE ID_Cialda = ?";
        
        try (Connection conn = dbConnection.getConnection()) {
            conn.setAutoCommit(false);
            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                // Prima elimina tutte le relazioni
                eliminaQuantitaCialde(conn, id);
                
                stmt.setInt(1, id);
                int affectedRows = stmt.executeUpdate();
                
                conn.commit();
                return affectedRows > 0;
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'eliminazione della cialda", e);
        }
    }

    /**
     * Converte un ResultSet in un oggetto Cialda.
     */
    private Cialda mapResultSetToCialda(ResultSet rs) throws SQLException {
        Cialda cialda = new Cialda();
        cialda.setId(rs.getInt("ID_Cialda"));
        cialda.setNome(rs.getString("Nome"));
        cialda.setTipoCialda(rs.getString("TipoCialda"));
        return cialda;
    }

    /**
     * Converte un ResultSet in un oggetto QuantitaCialde.
     */
    private QuantitaCialde mapResultSetToQuantitaCialde(ResultSet rs) throws SQLException {
        QuantitaCialde qc = new QuantitaCialde();
        qc.setId(rs.getInt("ID_QuantitaCialde"));
        qc.setMacchinaId(rs.getInt("ID_Macchina"));
        qc.setCialdaId(rs.getInt("ID_Cialda"));
        qc.setQuantita(rs.getInt("Quantita"));
        qc.setQuantitaMassima(rs.getInt("QuantitaMassima"));
        qc.setNomeCialda(rs.getString("NomeCialda"));
        qc.setTipoCialda(rs.getString("TipoCialda"));
        return qc;
    }

    /**
     * Elimina tutte le quantità cialde associate a una cialda.
     */
    private void eliminaQuantitaCialde(Connection conn, int cialdaId) throws SQLException {
        String sql = "DELETE FROM quantitacialde WHERE ID_Cialda = ?";
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, cialdaId);
            stmt.executeUpdate();
        }
    }
}

================
File: src/main/java/com/vending/core/repositories/DatabaseConnection.java
================
package com.vending.core.repositories;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
* Singleton class per gestire la connessione al database MySQL.
* Implementa il pattern Singleton thread-safe per garantire una singola istanza di connessione.
*/
public class DatabaseConnection {
   private static final Logger logger = LoggerFactory.getLogger(DatabaseConnection.class);
   private static volatile DatabaseConnection instance;
   private static final String URL = "jdbc:mysql://localhost:3306/pissir";
   private static final String USER = "root";
   private static final String PASSWORD = "Pissir2024!";
   
   private volatile Connection connection;
   
   /**
    * Costruttore privato che inizializza il driver MySQL.
    * @throws RuntimeException se il driver non viene trovato
    */
   private DatabaseConnection() {
       try {
           Class.forName("com.mysql.cj.jdbc.Driver");
           logger.info("MySQL Driver caricato con successo");
       } catch (ClassNotFoundException e) {
           logger.error("Errore nel caricamento del MySQL Driver", e);
           throw new RuntimeException("MySQL Driver non trovato: " + e.getMessage(), e);
       }
   }
   
   /**
    * Restituisce l'istanza singleton della connessione al database.
    * Implementa il double-checked locking per thread safety.
    * 
    * @return l'istanza di DatabaseConnection
    */
   public static DatabaseConnection getInstance() {
       if (instance == null) {
           synchronized (DatabaseConnection.class) {
               if (instance == null) {
                   instance = new DatabaseConnection();
               }
           }
       }
       return instance;
   }
   
   /**
    * Restituisce una connessione attiva al database.
    * Se la connessione non esiste o è chiusa, ne crea una nuova.
    * 
    * @return Connection oggetto connessione al database
    * @throws SQLException se la connessione fallisce
    */
   public Connection getConnection() throws SQLException {
       if (connection == null || connection.isClosed()) {
           synchronized (this) {
               if (connection == null || connection.isClosed()) {
                   try {
                       connection = DriverManager.getConnection(URL, USER, PASSWORD);
                   } catch (SQLException e) {
                       logger.error("Errore durante la connessione al database", e);
                       throw new SQLException("Impossibile connettersi al database: " + e.getMessage(), e);
                   }
               }
           }
       }
       return connection;
   }
   
   /**
    * Chiude la connessione al database se attiva.
    */
   public void closeConnection() {
       if (connection != null) {
           try {
               connection.close();
               connection = null;
               logger.info("Connessione al database chiusa con successo");
           } catch (SQLException e) {
               logger.error("Errore durante la chiusura della connessione", e);
           }
       }
   }
   
   /**
    * Verifica lo stato della connessione.
    * 
    * @return true se la connessione è attiva, false altrimenti
    */
   public boolean isConnected() {
       try {
           return connection != null && !connection.isClosed() && connection.isValid(1);
       } catch (SQLException e) {
           logger.error("Errore durante la verifica della connessione", e);
           return false;
       }
   }
}

================
File: src/main/java/com/vending/core/repositories/IstitutoRepository.java
================
package com.vending.core.repositories;

import com.vending.core.models.Istituto;
import com.vending.core.models.Macchina;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Repository per la gestione degli istituti nel database.
 * Gestisce le operazioni CRUD per la tabella 'istituto' e le relazioni
 * con la tabella 'macchina'.
 */
public class IstitutoRepository {
    private final DatabaseConnection dbConnection;
    private final MacchinaRepository macchinaRepository;

    /**
     * Costruttore del repository.
     *
     * @param macchinaRepository repository per l'accesso ai dati delle macchine
     */
    public IstitutoRepository(MacchinaRepository macchinaRepository) {
        this.dbConnection = DatabaseConnection.getInstance();
        this.macchinaRepository = macchinaRepository;
    }

    /**
     * Trova tutti gli istituti.
     *
     * @return lista di tutti gli istituti con le relative macchine
     */
    public List<Istituto> findAll() throws SQLException {
        List<Istituto> istituti = new ArrayList<>();
        String sql = "SELECT * FROM istituto";
        
        try (Connection conn = dbConnection.getConnection()) {
            // Lista temporanea per gli istituti base
            List<Istituto> istitutiTemp = new ArrayList<>();
            
            // Prima recupera tutti gli istituti base
            try (Statement stmt = conn.createStatement();
                 ResultSet rs = stmt.executeQuery(sql)) {
                
                while (rs.next()) {
                    Istituto istituto = mapResultSetToIstituto(rs);
                    istitutiTemp.add(istituto);
                }
            }
            
            // Poi carica le macchine per ogni istituto
            for (Istituto istituto : istitutiTemp) {
                caricaMacchine(istituto);
				istituti.add(istituto);
            }
            
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero degli istituti", e);
        }
        
        return istituti;
    }

    /**
     * Trova un istituto tramite ID.
     *
     * @param id ID dell'istituto
     * @return Optional contenente l'istituto se trovato
     */
    public Optional<Istituto> findById(int id) {
        String sql = "SELECT * FROM istituto WHERE ID_Istituto = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                Istituto istituto = mapResultSetToIstituto(rs);
                caricaMacchine(istituto);
                return Optional.of(istituto);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero dell'istituto", e);
        }
        return Optional.empty();
    }

    /**
     * Salva un nuovo istituto.
     *
     * @param istituto istituto da salvare
     * @return istituto salvato con ID generato
     */
    public Istituto save(Istituto istituto) {
        String sql = "INSERT INTO istituto (Nome, Indirizzo) VALUES (?, ?)";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            
            stmt.setString(1, istituto.getNome());
            stmt.setString(2, istituto.getIndirizzo());
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("La creazione dell'istituto ш fallita");
            }
            
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    istituto.setId(generatedKeys.getInt(1));
                    return istituto;
                } else {
                    throw new SQLException("La creazione dell'istituto ш fallita, nessun ID ottenuto");
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il salvataggio dell istituto", e);
        }
    }

    /**
     * Aggiorna un istituto esistente.
     *
     * @param istituto istituto da aggiornare
     * @return istituto aggiornato
     */
    public Istituto update(Istituto istituto) {
        String sql = "UPDATE istituto SET Nome = ?, Indirizzo = ? WHERE ID_Istituto = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, istituto.getNome());
            stmt.setString(2, istituto.getIndirizzo());
            stmt.setInt(3, istituto.getId());
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("L'aggiornamento dell'istituto ш fallito");
            }
            return istituto;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'aggiornamento dell'istituto", e);
        }
    }

    /**
     * Elimina un istituto.
     *
     * @param id ID dell'istituto da eliminare
     * @return true se l'eliminazione ha successo
     * @throws SQLException 
     */
    public boolean delete(int id) throws SQLException {
        // Verifica che non ci siano macchine associate
        List<Macchina> macchine = macchinaRepository.findByIstitutoId(id);
        if (!macchine.isEmpty()) {
            throw new IllegalStateException("Non e' possibile eliminare un istituto con macchine associate");
        }

        String sql = "DELETE FROM istituto WHERE ID_Istituto = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            int affectedRows = stmt.executeUpdate();
            return affectedRows > 0;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'eliminazione dell'istituto", e);
        }
    }

    /**
     * Converte un ResultSet in un oggetto Istituto.
     */
    private Istituto mapResultSetToIstituto(ResultSet rs) throws SQLException {
        Istituto istituto = new Istituto();
        istituto.setId(rs.getInt("ID_Istituto"));
        istituto.setNome(rs.getString("Nome"));
        istituto.setIndirizzo(rs.getString("Indirizzo"));
        istituto.setMacchine(new ArrayList<>()); // Inizializza la lista delle macchine
        return istituto;
    }

    /**
     * Carica le macchine associate all'istituto.
     * @throws SQLException 
     */
    private void caricaMacchine(Istituto istituto) throws SQLException {
        List<Macchina> macchine = macchinaRepository.findByIstitutoId(istituto.getId());
        istituto.setMacchine(macchine);
    }

    /**
     * Verifica se esiste un istituto con il nome specificato.
     *
     * @param nome nome da verificare
     * @return true se esiste giра un istituto con quel nome
     */
    public boolean existsByNome(String nome) {
        String sql = "SELECT COUNT(*) FROM istituto WHERE Nome = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, nome);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return rs.getInt(1) > 0;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante la verifica del nome istituto", e);
        }
        return false;
    }

    /**
     * Conta il numero di macchine attive in un istituto.
     *
     * @param id ID dell'istituto
     * @return numero di macchine attive
     */
    public int contaMacchineAttive(int id) {
        String sql = "SELECT COUNT(*) FROM macchina WHERE ID_Istituto = ? AND Stato = 1";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return rs.getInt(1);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il conteggio delle macchine attive", e);
        }
        return 0;
    }
}

================
File: src/main/java/com/vending/core/repositories/MacchinaRepository.java
================
package com.vending.core.repositories;

import com.vending.core.models.*;
import java.sql.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Repository per la gestione delle macchine distributrici nel database.
 * Gestisce tutte le operazioni CRUD e le relazioni con le altre entità
 * come bevande, cialde e stato della macchina.
 */
public class MacchinaRepository {
    private final DatabaseConnection dbConnection;

    /**
     * Costruttore del repository.
     * Inizializza la connessione al database.
     */
    public MacchinaRepository() {
        this.dbConnection = DatabaseConnection.getInstance();
    }

    /**
     * Recupera tutte le macchine distributrici dal database.
     * Include le informazioni sull'istituto e lo stato della macchina.
     *
     * @return Lista di tutte le macchine con i relativi dettagli
     * @throws RuntimeException se si verifica un errore durante l'accesso al database
     */
    public List<Macchina> findAll() {
        List<Macchina> macchine = new ArrayList<>();
        String sql = "SELECT macchina.*, istituto.Nome as NomeIstituto, statomacchina.Descrizione as StatoDescrizione " +
                    "FROM macchina " +
                    "JOIN istituto ON macchina.ID_Istituto = istituto.ID_Istituto " +
                    "JOIN statomacchina ON macchina.Stato = statomacchina.ID_StatoMacchina";
        
        try (Connection conn = dbConnection.getConnection()){
        	List<Macchina> macchineTemp = new ArrayList<>();
        	// Prima recupera tutte le macchine base
            try (Statement stmt = conn.createStatement();
                 ResultSet rs = stmt.executeQuery(sql)) {
                
                while (rs.next()) {
                    Macchina macchina = mapResultSetToMacchina(rs);
                    macchineTemp.add(macchina);
                }
            }
            
            // Poi carica i dettagli per ogni macchina
            for (Macchina macchina : macchineTemp) {
                try {
                    caricaDettagliMacchina(macchina);
                    macchine.add(macchina);
                } catch (SQLException e) {
                    // Log dell'errore ma continua con le altre macchine
                    System.err.println("Errore nel caricamento dei dettagli per la macchina " + macchina.getId() + ": " + e.getMessage());
                }
            }
            
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero delle macchine", e);
        }
        
        return macchine;
    }

    /**
     * Trova tutte le macchine installate in un determinato istituto.
     *
     * @param istitutoId ID dell'istituto
     * @return Lista delle macchine presenti nell'istituto
     * @throws SQLException 
     * @throws RuntimeException se si verifica un errore durante l'accesso al database
     */
    public List<Macchina> findByIstitutoId(int istitutoId) throws SQLException {
        List<Macchina> macchine = new ArrayList<>();
        String sql = "SELECT macchina.*, istituto.Nome as NomeIstituto, statomacchina.Descrizione as StatoDescrizione " +
                    "FROM macchina " +
                    "JOIN istituto ON macchina.ID_Istituto = istituto.ID_Istituto " +
                    "JOIN statomacchina ON macchina.Stato = statomacchina.ID_StatoMacchina " +
                    "WHERE macchina.ID_Istituto = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
        	List<Macchina> macchineTemp = new ArrayList<>();
            stmt.setInt(1, istitutoId);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                	Macchina macchina = mapResultSetToMacchina(rs);
                    macchineTemp.add(macchina);
                }
            }
         // Poi carica i dettagli per ogni macchina
            for (Macchina macchina : macchineTemp) {
                try {
                    caricaDettagliMacchina(macchina);
                    macchine.add(macchina);
                } catch (SQLException e) {
                    // Log dell'errore ma continua con le altre macchine
                    System.err.println("Errore nel caricamento dei dettagli per la macchina " + macchina.getId() + ": " + e.getMessage());
                }
            }
        } catch (SQLException e) {
            throw new SQLException("Errore durante il recupero delle macchine dell'istituto", e);
        }
        return macchine;
    }
           /* ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                Macchina macchina = mapResultSetToMacchina(rs);
                caricaDettagliMacchina(macchina);
                macchine.add(macchina);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero delle macchine dell'istituto", e);
        }
        return macchine;
    }*/

    /**
     * Recupera una specifica macchina dal database tramite il suo ID.
     *
     * @param id ID della macchina da recuperare
     * @return La macchina trovata o null se non esiste
     * @throws RuntimeException se si verifica un errore durante l'accesso al database
     */
    public Macchina findById(int id) {
        String sql = "SELECT m.*, i.Nome as NomeIstituto, sm.Descrizione as StatoDescrizione " +
                    "FROM macchina m " +
                    "JOIN istituto i ON m.ID_Istituto = i.ID_Istituto " +
                    "JOIN statomacchina sm ON m.Stato = sm.ID_StatoMacchina " +
                    "WHERE m.ID_Macchina = ?";

        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                Macchina macchina = mapResultSetToMacchina(rs);
                caricaDettagliMacchina(macchina);
                return macchina;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero della macchina", e);
        }
        return null;
    }

    /**
     * Salva una nuova macchina nel database.
     * Gestisce anche il salvataggio delle relazioni con bevande e cialde.
     *
     * @param macchina La macchina da salvare
     * @return La macchina salvata con l'ID generato
     * @throws RuntimeException se si verifica un errore durante il salvataggio
     */
    public Macchina save(Macchina macchina) {
        String sql = "INSERT INTO macchina (ID_Istituto, Stato, CassaAttuale, CassaMassima) " +
                    "VALUES (?, ?, ?, ?)";
        
        try (Connection conn = dbConnection.getConnection()) {
            conn.setAutoCommit(false);
            try (PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
                stmt.setInt(1, macchina.getIstitutoId());
                stmt.setInt(2, macchina.getStatoId());
                stmt.setDouble(3, macchina.getCassaAttuale());
                stmt.setDouble(4, macchina.getCassaMassima());
                
                int affectedRows = stmt.executeUpdate();
                if (affectedRows == 0) {
                    throw new SQLException("La creazione della macchina è fallita");
                }
                
                try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        macchina.setId(generatedKeys.getInt(1));
                        salvaCialde(conn, macchina);
                        salvaBevande(conn, macchina);
                        conn.commit();
                        return macchina;
                    } else {
                        throw new SQLException("La creazione della macchina è fallita, nessun ID ottenuto");
                    }
                }
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il salvataggio della macchina", e);
        }
    }

    /**
     * Aggiorna una macchina esistente nel database.
     * Aggiorna anche le relazioni con bevande e cialde.
     *
     * @param macchina La macchina da aggiornare
     * @return La macchina aggiornata
     * @throws RuntimeException se si verifica un errore durante l'aggiornamento
     */
    public Macchina update(Macchina macchina) {
        String sql = "UPDATE macchina SET Stato = ?, CassaAttuale = ?, CassaMassima = ? " +
                    "WHERE ID_Macchina = ?";
        
        try (Connection conn = dbConnection.getConnection()) {
            conn.setAutoCommit(false);
            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setInt(1, macchina.getStatoId());
                stmt.setDouble(2, macchina.getCassaAttuale());
                stmt.setDouble(3, macchina.getCassaMassima());
                stmt.setInt(4, macchina.getId());
                
                int affectedRows = stmt.executeUpdate();
                if (affectedRows == 0) {
                    throw new SQLException("L'aggiornamento della macchina è fallito");
                }
                
                aggiornaCialde(conn, macchina);
                aggiornaBevande(conn, macchina);
                conn.commit();
                return macchina;
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'aggiornamento della macchina", e);
        }
    }

    /**
     * Elimina una macchina dal database.
     * Elimina anche tutte le relazioni associate (cialde e bevande).
     *
     * @param id ID della macchina da eliminare
     * @return true se l'eliminazione ha avuto successo, false altrimenti
     * @throws RuntimeException se si verifica un errore durante l'eliminazione
     */
    public boolean delete(int id) {
        String sql = "DELETE FROM macchina WHERE ID_Macchina = ?";
        
        try (Connection conn = dbConnection.getConnection()) {
            conn.setAutoCommit(false);
            try {
                // Prima elimina tutte le relazioni
                eliminaCialde(conn, id);
                eliminaBevande(conn, id);
                
                // Poi elimina la macchina
                try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                    stmt.setInt(1, id);
                    int affectedRows = stmt.executeUpdate();
                    conn.commit();
                    return affectedRows > 0;
                }
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'eliminazione della macchina", e);
        }
    }

    /**
     * Converte un ResultSet in un oggetto Macchina.
     */
    private Macchina mapResultSetToMacchina(ResultSet rs) throws SQLException {
        Macchina macchina = new Macchina();
        macchina.setId(rs.getInt("ID_Macchina"));
        macchina.setIstitutoId(rs.getInt("ID_Istituto"));
        macchina.setNomeIstituto(rs.getString("NomeIstituto"));
        macchina.setStatoId(rs.getInt("Stato"));
        macchina.setStatoDescrizione(rs.getString("StatoDescrizione"));
        macchina.setCassaAttuale(rs.getDouble("CassaAttuale"));
        macchina.setCassaMassima(rs.getDouble("CassaMassima"));
        return macchina;
    }

    /**
     * Carica le cialde associate alla macchina.
     */
    private void caricaCialde(Macchina macchina) throws SQLException {
        String sql = "SELECT qc.*, c.Nome as NomeCialda, c.TipoCialda " +
                    "FROM quantitacialde qc " +
                    "JOIN cialda c ON qc.ID_Cialda = c.ID_Cialda " +
                    "WHERE qc.ID_Macchina = ?";

        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, macchina.getId());
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                QuantitaCialde qc = new QuantitaCialde();
                qc.setId(rs.getInt("ID_QuantitaCialde"));
                qc.setMacchinaId(rs.getInt("ID_QuantitaCialde"));
                qc.setCialdaId(rs.getInt("ID_Cialda"));
                qc.setNomeCialda(rs.getString("NomeCialda"));
                qc.setTipoCialda(rs.getString("TipoCialda"));
                qc.setQuantita(rs.getInt("Quantita"));
                qc.setQuantitaMassima(rs.getInt("QuantitaMassima"));
                macchina.getCialde().add(qc);
            }
        }
    }

    /**
     * Carica le bevande associate alla macchina.
     */
    private void caricaBevande(Macchina macchina) throws SQLException {
        String sql = "SELECT b.* FROM bevanda b " +
                    "JOIN macchinahabevanda mhb ON b.ID_Bevanda = mhb.ID_Bevanda " +
                    "WHERE mhb.ID_Macchina = ?";

        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, macchina.getId());
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                Bevanda bevanda = new Bevanda();
                bevanda.setId(rs.getInt("ID_Bevanda"));
                bevanda.setNome(rs.getString("Nome"));
                bevanda.setPrezzo(rs.getDouble("Prezzo"));
                
                macchina.getBevande().add(bevanda);
            }
        }
    }
    
    		/**
    		 * Carica le cialde che compongono ogni bevanda della macchina.
    		 * 
    		 * @param macchina la macchina di cui caricare le composizioni delle bevande
    		 * @throws SQLException se si verifica un errore nell'accesso al database
    		 */
    		private void caricaComposizioneBevande(Macchina macchina) throws SQLException {
    		    String sql = "SELECT b.ID_Bevanda, c.ID_Cialda, c.Nome, c.TipoCialda FROM bevanda b JOIN bevandahacialda bc ON b.ID_Bevanda = bc.ID_Bevanda JOIN cialda c ON bc.ID_Cialda = c.ID_Cialda WHERE b.ID_Bevanda IN (SELECT mhb.ID_Bevanda FROM macchinahabevanda mhb WHERE mhb.ID_Macchina = ?) ORDER BY b.ID_Bevanda, c.ID_Cialda";

    		    try (Connection conn = dbConnection.getConnection();
    		            PreparedStatement stmt = conn.prepareStatement(sql, 
    		                ResultSet.TYPE_SCROLL_SENSITIVE, 
    		                ResultSet.CONCUR_READ_ONLY)) {
    		           
    		           stmt.setInt(1, macchina.getId());
    		           ResultSet rs = stmt.executeQuery();

    		           // Mappa temporanea per raggruppare le cialde per ID_Bevanda
    		           Map<Integer, List<Cialda>> cialdeBevande = new HashMap<>();

    		           // Popola la mappa con tutte le cialde
    		           while (rs.next()) {
    		               int idBevanda = rs.getInt("ID_Bevanda");
    		               
    		               Cialda cialda = new Cialda();
    		               cialda.setId(rs.getInt("ID_Cialda"));
    		               cialda.setNome(rs.getString("Nome"));
    		               cialda.setTipoCialda(rs.getString("TipoCialda"));

    		               cialdeBevande.computeIfAbsent(idBevanda, k -> new ArrayList<>())
    		                           .add(cialda);
    		           }

    		           // Assegna le cialde alle bevande
    		           for (Bevanda bevanda : macchina.getBevande()) {
    		               if (bevanda.getCialde() == null) {
    		                   bevanda.setCialde(new ArrayList<>());
    		               }
    		               List<Cialda> cialdeBevanda = cialdeBevande.get(bevanda.getId());
    		               if (cialdeBevanda != null) {
    		                   bevanda.getCialde().addAll(cialdeBevanda);
    		               }
    		           }
    		       }
    		   }
    /**
     * Carica tutti i dettagli associati alla macchina.
     */
    private void caricaDettagliMacchina(Macchina macchina) throws SQLException {
        caricaCialde(macchina);
        caricaBevande(macchina);
        caricaComposizioneBevande(macchina);
    }

    /**
     * Salva le cialde associate alla macchina.
     */
    private void salvaCialde(Connection conn, Macchina macchina) throws SQLException {
        String sql = "INSERT INTO quantitacialde (ID_Macchina, ID_Cialda, Quantita, QuantitaMassima) " +
                    "VALUES (?, ?, ?, ?)";
        
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            for (QuantitaCialde qc : macchina.getCialde()) {
                stmt.setInt(1, macchina.getId());
                stmt.setInt(2, qc.getCialdaId());
                stmt.setInt(3, qc.getQuantita());
                stmt.setInt(4, qc.getQuantitaMassima());
                stmt.addBatch();
            }
            stmt.executeBatch();
        }
    }

    /**
     * Salva le bevande associate alla macchina.
     */
    private void salvaBevande(Connection conn, Macchina macchina) throws SQLException {
        String sql = "INSERT INTO macchinahabevanda (ID_Macchina, ID_Bevanda) VALUES (?, ?)";
        
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            for (Bevanda bevanda : macchina.getBevande()) {
                stmt.setInt(1, macchina.getId());
                stmt.setInt(2, bevanda.getId());
                stmt.addBatch();
            }
            stmt.executeBatch();
        }
    }

    /**
     * Aggiorna le cialde associate alla macchina.
     * Elimina le associazioni esistenti e ne crea di nuove.
     *
     * @param conn Connessione al database
     * @param macchina Macchina di cui aggiornare le cialde
     * @throws SQLException se si verifica un errore durante l'aggiornamento
     */
    private void aggiornaCialde(Connection conn, Macchina macchina) throws SQLException {
        String deleteSQL = "DELETE FROM quantitacialde WHERE ID_Macchina = ?";
        try (PreparedStatement stmt = conn.prepareStatement(deleteSQL)) {
            stmt.setInt(1, macchina.getId());
            stmt.executeUpdate();
        }
        salvaCialde(conn, macchina);
    }

    /**
     * Aggiorna le bevande associate alla macchina.
     * Elimina le associazioni esistenti e ne crea di nuove.
     *
     * @param conn Connessione al database
     * @param macchina Macchina di cui aggiornare le bevande
     * @throws SQLException se si verifica un errore durante l'aggiornamento
     */
    private void aggiornaBevande(Connection conn, Macchina macchina) throws SQLException {
        String deleteSQL = "DELETE FROM macchinahabevanda WHERE ID_Macchina = ?";
        try (PreparedStatement stmt = conn.prepareStatement(deleteSQL)) {
            stmt.setInt(1, macchina.getId());
            stmt.executeUpdate();
        }
        salvaBevande(conn, macchina);
    }

    /**
     * Elimina tutte le cialde associate alla macchina.
     *
     * @param conn Connessione al database
     * @param macchinaId ID della macchina di cui eliminare le cialde
     * @throws SQLException se si verifica un errore durante l'eliminazione
     */
    private void eliminaCialde(Connection conn, int macchinaId) throws SQLException {
        String sql = "DELETE FROM quantitacialde WHERE ID_Macchina = ?";
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, macchinaId);
            stmt.executeUpdate();
        }
    }

    /**
     * Elimina tutte le bevande associate alla macchina.
     *
     * @param conn Connessione al database
     * @param macchinaId ID della macchina di cui eliminare le bevande
     * @throws SQLException se si verifica un errore durante l'eliminazione
     */
    private void eliminaBevande(Connection conn, int macchinaId) throws SQLException {
        String sql = "DELETE FROM macchinahabevanda WHERE ID_Macchina = ?";
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, macchinaId);
            stmt.executeUpdate();
        }
    }

    /**
     * Trova le macchine in base al loro stato.
     *
     * @param statoId ID dello stato da cercare (dalla tabella statomacchina)
     * @return Lista delle macchine nello stato specificato
     * @throws RuntimeException se si verifica un errore durante la ricerca
     */
    public List<Macchina> findByStato(int statoId) {
        List<Macchina> macchine = new ArrayList<>();
        String sql = "SELECT m.*, i.Nome as NomeIstituto, sm.Descrizione as StatoDescrizione " +
                    "FROM macchina m " +
                    "JOIN istituto i ON m.ID_Istituto = i.ID_Istituto " +
                    "JOIN statomacchina sm ON m.Stato = sm.ID_StatoMacchina " +
                    "WHERE m.Stato = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, statoId);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                Macchina macchina = mapResultSetToMacchina(rs);
                caricaDettagliMacchina(macchina);
                macchine.add(macchina);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero delle macchine per stato", e);
        }
        return macchine;
    }

    /**
     * Aggiorna lo stato di una macchina.
     *
     * @param macchinaId ID della macchina
     * @param nuovoStatoId Nuovo ID dello stato
     * @return true se l'aggiornamento ha avuto successo
     * @throws RuntimeException se si verifica un errore durante l'aggiornamento
     */
    public boolean aggiornaStato(int macchinaId, int nuovoStatoId) {
        String sql = "UPDATE macchina SET Stato = ? WHERE ID_Macchina = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, nuovoStatoId);
            stmt.setInt(2, macchinaId);
            
            int affectedRows = stmt.executeUpdate();
            return affectedRows > 0;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'aggiornamento dello stato della macchina", e);
        }
    }
}

================
File: src/main/java/com/vending/core/repositories/ManutenzioneRepository.java
================
package com.vending.core.repositories;

import com.vending.core.models.Manutenzione;
import java.sql.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Repository per la gestione delle manutenzioni delle macchine distributrici.
 * Gestisce le interazioni con la tabella 'macchina' e 'statomacchina' per
 * tenere traccia degli interventi di manutenzione.
 */
public class ManutenzioneRepository {
    private final DatabaseConnection dbConnection;

    /**
     * Costruttore del repository.
     */
    public ManutenzioneRepository() {
        this.dbConnection = DatabaseConnection.getInstance();
    }

    /**
     * Trova tutte le macchine in manutenzione.
     *
     * @return lista delle macchine in manutenzione
     */
    public List<Manutenzione> findAll() {
        List<Manutenzione> manutenzioni = new ArrayList<>();
        String sql = "SELECT m.*, i.Nome as NomeIstituto, u.Nome as NomeTecnico " +
                    "FROM macchina m " +
                    "JOIN istituto i ON m.ID_Istituto = i.ID_Istituto " +
                    "LEFT JOIN utente u ON u.ID_Utente = m.ID_Tecnico " +
                    "WHERE m.Stato = 2";  // 2 = In manutenzione
        
        try (Connection conn = dbConnection.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            
            while (rs.next()) {
                manutenzioni.add(mapResultSetToManutenzione(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore nel recupero delle manutenzioni", e);
        }
        return manutenzioni;
    }

    /**
     * Trova una specifica manutenzione.
     *
     * @param id ID della macchina in manutenzione
     * @return Optional contenente la manutenzione se trovata
     */
    public Optional<Manutenzione> findById(int id) {
        String sql = "SELECT m.*, i.Nome as NomeIstituto, u.Nome as NomeTecnico " +
                    "FROM macchina m " +
                    "JOIN istituto i ON m.ID_Istituto = i.ID_Istituto " +
                    "LEFT JOIN utente u ON u.ID_Utente = m.ID_Tecnico " +
                    "WHERE m.ID_Macchina = ? AND m.Stato = 2";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return Optional.of(mapResultSetToManutenzione(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore nel recupero della manutenzione", e);
        }
        return Optional.empty();
    }

    /**
     * Recupera tutte le manutenzioni di una specifica macchina, incluse quelle completate.
     *
     * @param macchinaId ID della macchina
     * @return lista delle manutenzioni della macchina
     */
    public List<Manutenzione> findByMacchinaId(int macchinaId) {
        List<Manutenzione> manutenzioni = new ArrayList<>();
        String sql = "SELECT m.*, i.Nome as NomeIstituto, u.Nome as NomeTecnico, " +
                    "man.DataInizio, man.DataCompletamento, man.ID as ManId " +
                    "FROM macchina m " +
                    "JOIN istituto i ON m.ID_Istituto = i.ID_Istituto " +
                    "JOIN manutenzione man ON man.ID_Macchina = m.ID_Macchina " +
                    "LEFT JOIN utente u ON u.ID_Utente = man.ID_Tecnico " +
                    "WHERE m.ID_Macchina = ? " +
                    "ORDER BY man.DataInizio DESC";
        
        try (Connection conn = dbConnection.getConnection();
            PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, macchinaId);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                Manutenzione manutenzione = new Manutenzione();
                manutenzione.setId(rs.getInt("ManId"));
                manutenzione.setMacchinaId(rs.getInt("ID_Macchina"));
                manutenzione.setNomeIstituto(rs.getString("NomeIstituto"));
                manutenzione.setTecnicoId(rs.getInt("ID_Tecnico"));
                manutenzione.setNomeTecnico(rs.getString("NomeTecnico"));
                
                Timestamp dataInizio = rs.getTimestamp("DataInizio");
                if (dataInizio != null) {
                    manutenzione.setDataRichiesta(dataInizio.toLocalDateTime());
                }
                
                Timestamp dataCompletamento = rs.getTimestamp("DataCompletamento");
                if (dataCompletamento != null) {
                    manutenzione.setDataCompletamento(dataCompletamento.toLocalDateTime());
                }
                
                manutenzioni.add(manutenzione);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore nel recupero delle manutenzioni per macchina", e);
        }
        return manutenzioni;
    }

    /**
     * Trova tutte le macchine in manutenzione per un istituto.
     *
     * @param istitutoId ID dell'istituto
     * @return lista delle macchine in manutenzione nell'istituto
     */
    public List<Manutenzione> findByIstitutoId(int istitutoId) {
        List<Manutenzione> manutenzioni = new ArrayList<>();
        String sql = "SELECT m.*, i.Nome as NomeIstituto, u.Nome as NomeTecnico " +
                    "FROM macchina m " +
                    "JOIN istituto i ON m.ID_Istituto = i.ID_Istituto " +
                    "LEFT JOIN utente u ON u.ID_Utente = m.ID_Tecnico " +
                    "WHERE m.ID_Istituto = ? AND m.Stato = 2";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, istitutoId);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                manutenzioni.add(mapResultSetToManutenzione(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore nel recupero delle manutenzioni per istituto", e);
        }
        return manutenzioni;
    }

    /**
     * Trova tutte le macchine assegnate a un tecnico.
     *
     * @param tecnicoId ID del tecnico
     * @return lista delle macchine in manutenzione assegnate al tecnico
     */
    public List<Manutenzione> findByTecnicoId(int tecnicoId) {
        List<Manutenzione> manutenzioni = new ArrayList<>();
        String sql = "SELECT m.*, i.Nome as NomeIstituto, u.Nome as NomeTecnico " +
                    "FROM macchina m " +
                    "JOIN istituto i ON m.ID_Istituto = i.ID_Istituto " +
                    "LEFT JOIN utente u ON u.ID_Utente = m.ID_Tecnico " +
                    "WHERE m.ID_Tecnico = ? AND m.Stato = 2";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, tecnicoId);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                manutenzioni.add(mapResultSetToManutenzione(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore nel recupero delle manutenzioni per tecnico", e);
        }
        return manutenzioni;
    }

    /**
     * Inizia una nuova manutenzione per una macchina.
     *
     * @param manutenzione dati della manutenzione
     * @return manutenzione iniziata
     */
    public Manutenzione iniziaManutenzione(Manutenzione manutenzione) {
        String sql = "UPDATE macchina SET Stato = 2, ID_Tecnico = ? WHERE ID_Macchina = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, manutenzione.getTecnicoId());
            stmt.setInt(2, manutenzione.getMacchinaId());
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("Inizializzazione manutenzione fallita");
            }
            
            return manutenzione;
        } catch (SQLException e) {
            throw new RuntimeException("Errore nell'inizializzazione della manutenzione", e);
        }
    }

    /**
     * Completa una manutenzione.
     *
     * @param manutenzione dati della manutenzione completata
     * @return manutenzione completata
     */
    public Manutenzione completaManutenzione(Manutenzione manutenzione) {
        String sql = "UPDATE macchina SET Stato = 1, ID_Tecnico = NULL WHERE ID_Macchina = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, manutenzione.getMacchinaId());
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("Completamento manutenzione fallito");
            }
            
            manutenzione.setDataCompletamento(LocalDateTime.now());
            return manutenzione;
        } catch (SQLException e) {
            throw new RuntimeException("Errore nel completamento della manutenzione", e);
        }
    }

    /**
     * Segna una macchina come fuori servizio.
     *
     * @param macchinaId ID della macchina
     * @return true se l'operazione ha successo
     */
    public boolean setFuoriServizio(int macchinaId) {
        String sql = "UPDATE macchina SET Stato = 3 WHERE ID_Macchina = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, macchinaId);
            int affectedRows = stmt.executeUpdate();
            return affectedRows > 0;
        } catch (SQLException e) {
            throw new RuntimeException("Errore nell'impostazione fuori servizio", e);
        }
    }

    /**
     * Converte un ResultSet in un oggetto Manutenzione.
     */
    private Manutenzione mapResultSetToManutenzione(ResultSet rs) throws SQLException {
        Manutenzione manutenzione = new Manutenzione();
        manutenzione.setId(rs.getInt("id"));
        manutenzione.setMacchinaId(rs.getInt("ID_Macchina"));
        manutenzione.setNomeIstituto(rs.getString("NomeIstituto"));
        manutenzione.setTecnicoId(rs.getInt("ID_Tecnico"));
        manutenzione.setNomeTecnico(rs.getString("NomeTecnico"));
        manutenzione.setDataRichiesta(LocalDateTime.now());
        return manutenzione;
    }
}

================
File: src/main/java/com/vending/core/repositories/RicavoRepository.java
================
package com.vending.core.repositories;

import com.vending.core.models.Ricavo;
import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Repository per la gestione dei ricavi delle macchine distributrici.
 * Gestisce le operazioni CRUD per la tabella 'ricavo' e utilizza la vista
 * 'ricavigiornalieri' per le statistiche aggregate.
 */
public class RicavoRepository {
    private final DatabaseConnection dbConnection;

    /**
     * Costruttore del repository.
     */
    public RicavoRepository() {
        this.dbConnection = DatabaseConnection.getInstance();
    }

    /**
     * Trova tutti i ricavi ordinati per data.
     *
     * @return lista di tutti i ricavi
     */
    public List<Ricavo> findAll() {
        List<Ricavo> ricavi = new ArrayList<>();
        String sql = "SELECT r.*, i.Nome as NomeIstituto " +
                    "FROM ricavo r " +
                    "JOIN macchina m ON r.ID_Macchina = m.ID_Macchina " +
                    "JOIN istituto i ON m.ID_Istituto = i.ID_Istituto " +
                    "ORDER BY r.DataOra DESC";
        
        try (Connection conn = dbConnection.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            
            while (rs.next()) {
                ricavi.add(mapResultSetToRicavo(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero dei ricavi", e);
        }
        return ricavi;
    }

    /**
     * Trova i ricavi di una specifica macchina.
     *
     * @param macchinaId ID della macchina
     * @return lista dei ricavi della macchina
     */
    public List<Ricavo> findByMacchinaId(int macchinaId) {
        List<Ricavo> ricavi = new ArrayList<>();
        String sql = "SELECT r.*, i.Nome as NomeIstituto " +
                    "FROM ricavo r " +
                    "JOIN macchina m ON r.ID_Macchina = m.ID_Macchina " +
                    "JOIN istituto i ON m.ID_Istituto = i.ID_Istituto " +
                    "WHERE r.ID_Macchina = ? " +
                    "ORDER BY r.DataOra DESC";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, macchinaId);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                ricavi.add(mapResultSetToRicavo(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero dei ricavi della macchina", e);
        }
        return ricavi;
    }

    /**
     * Trova i ricavi giornalieri di un istituto.
     *
     * @param istitutoId ID dell'istituto
     * @param data data di riferimento
     * @return ricavo giornaliero
     */
    public Optional<Double> findRicavoGiornaliero(int istitutoId, LocalDate data) {
        String sql = "SELECT SUM(RicavoGiornaliero) as Totale FROM ricavigiornalieri " +
                    "WHERE ID_Istituto = ? AND Data = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, istitutoId);
            stmt.setDate(2, java.sql.Date.valueOf(data));
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return Optional.ofNullable(rs.getDouble("Totale"));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il calcolo del ricavo giornaliero", e);
        }
        return Optional.empty();
    }

    /**
     * Salva un nuovo ricavo.
     *
     * @param ricavo ricavo da salvare
     * @return ricavo salvato con ID generato
     */
    public Ricavo save(Ricavo ricavo) {
        String sql = "INSERT INTO ricavo (ID_Macchina, Importo, DataOra) VALUES (?, ?, ?)";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            
            stmt.setInt(1, ricavo.getMacchinaId());
            stmt.setDouble(2, ricavo.getImporto());
            stmt.setTimestamp(3, Timestamp.valueOf(ricavo.getDataOra()));
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("La creazione del ricavo è fallita");
            }
            
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    ricavo.setId(generatedKeys.getInt(1));
                    return ricavo;
                } else {
                    throw new SQLException("La creazione del ricavo è fallita, nessun ID ottenuto");
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il salvataggio del ricavo", e);
        }
    }

    /**
     * Calcola il totale dei ricavi di una macchina.
     *
     * @param macchinaId ID della macchina
     * @return totale dei ricavi
     */
    public Double getTotaleRicaviByMacchina(int macchinaId) {
        String sql = "SELECT SUM(Importo) as totale FROM ricavo WHERE ID_Macchina = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, macchinaId);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return rs.getDouble("totale");
            }
            return 0.0;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il calcolo del totale ricavi", e);
        }
    }

    /**
     * Calcola il totale dei ricavi in un periodo.
     *
     * @param dataInizio data iniziale del periodo
     * @param dataFine data finale del periodo
     * @return totale dei ricavi nel periodo
     */
    public Double getTotaleRicaviPeriodo(LocalDateTime dataInizio, LocalDateTime dataFine) {
        String sql = "SELECT SUM(Importo) as totale FROM ricavo WHERE DataOra BETWEEN ? AND ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setTimestamp(1, Timestamp.valueOf(dataInizio));
            stmt.setTimestamp(2, Timestamp.valueOf(dataFine));
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return rs.getDouble("totale");
            }
            return 0.0;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il calcolo del totale ricavi del periodo", e);
        }
    }

    /**
     * Converte un ResultSet in un oggetto Ricavo.
     */
    private Ricavo mapResultSetToRicavo(ResultSet rs) throws SQLException {
        Ricavo ricavo = new Ricavo();
        ricavo.setId(rs.getInt("ID_Ricavo"));
        ricavo.setMacchinaId(rs.getInt("ID_Macchina"));
        ricavo.setNomeIstituto(rs.getString("NomeIstituto"));
        ricavo.setImporto(rs.getDouble("Importo"));
        ricavo.setDataOra(rs.getTimestamp("DataOra").toLocalDateTime());
        return ricavo;
    }
}

================
File: src/main/java/com/vending/core/repositories/TransazioneRepository.java
================
package com.vending.core.repositories;

import com.vending.core.models.Transazione;
import java.sql.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Repository per la gestione delle transazioni delle macchine distributrici.
 * Gestisce le operazioni CRUD per la tabella 'transazione' e utilizza la vista
 * 'transazionirecenti' per le consultazioni recenti.
 */
public class TransazioneRepository {
    private final DatabaseConnection dbConnection;

    /**
     * Costruttore del repository.
     */
    public TransazioneRepository() {
        this.dbConnection = DatabaseConnection.getInstance();
    }

    /**
     * Trova tutte le transazioni ordinate per data.
     *
     * @return lista di tutte le transazioni
     */
    public List<Transazione> findAll() {
        List<Transazione> transazioni = new ArrayList<>();
        String sql = "SELECT t.*, i.Nome as NomeIstituto, b.Nome as NomeBevanda " +
                    "FROM transazione t " +
                    "JOIN macchina m ON t.ID_Macchina = m.ID_Macchina " +
                    "JOIN istituto i ON m.ID_Istituto = i.ID_Istituto " +
                    "JOIN bevanda b ON t.ID_Bevanda = b.ID_Bevanda " +
                    "ORDER BY t.DataOra DESC";
        
        try (Connection conn = dbConnection.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            
            while (rs.next()) {
                transazioni.add(mapResultSetToTransazione(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero delle transazioni", e);
        }
        return transazioni;
    }

    /**
     * Trova una transazione tramite ID.
     *
     * @param id ID della transazione
     * @return Optional contenente la transazione se trovata
     */
    public Optional<Transazione> findById(int id) {
        String sql = "SELECT t.*, i.Nome as NomeIstituto, b.Nome as NomeBevanda " +
                    "FROM transazione t " +
                    "JOIN macchina m ON t.ID_Macchina = m.ID_Macchina " +
                    "JOIN istituto i ON m.ID_Istituto = i.ID_Istituto " +
                    "JOIN bevanda b ON t.ID_Bevanda = b.ID_Bevanda " +
                    "WHERE t.ID_Transazione = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return Optional.of(mapResultSetToTransazione(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore nel recupero della transazione", e);
        }
        return Optional.empty();
    }

    /**
     * Trova le transazioni di una macchina.
     *
     * @param macchinaId ID della macchina
     * @return lista delle transazioni della macchina
     */
    public List<Transazione> findByMacchinaId(int macchinaId) {
        List<Transazione> transazioni = new ArrayList<>();
        String sql = "SELECT t.*, i.Nome as NomeIstituto, b.Nome as NomeBevanda " +
                    "FROM transazione t " +
                    "JOIN macchina m ON t.ID_Macchina = m.ID_Macchina " +
                    "JOIN istituto i ON m.ID_Istituto = i.ID_Istituto " +
                    "JOIN bevanda b ON t.ID_Bevanda = b.ID_Bevanda " +
                    "WHERE t.ID_Macchina = ? " +
                    "ORDER BY t.DataOra DESC";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, macchinaId);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                transazioni.add(mapResultSetToTransazione(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero delle transazioni della macchina", e);
        }
        return transazioni;
    }

    /**
     * Trova le transazioni recenti.
     * Utilizza la vista 'transazionirecenti' che mostra le ultime 100 transazioni.
     *
     * @return lista delle transazioni recenti
     */
    public List<Transazione> findTransazioniRecenti() {
        List<Transazione> transazioni = new ArrayList<>();
        String sql = "SELECT * FROM transazionirecenti";
        
        try (Connection conn = dbConnection.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            
            while (rs.next()) {
                transazioni.add(mapResultSetToTransazione(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero delle transazioni recenti", e);
        }
        return transazioni;
    }

    /**
     * Salva una nuova transazione.
     *
     * @param transazione transazione da salvare
     * @return transazione salvata con ID generato
     */
    public Transazione save(Transazione transazione) {
        String sql = "INSERT INTO transazione (ID_Macchina, ID_Bevanda, Importo, DataOra) " +
                    "VALUES (?, ?, ?, ?)";
                    
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            
            stmt.setInt(1, transazione.getMacchinaId());
            stmt.setInt(2, transazione.getBevandaId());
            stmt.setDouble(3, transazione.getImporto());
            stmt.setTimestamp(4, Timestamp.valueOf(transazione.getDataOra()));
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("La creazione della transazione è fallita");
            }
            
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    transazione.setId(generatedKeys.getInt(1));
                    return transazione;
                } else {
                    throw new SQLException("La creazione della transazione è fallita, nessun ID ottenuto");
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il salvataggio della transazione", e);
        }
    }

    /**
     * Calcola il totale delle transazioni di una macchina in un periodo.
     *
     * @param macchinaId ID della macchina
     * @param dataInizio data iniziale del periodo
     * @param dataFine data finale del periodo
     * @return totale delle transazioni
     */
    public Double calcolaTotaleMacchina(int macchinaId, LocalDateTime dataInizio, LocalDateTime dataFine) {
        String sql = "SELECT SUM(Importo) as totale FROM transazione " +
                    "WHERE ID_Macchina = ? AND DataOra BETWEEN ? AND ?";
                    
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, macchinaId);
            stmt.setTimestamp(2, Timestamp.valueOf(dataInizio));
            stmt.setTimestamp(3, Timestamp.valueOf(dataFine));
            
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return Optional.ofNullable(rs.getDouble("totale"))
                    .orElse(0.0);
            }
            return 0.0;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il calcolo del totale", e);
        }
    }

    /**
     * Converte un ResultSet in un oggetto Transazione.
     */
    private Transazione mapResultSetToTransazione(ResultSet rs) throws SQLException {
        Transazione transazione = new Transazione();
        transazione.setId(rs.getInt("ID_Transazione"));
        transazione.setMacchinaId(rs.getInt("ID_Macchina"));
        transazione.setBevandaId(rs.getInt("ID_Bevanda"));
        transazione.setNomeIstituto(rs.getString("NomeIstituto"));
        transazione.setNomeBevanda(rs.getString("NomeBevanda"));
        transazione.setImporto(rs.getDouble("Importo"));
        transazione.setDataOra(rs.getTimestamp("DataOra").toLocalDateTime());
        return transazione;
    }
}

================
File: src/main/java/com/vending/core/repositories/UtenteRepository.java
================
package com.vending.core.repositories;

import com.vending.core.models.Utente;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Repository per la gestione degli utenti del sistema.
 * Gestisce le operazioni CRUD per la tabella 'utente' e le sue relazioni
 * con la tabella 'adminlogin'.
 */
public class UtenteRepository {
    private final DatabaseConnection dbConnection;

    /**
     * Costruttore del repository.
     */
    public UtenteRepository() {
        this.dbConnection = DatabaseConnection.getInstance();
    }

    /**
     * Trova tutti gli utenti.
     *
     * @return lista di tutti gli utenti
     */
    public List<Utente> findAll() {
        List<Utente> utenti = new ArrayList<>();
        String sql = "SELECT u.*, al.Username, al.UltimoAccesso " +
                    "FROM utente u " +
                    "LEFT JOIN adminlogin al ON u.ID_Utente = al.ID_Utente";
        
        try (Connection conn = dbConnection.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            
            while (rs.next()) {
                utenti.add(mapResultSetToUtente(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero degli utenti", e);
        }
        return utenti;
    }

    /**
     * Trova un utente tramite ID.
     *
     * @param id ID dell'utente
     * @return Optional contenente l'utente se trovato
     */
    public Optional<Utente> findById(int id) {
        String sql = "SELECT u.*, al.Username, al.UltimoAccesso " +
                    "FROM utente u " +
                    "LEFT JOIN adminlogin al ON u.ID_Utente = al.ID_Utente " +
                    "WHERE u.ID_Utente = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return Optional.of(mapResultSetToUtente(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore nel recupero dell'utente", e);
        }
        return Optional.empty();
    }

    /**
     * Trova un utente tramite username.
     *
     * @param username username da cercare
     * @return Optional contenente l'utente se trovato
     */
    public Utente findByUsername(String username) {
        String sql = "SELECT u.*, al.Username, al.UltimoAccesso " +
                    "FROM utente u " +
                    "JOIN adminlogin al ON u.ID_Utente = al.ID_Utente " +
                    "WHERE al.Username = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, username);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return mapResultSetToUtente(rs);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante la ricerca dell'utente", e);
        }
        return null;
    }

    /**
     * Trova gli utenti per ruolo.
     *
     * @param ruolo ruolo da cercare
     * @return lista degli utenti con il ruolo specificato
     */
    public List<Utente> findByRuolo(String ruolo) {
        List<Utente> utenti = new ArrayList<>();
        String sql = "SELECT u.*, al.Username, al.UltimoAccesso " +
                    "FROM utente u " +
                    "LEFT JOIN adminlogin al ON u.ID_Utente = al.ID_Utente " +
                    "WHERE u.Ruolo = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, ruolo);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                utenti.add(mapResultSetToUtente(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero degli utenti per ruolo", e);
        }
        return utenti;
    }

    /**
     * Salva un nuovo utente.
     *
     * @param utente utente da salvare
     * @return utente salvato con ID generato
     */
    public Utente save(Utente utente) {
        String sql = "INSERT INTO utente (Nome, Ruolo) VALUES (?, ?)";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            
            stmt.setString(1, utente.getNome());
            stmt.setString(2, utente.getRuolo());
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("La creazione dell'utente è fallita");
            }
            
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    utente.setId(generatedKeys.getInt(1));
                    return utente;
                } else {
                    throw new SQLException("La creazione dell'utente è fallita, nessun ID ottenuto");
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il salvataggio dell'utente", e);
        }
    }

    /**
     * Aggiorna un utente esistente.
     *
     * @param utente utente da aggiornare
     * @return utente aggiornato
     */
    public Utente update(Utente utente) {
        String sql = "UPDATE utente SET Nome = ?, Ruolo = ? WHERE ID_Utente = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, utente.getNome());
            stmt.setString(2, utente.getRuolo());
            stmt.setInt(3, utente.getId());
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("L'aggiornamento dell'utente è fallito");
            }
            return utente;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'aggiornamento dell'utente", e);
        }
    }

    /**
     * Elimina un utente.
     *
     * @param id ID dell'utente da eliminare
     * @return true se l'eliminazione ha successo
     */
    public boolean delete(int id) {
        String sql = "DELETE FROM utente WHERE ID_Utente = ?";
        
        try (Connection conn = dbConnection.getConnection()) {
            conn.setAutoCommit(false);
            try {
                // Prima elimina eventuali login associati
                deleteAdminLogin(conn, id);
                
                // Poi elimina l'utente
                try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                    stmt.setInt(1, id);
                    int affectedRows = stmt.executeUpdate();
                    conn.commit();
                    return affectedRows > 0;
                }
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'eliminazione dell'utente", e);
        }
    }

    /**
     * Elimina i dati di login di un utente.
     */
    private void deleteAdminLogin(Connection conn, int utenteId) throws SQLException {
        String sql = "DELETE FROM adminlogin WHERE ID_Utente = ?";
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, utenteId);
            stmt.executeUpdate();
        }
    }

    /**
     * Converte un ResultSet in un oggetto Utente.
     */
    private Utente mapResultSetToUtente(ResultSet rs) throws SQLException {
        Utente utente = new Utente();
        utente.setId(rs.getInt("ID_Utente"));
        utente.setNome(rs.getString("Nome"));
        utente.setRuolo(rs.getString("Ruolo"));
        
        // Gestione dei campi opzionali da adminlogin
        String username = rs.getString("Username");
        if (username != null) {
            utente.setUsername(username);
            utente.setUltimoAccesso(rs.getTimestamp("UltimoAccesso").toLocalDateTime());
        }
        
        return utente;
    }
}

================
File: src/main/java/com/vending/core/services/AdminLoginService.java
================
package com.vending.core.services;

import com.vending.core.models.AdminLogin;
import com.vending.core.models.Utente;
import com.vending.core.repositories.AdminLoginRepository;
import com.vending.core.repositories.UtenteRepository;
import java.time.LocalDateTime;
import java.util.Optional;

/**
 * Servizio che gestisce la logica di business per l'autenticazione e la gestione
 * degli accessi amministrativi al sistema.
 */
public class AdminLoginService {
    private final AdminLoginRepository adminLoginRepository;
    private final UtenteRepository utenteRepository;

    /**
     * Costruttore del servizio.
     *
     * @param adminLoginRepository repository per l'accesso ai dati di AdminLogin
     * @param utenteRepository repository per l'accesso ai dati degli Utenti
     */
    public AdminLoginService(AdminLoginRepository adminLoginRepository, UtenteRepository utenteRepository) {
        this.adminLoginRepository = adminLoginRepository;
        this.utenteRepository = utenteRepository;
    }

    /**
     * Autentica un utente utilizzando username e password.
     *
     * @param username nome utente
     * @param password password in chiaro
     * @return Optional contenente l'AdminLogin se l'autenticazione ha successo
     */
    public Optional<AdminLogin> autenticaUtente(String username, String password) {
        Optional<AdminLogin> loginOpt = adminLoginRepository.findByUsername(username);
        
        if (loginOpt.isPresent()) {
            AdminLogin login = loginOpt.get();
            if (login.verificaPassword(password)) {
                login.aggiornaUltimoAccesso();
                adminLoginRepository.update(login);
                return Optional.of(login);
            }
        }
        return Optional.empty();
    }

    /**
     * Crea un nuovo accesso amministrativo per un utente.
     *
     * @param utenteId ID dell'utente
     * @param username nome utente desiderato
     * @param password password in chiaro
     * @return AdminLogin creato
     * @throws IllegalArgumentException se l'utente non esiste o lo username è già in uso
     */
    public AdminLogin creaAccessoAmministrativo(int utenteId, String username, String password) {
        // Verifica esistenza utente
        Utente utente = utenteRepository.findById(utenteId)
            .orElseThrow(() -> new IllegalArgumentException("Utente non trovato"));

        // Verifica unicità username
        if (adminLoginRepository.findByUsername(username).isPresent()) {
            throw new IllegalArgumentException("Username già in uso");
        }

        // Crea nuovo accesso
        AdminLogin adminLogin = new AdminLogin(utenteId, username, password);
        adminLogin.setUtente(utente);
        
        return adminLoginRepository.save(adminLogin);
    }

    /**
     * Modifica la password di un accesso amministrativo.
     *
     * @param adminLoginId ID dell'accesso amministrativo
     * @param vecchiaPassword password attuale
     * @param nuovaPassword nuova password
     * @return true se la modifica ha successo
     * @throws IllegalArgumentException se l'accesso non esiste o la vecchia password è errata
     */
    public boolean modificaPassword(int adminLoginId, String vecchiaPassword, String nuovaPassword) {
        AdminLogin login = adminLoginRepository.findById(adminLoginId)
            .orElseThrow(() -> new IllegalArgumentException("Accesso amministrativo non trovato"));

        if (!login.verificaPassword(vecchiaPassword)) {
            throw new IllegalArgumentException("Password attuale non corretta");
        }

        login.setPassword(nuovaPassword);
        adminLoginRepository.update(login);
        return true;
    }

    /**
     * Disattiva un accesso amministrativo.
     *
     * @param adminLoginId ID dell'accesso amministrativo
     * @return true se la disattivazione ha successo
     */
    public boolean disattivaAccesso(int adminLoginId) {
        return adminLoginRepository.delete(adminLoginId);
    }

    /**
     * Verifica se un username è disponibile.
     *
     * @param username username da verificare
     * @return true se lo username è disponibile
     */
    public boolean isUsernameDisponibile(String username) {
        return adminLoginRepository.findByUsername(username).isEmpty();
    }

    /**
     * Recupera l'accesso amministrativo di un utente.
     *
     * @param utenteId ID dell'utente
     * @return Optional contenente l'AdminLogin se esistente
     */
    public Optional<AdminLogin> getAccessoPerUtente(int utenteId) {
        return adminLoginRepository.findByUtenteId(utenteId);
    }

    /**
     * Verifica se un utente ha accesso amministrativo.
     *
     * @param utenteId ID dell'utente
     * @return true se l'utente ha un accesso amministrativo
     */
    public boolean haAccessoAmministrativo(int utenteId) {
        return adminLoginRepository.findByUtenteId(utenteId).isPresent();
    }

    /**
     * Recupera l'ultima data di accesso di un utente.
     *
     * @param username username dell'utente
     * @return Optional contenente la data dell'ultimo accesso
     */
    public Optional<LocalDateTime> getUltimoAccesso(String username) {
        return adminLoginRepository.findByUsername(username)
            .map(AdminLogin::getUltimoAccesso);
    }
}

================
File: src/main/java/com/vending/core/services/BevandaService.java
================
package com.vending.core.services;

import com.vending.core.models.Bevanda;
import com.vending.core.models.Cialda;
import com.vending.core.repositories.BevandaRepository;
import com.vending.core.repositories.CialdaRepository;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Servizio che gestisce la logica di per le bevande disponibili
 * nelle macchine distributrici.
 */
public class BevandaService {
    private final BevandaRepository bevandaRepository;
    private final CialdaRepository cialdaRepository;

    /**
     * Costruttore del servizio.
     *
     * @param bevandaRepository repository per l'accesso ai dati delle bevande
     * @param cialdaRepository repository per l'accesso ai dati delle cialde
     */
    public BevandaService(BevandaRepository bevandaRepository, CialdaRepository cialdaRepository) {
        this.bevandaRepository = bevandaRepository;
        this.cialdaRepository = cialdaRepository;
    }

    /**
     * Recupera tutte le bevande disponibili.
     *
     * @return lista di tutte le bevande
     */
    public List<Bevanda> getTutteBevande() {
        return bevandaRepository.findAll();
    }

    /**
     * Recupera una bevanda specifica.
     *
     * @param id ID della bevanda
     * @return Optional contenente la bevanda se trovata
     */
    public Optional<Bevanda> getBevandaById(int id) {
        return bevandaRepository.findById(id);
    }

    /**
     * Crea una nuova bevanda.
     *
     * @param nome nome della bevanda
     * @param prezzo prezzo della bevanda
     * @param cialdeIds lista degli ID delle cialde necessarie
     * @return bevanda creata
     */
    public Bevanda creaBevanda(String nome, Double prezzo, List<Integer> cialdeIds) {
        // Valida i parametri base
        validaParametriBevanda(nome, prezzo);

        // Verifica e recupera le cialde
        List<Cialda> cialde = recuperaCialde(cialdeIds);

        // Crea e salva la bevanda
        Bevanda bevanda = new Bevanda(nome, prezzo);
        bevanda.setCialde(cialde);
        return bevandaRepository.save(bevanda);
    }

    /**
     * Aggiorna una bevanda esistente.
     *
     * @param id ID della bevanda da aggiornare
     * @param nome nuovo nome
     * @param prezzo nuovo prezzo 
     * @param cialdeIds nuova lista di ID delle cialde
     * @return bevanda aggiornata
     */
    public Bevanda aggiornaBevanda(int id, String nome, Double prezzo, List<Integer> cialdeIds) {
        // Recupera la bevanda esistente
        Bevanda bevanda = bevandaRepository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("Bevanda non trovata"));

        // Aggiorna solo i campi forniti
        if (nome != null && !nome.trim().isEmpty()) {
            bevanda.setNome(nome);
        }
        if (prezzo != null && prezzo > 0) {
            bevanda.setPrezzo(prezzo);
        }
        if (cialdeIds != null && !cialdeIds.isEmpty()) {
            bevanda.setCialde(recuperaCialde(cialdeIds));
        }

        return bevandaRepository.update(bevanda);
    }

    /**
     * Elimina una bevanda.
     *
     * @param id ID della bevanda da eliminare
     * @return true se l'eliminazione ha successo
     */
    public boolean eliminaBevanda(int id) {
        return bevandaRepository.delete(id);
    }

    /**
     * Aggiunge una cialda a una bevanda.
     *
     * @param bevandaId ID della bevanda
     * @param cialdaId ID della cialda da aggiungere
     */
    public void aggiungiCialda(int bevandaId, int cialdaId) {
        // Recupera bevanda e cialda
        Bevanda bevanda = bevandaRepository.findById(bevandaId)
            .orElseThrow(() -> new IllegalArgumentException("Bevanda non trovata"));
        
        Cialda cialda = cialdaRepository.findById(cialdaId)
            .orElseThrow(() -> new IllegalArgumentException("Cialda non trovata"));

        // Aggiunge la cialda e aggiorna
        bevanda.aggiungiCialda(cialda);
        bevandaRepository.update(bevanda);
    }

    /**
     * Rimuove una cialda da una bevanda.
     *
     * @param bevandaId ID della bevanda
     * @param cialdaId ID della cialda da rimuovere
     */
    public void rimuoviCialda(int bevandaId, int cialdaId) {
        // Recupera la bevanda
        Bevanda bevanda = bevandaRepository.findById(bevandaId)
            .orElseThrow(() -> new IllegalArgumentException("Bevanda non trovata"));

        // Verifica che rimanga almeno una cialda
        if (bevanda.getCialde().size() <= 1) {
            throw new IllegalStateException("La bevanda deve mantenere almeno una cialda");
        }

        // Rimuove la cialda e aggiorna
        bevanda.getCialde().removeIf(c -> c.getId() == cialdaId);
        bevandaRepository.update(bevanda);
    }

    /**
     * Recupera le cialde per una lista di ID.
     */
    private List<Cialda> recuperaCialde(List<Integer> cialdeIds) {
        return cialdeIds.stream()
            .map(id -> cialdaRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Cialda non trovata: " + id)))
            .collect(Collectors.toList());
    }

    /**
     * Valida i parametri base di una bevanda.
     */
    private void validaParametriBevanda(String nome, Double prezzo) {
        if (nome == null || nome.trim().isEmpty()) {
            throw new IllegalArgumentException("Nome bevanda obbligatorio");
        }
        if (prezzo == null || prezzo <= 0) {
            throw new IllegalArgumentException("Prezzo non valido");
        }
    }
}

================
File: src/main/java/com/vending/core/services/IstitutoService.java
================
package com.vending.core.services;

import com.vending.core.models.Istituto;
import com.vending.core.models.Macchina;
import com.vending.core.repositories.IstitutoRepository;
import com.vending.core.repositories.MacchinaRepository;

import java.sql.SQLException;
import java.util.List;

/**
 * Servizio per la gestione degli istituti nel sistema di distribuzione automatica.
 * 
 * Questa classe fornisce operazioni di business logic per la gestione degli istituti,
 * inclusi metodi per la creazione, lettura, aggiornamento ed eliminazione degli istituti,
 * nonché la gestione delle macchine associate.
 */
public class IstitutoService {
    private final IstitutoRepository istitutoRepository;
    private final MacchinaRepository macchinaRepository;

    /**
     * Costruttore per il servizio degli istituti.
     * 
     * @param istitutoRepository Repository per le operazioni sui dati degli istituti
     * @param macchinaRepository Repository per le operazioni sui dati delle macchine
     */
    public IstitutoService(IstitutoRepository istitutoRepository, MacchinaRepository macchinaRepository) {
        this.istitutoRepository = istitutoRepository;
        this.macchinaRepository = macchinaRepository;
    }

    /**
     * Recupera tutti gli istituti presenti nel sistema.
     * 
     * @return Lista di tutti gli istituti
     * @throws SQLException 
     */
    public List<Istituto> getTuttiIstituti() throws SQLException {
        return istitutoRepository.findAll();
    }

    /**
     * Recupera un istituto specifico tramite il suo ID.
     * 
     * @param id Identificativo dell'istituto
     * @return L'istituto corrispondente all'ID
     */
    public Istituto getIstitutoById(int id) {
        return istitutoRepository.findById(id).orElse(null);
    }

    /**
     * Crea un nuovo istituto nel sistema.
     * 
     * Esegue la validazione dell'istituto prima del salvataggio.
     * 
     * @param istituto Istituto da creare
     * @return L'istituto salvato con il suo nuovo ID
     * @throws IllegalArgumentException Se la validazione fallisce
     */
    public Istituto creaIstituto(Istituto istituto) {
        validaIstituto(istituto);
        return istitutoRepository.save(istituto);
    }

    /**
     * Aggiorna un istituto esistente nel sistema.
     * 
     * Esegue la validazione dell'istituto prima dell'aggiornamento.
     * 
     * @param istituto Istituto da aggiornare
     * @return L'istituto aggiornato
     * @throws IllegalArgumentException Se la validazione fallisce
     */
    public Istituto aggiornaIstituto(Istituto istituto) {
        validaIstituto(istituto);
        return istitutoRepository.update(istituto);
    }

    /**
     * Elimina un istituto dal sistema.
     * 
     * L'eliminazione è consentita solo se non ci sono macchine associate all'istituto.
     * 
     * @param id Identificativo dell'istituto da eliminare
     * @return true se l'eliminazione ha avuto successo, false altrimenti
     * @throws SQLException 
     * @throws IllegalStateException Se l'istituto ha macchine associate
     */
    public boolean eliminaIstituto(int id) throws SQLException {
        List<Macchina> macchine = macchinaRepository.findByIstitutoId(id);
        if (!macchine.isEmpty()) {
            throw new IllegalStateException("Non è possibile eliminare un istituto con macchine associate");
        }
        return istitutoRepository.delete(id);
    }

    /**
     * Assegna una macchina a un istituto.
     * 
     * @param istitutoId Identificativo dell'istituto a cui assegnare la macchina
     * @param macchina Macchina da assegnare
     * @throws IllegalArgumentException Se l'istituto non esiste
     */
    public void assegnaMacchina(int istitutoId, Macchina macchina) {
        Istituto istituto = getIstitutoById(istitutoId);
        if (istituto == null) {
            throw new IllegalArgumentException("Istituto non trovato");
        }
        macchina.setIstitutoId(istitutoId);
        macchinaRepository.save(macchina);
    }

    /**
     * Rimuove una macchina da un istituto.
     * 
     * @param istitutoId Identificativo dell'istituto da cui rimuovere la macchina
     * @param macchinaId Identificativo della macchina da rimuovere
     * @throws IllegalArgumentException Se la macchina non esiste o non è associata all'istituto
     */
    public void rimuoviMacchina(int istitutoId, int macchinaId) {
        Macchina macchina = macchinaRepository.findById(macchinaId);
        if (macchina == null || macchina.getIstitutoId() != istitutoId) {
            throw new IllegalArgumentException("Macchina non trovata o non associata all'istituto");
        }
        macchinaRepository.delete(macchinaId);
    }

    /**
     * Convalida un istituto prima del salvataggio o dell'aggiornamento.
     * 
     * Verifica che il nome e l'indirizzo dell'istituto non siano nulli o vuoti.
     * 
     * @param istituto Istituto da validare
     * @throws IllegalArgumentException Se la validazione fallisce
     */
    private void validaIstituto(Istituto istituto) {
        if (istituto.getNome() == null || istituto.getNome().trim().isEmpty()) {
            throw new IllegalArgumentException("Nome istituto obbligatorio");
        }
        if (istituto.getIndirizzo() == null || istituto.getIndirizzo().trim().isEmpty()) {
            throw new IllegalArgumentException("Indirizzo istituto obbligatorio");
        }
    }
}

================
File: src/main/java/com/vending/core/services/MacchinaService.java
================
package com.vending.core.services;

import com.vending.core.models.*;
import com.vending.core.repositories.*;

import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Servizio per la gestione delle macchine distributrici.
 * Gestisce le operazioni di business logic per il ciclo di vita delle macchine,
 * incluse erogazione di bevande, gestione stati e transazioni finanziarie.
 */
public class MacchinaService {
    private final MacchinaRepository macchinaRepository;
    private final RicavoRepository ricavoRepository;
    private final TransazioneRepository transazioneRepository;

    /**
     * Costruttore del servizio.
     *
     * @param macchinaRepository repository per le macchine
     * @param ricavoRepository repository per i ricavi
     * @param transazioneRepository repository per le transazioni
     */
    public MacchinaService(MacchinaRepository macchinaRepository, 
                          RicavoRepository ricavoRepository,
                          TransazioneRepository transazioneRepository) {
        this.macchinaRepository = macchinaRepository;
        this.ricavoRepository = ricavoRepository;
        this.transazioneRepository = transazioneRepository;
    }

    /**
     * Recupera tutte le macchine nel sistema.
     *
     * @return Lista delle macchine
     */
    public List<Macchina> getTutteMacchine() {
        return macchinaRepository.findAll();
    }

    /**
     * Aggiorna lo stato di una macchina.
     *
     * @param id ID della macchina
     * @param nuovoStatoId nuovo stato da impostare
     * @return macchina aggiornata
     */
    public Macchina aggiornaMacchina(int id, int nuovoStatoId) {
        Macchina macchina = macchinaRepository.findById(id);
        if (macchina == null) {
            throw new IllegalArgumentException("Macchina non trovata: " + id);
        }

        if (!isStatoValido(nuovoStatoId)) {
            throw new IllegalArgumentException("Stato non valido: " + nuovoStatoId);
        }

        // Gestione cambio stato da manutenzione ad attiva
        if (macchina.getStatoId() == 2 && nuovoStatoId == 1) {
            //macchina.setDataUltimaManutenzione(LocalDateTime.now());
        }

        // Svuotamento cassa pre-manutenzione
        if (nuovoStatoId == 2 && macchina.getStatoId() != 2 && 
            macchina.getCassaAttuale() > 0) {
            
            svuotaCassa(macchina.getId());
        }

        macchina.setStatoId(nuovoStatoId);
        return macchinaRepository.update(macchina);
    }

    /**
     * Verifica se uno stato è valido.
     *
     * @param statoId stato da verificare
     * @return true se lo stato è valido
     */
    private boolean isStatoValido(int statoId) {
        return statoId >= 1 && statoId <= 3; // 1=Attiva, 2=In manutenzione, 3=Fuori servizio
    }

    /**
     * Recupera una macchina tramite ID.
     *
     * @param id ID della macchina
     * @return la macchina se trovata, null altrimenti
     */
    public Macchina getMacchinaById(int id) {
        if (id <= 0) {
            throw new IllegalArgumentException("ID non valido");
        }
        return macchinaRepository.findById(id);
    }

    /**
     * Recupera le macchine di un istituto.
     *
     * @param istitutoId ID dell'istituto
     * @return lista delle macchine dell'istituto
     * @throws SQLException 
     */
    public List<Macchina> getMacchineByIstituto(int istitutoId) throws SQLException {
        if (istitutoId <= 0) {
            throw new IllegalArgumentException("ID istituto non valido");
        }
        return macchinaRepository.findByIstitutoId(istitutoId);
    }

    /**
     * Crea una nuova macchina.
     *
     * @param macchina macchina da creare
     * @return macchina creata
     */
    public Macchina creaMacchina(Macchina macchina) {
        validaMacchina(macchina);
        macchina.setStatoId(1); // Attiva
        macchina.setCreditoAttuale(0.0);
        return macchinaRepository.save(macchina);
    }

    /**
     * Aggiorna una macchina esistente.
     *
     * @param macchina macchina da aggiornare
     * @return macchina aggiornata
     */
    public Macchina aggiornaMacchina(Macchina macchina) {
        validaMacchina(macchina);
        return macchinaRepository.update(macchina);
    }

    /**
     * Elimina una macchina.
     *
     * @param id ID della macchina
     * @return true se l'eliminazione ha successo
     */
    public boolean eliminaMacchina(int id) {
        return macchinaRepository.delete(id);
    }

    /**
     * Inserisce denaro nella macchina.
     *
     * @param macchinaId ID della macchina
     * @param importo importo da inserire
     * @return true se l'inserimento ha successo
     */
    public boolean inserisciDenaro(int macchinaId, Double importo) {
        Macchina macchina = getMacchinaById(macchinaId);
        if (macchina == null) {
            throw new IllegalArgumentException("Macchina non trovata");
        }

        if (macchina.getStatoId() != 1) {
            throw new IllegalStateException("Macchina non attiva");
        }

        if (!macchina.puoAccettareDenaro(importo)) {
            return false;
        }

        macchina.setCreditoAttuale(macchina.getCreditoAttuale() + importo);
        macchinaRepository.update(macchina);
        return true;
    }

    /**
     * Eroga una bevanda.
     *
     * @param macchinaId ID della macchina
     * @param bevandaId ID della bevanda
     * @return transazione completata
     */
    public Transazione erogaBevanda(int macchinaId, int bevandaId) {
        Macchina macchina = getMacchinaById(macchinaId);
        if (macchina == null) {
            throw new IllegalArgumentException("Macchina non trovata");
        }

        if (macchina.getStatoId() != 1) {
            throw new IllegalStateException("Macchina non attiva");
        }

        Bevanda bevanda = macchina.getBevande().stream()
                .filter(b -> b.getId() == bevandaId)
                .findFirst()
                .orElse(null);

        if (bevanda == null) {
            throw new IllegalArgumentException("Bevanda non disponibile");
        }

        if (!macchina.hasCreditorSufficiente(bevanda.getPrezzo())) {
            throw new IllegalStateException("Credito insufficiente");
        }

        verificaDisponibilitaCialde(macchina, bevanda);

        // Crea transazione
        Transazione transazione = new Transazione();
        transazione.setMacchinaId(macchinaId);
        transazione.setBevandaId(bevandaId);
        transazione.setImporto(bevanda.getPrezzo());
        transazione.setDataOra(LocalDateTime.now());

        // Aggiorna stato macchina
        macchina.setCreditoAttuale(macchina.getCreditoAttuale() - bevanda.getPrezzo());
        macchina.setCassaAttuale(macchina.getCassaAttuale() + bevanda.getPrezzo());
        decrementaCialde(macchina, bevanda);

        macchinaRepository.update(macchina);
        return transazioneRepository.save(transazione);
    }

    /**
     * Restituisce il credito residuo.
     *
     * @param macchinaId ID della macchina
     * @return importo restituito
     */
    public Double restituisciCredito(int macchinaId) {
        Macchina macchina = getMacchinaById(macchinaId);
        if (macchina == null) {
            throw new IllegalArgumentException("Macchina non trovata");
        }

        Double credito = macchina.getCreditoAttuale();
        macchina.setCreditoAttuale(0.0);
        macchinaRepository.update(macchina);
        return credito;
    }

    /**
     * Svuota la cassa di una macchina.
     *
     * @param macchinaId ID della macchina
     */
    public void svuotaCassa(int macchinaId) {
        Macchina macchina = getMacchinaById(macchinaId);
        if (macchina == null) {
            throw new IllegalArgumentException("Macchina non trovata");
        }

        if (macchina.getCassaAttuale() > 0) {
            Ricavo ricavo = new Ricavo();
            ricavo.setMacchinaId(macchinaId);
            ricavo.setImporto(macchina.getCassaAttuale());
            ricavo.setDataOra(LocalDateTime.now());
            ricavoRepository.save(ricavo);

            macchina.setCassaAttuale(0.0);
            macchinaRepository.update(macchina);
        }
    }

    /**
     * Valida i dati di una macchina.
     */
    private void validaMacchina(Macchina macchina) {
        if (macchina.getIstitutoId() <= 0) {
            throw new IllegalArgumentException("Istituto non valido");
        }
        if (macchina.getCassaMassima() <= 0) {
            throw new IllegalArgumentException("Capacità cassa non valida");
        }
    }

    /**
     * Verifica la disponibilità delle cialde.
     */
    private void verificaDisponibilitaCialde(Macchina macchina, Bevanda bevanda) {
        for (Cialda cialda : bevanda.getCialde()) {
            QuantitaCialde qc = macchina.getCialde().stream()
                    .filter(q -> q.getCialdaId() == cialda.getId())
                    .findFirst()
                    .orElse(null);

            if (qc == null) {
                throw new IllegalStateException("Cialda non disponibile: " + cialda.getNome());
            }

            if (qc.getQuantita() <= 0) {
                throw new IllegalStateException("Cialda esaurita: " + cialda.getNome());
            }
        }
    }

    /**
     * Decrementa le cialde utilizzate.
     */
    private void decrementaCialde(Macchina macchina, Bevanda bevanda) {
        for (Cialda cialda : bevanda.getCialde()) {
            macchina.getCialde().stream()
                    .filter(q -> q.getCialdaId() == cialda.getId())
                    .forEach(QuantitaCialde::decrementaQuantita);
        }
    }
}

================
File: src/main/java/com/vending/core/services/ManutenzioneService.java
================
package com.vending.core.services;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.JsonSyntaxException;
import com.vending.core.models.Macchina;
import com.vending.core.models.Manutenzione;
import com.vending.core.repositories.ManutenzioneRepository;
import com.vending.core.repositories.MacchinaRepository;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Servizio che gestisce la logica di business relativa alle manutenzioni delle macchine distributrici.
 * Gestisce il ciclo di vita delle manutenzioni, dalla segnalazione al completamento,
 * integrando i dati delle macchine e dei tecnici assegnati.
 */
public class ManutenzioneService {
    private final ManutenzioneRepository manutenzioneRepository;
    private final MacchinaRepository macchinaRepository;

    /**
     * Costruisce un nuovo servizio manutenzioni.
     *
     * @param manutenzioneRepository repository per l'accesso ai dati delle manutenzioni
     * @param macchinaRepository repository per l'accesso ai dati delle macchine
     */
    public ManutenzioneService(ManutenzioneRepository manutenzioneRepository, 
                              MacchinaRepository macchinaRepository) {
        this.manutenzioneRepository = manutenzioneRepository;
        this.macchinaRepository = macchinaRepository;
    }

    /**
     * Recupera tutte le manutenzioni attive nel sistema.
     * Una manutenzione è considerata attiva se non ha una data di completamento.
     *
     * @return lista delle manutenzioni attive
     * @throws RuntimeException se si verifica un errore durante il recupero
     */
    public List<Manutenzione> getManutenzioniAttive() {
        try {
            return manutenzioneRepository.findAll().stream()
                    .filter(m -> !m.isCompletata())
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new RuntimeException("Errore nel recupero delle manutenzioni attive", e);
        }
    }

    /**
     * Recupera tutte le manutenzioni di una specifica macchina.
     *
     * @param macchinaId ID della macchina
     * @return lista delle manutenzioni della macchina
     * @throws IllegalArgumentException se la macchina non esiste
     * @throws RuntimeException se si verifica un errore durante il recupero
     */
    public List<Manutenzione> getManutenzioniMacchina(int macchinaId) {
        Macchina macchina = validaMacchina(macchinaId);
        if (macchina == null) {
            throw new IllegalArgumentException("Macchina con id: " + macchinaId + " non trovata");
        }
        return manutenzioneRepository.findByMacchinaId(macchinaId);
    }

    /**
     * Recupera lo stato dettagliato di manutenzione di una macchina.
     *
     * @param macchinaId ID della macchina
     * @return mappa contenente lo stato e le statistiche di manutenzione
     * @throws IllegalArgumentException se la macchina non esiste
     * @throws RuntimeException se si verifica un errore durante il recupero
     */
    public Map<String, Object> getStatoManutenzione(int macchinaId) {
        try {
            Macchina macchina = validaMacchina(macchinaId);
            List<Manutenzione> manutenzioni = manutenzioneRepository.findByMacchinaId(macchinaId);
            
            List<Manutenzione> attive = manutenzioni.stream()
                    .filter(m -> !m.isCompletata())
                    .collect(Collectors.toList());
            
            List<Manutenzione> completate = manutenzioni.stream()
                    .filter(Manutenzione::isCompletata)
                    .collect(Collectors.toList());

            Map<String, Object> stato = new HashMap<>();
            stato.put("statoId", macchina.getStatoId());
            stato.put("statoDescrizione", macchina.getStatoDescrizione());
            stato.put("manutenzioniAttive", attive);
            stato.put("numeroManutenzioniAttive", attive.size());
            
            completate.stream()
                    .max((a, b) -> a.getDataCompletamento().compareTo(b.getDataCompletamento()))
                    .ifPresent(m -> stato.put("ultimaManutenzione", m));

            return stato;
        } catch (IllegalArgumentException e) {
            throw e;
        } catch (Exception e) {
            throw new RuntimeException("Errore nel recupero dello stato manutenzione", e);
        }
    }

    /**
     * Avvia una nuova manutenzione per una macchina.
     *
     * @param macchinaId ID della macchina
     * @param tecnicoId ID del tecnico assegnato
     * @param note note iniziali della manutenzione
     * @return la manutenzione creata
     * @throws IllegalArgumentException se i parametri non sono validi
     * @throws RuntimeException se si verifica un errore durante la creazione
     */
    public Manutenzione avviaManutenzione(int macchinaId, int tecnicoId, String note) {
        try {
            Macchina macchina = validaMacchina(macchinaId);
            
            Manutenzione manutenzione = new Manutenzione(macchinaId, 2); // 2 = In manutenzione
            manutenzione.setTecnicoId(tecnicoId);
            manutenzione.setNote(note);
            manutenzione.setDataRichiesta(LocalDateTime.now());
            
            macchina.setStatoId(2); // In manutenzione
            macchinaRepository.update(macchina);
            
            return manutenzioneRepository.iniziaManutenzione(manutenzione);
        } catch (IllegalArgumentException e) {
            throw e;
        } catch (Exception e) {
            throw new RuntimeException("Errore nell'avvio della manutenzione", e);
        }
    }

    /**
     * Completa una manutenzione esistente.
     *
     * @param manutenzioneId ID della manutenzione
     * @param note note di completamento
     * @return la manutenzione completata
     * @throws IllegalArgumentException se la manutenzione non esiste
     * @throws IllegalStateException se la manutenzione è già completata
     * @throws RuntimeException se si verifica un errore durante il completamento
     */
    public Manutenzione completaManutenzione(int manutenzioneId, String note) {
        try {
            Optional<Manutenzione> optManutenzione = manutenzioneRepository.findById(manutenzioneId);
            if (!optManutenzione.isPresent()) {
                throw new IllegalArgumentException("Manutenzione non trovata: " + manutenzioneId);
            }

            Manutenzione manutenzione = optManutenzione.get();
            if (manutenzione.isCompletata()) {
                throw new IllegalStateException("Manutenzione già completata");
            }

            manutenzione.completaManutenzione(note);
            Manutenzione manutenzioneCompletata = manutenzioneRepository.completaManutenzione(manutenzione);

            // Verifica altre manutenzioni attive
            List<Manutenzione> altreAttive = getManutenzioniMacchina(manutenzione.getMacchinaId())
                    .stream()
                    .filter(m -> !m.isCompletata())
                    .collect(Collectors.toList());

            if (altreAttive.isEmpty()) {
                Macchina macchina = validaMacchina(manutenzione.getMacchinaId());
                macchina.setStatoId(1); // Attiva
                macchinaRepository.update(macchina);
            }

            return manutenzioneCompletata;
        } catch (IllegalArgumentException | IllegalStateException e) {
            throw e;
        } catch (Exception e) {
            throw new RuntimeException("Errore nel completamento della manutenzione", e);
        }
    }

    /**
     * Imposta una macchina come fuori servizio.
     *
     * @param macchinaId ID della macchina
     * @return true se l'operazione ha successo
     * @throws IllegalArgumentException se la macchina non esiste
     * @throws RuntimeException se si verifica un errore durante l'operazione
     */
    public boolean setFuoriServizio(int macchinaId) {
        Macchina macchina = validaMacchina(macchinaId);
        if (macchina == null) {
            throw new IllegalArgumentException("Macchina con id: " + macchinaId + " non trovata");
        }
        return manutenzioneRepository.setFuoriServizio(macchinaId);
    }

    /**
     * Valida l'esistenza di una macchina.
     *
     * @param macchinaId ID della macchina da validare
     * @return la macchina se esiste
     * @throws IllegalArgumentException se la macchina non esiste
     */
    private Macchina validaMacchina(int macchinaId) {
        Macchina macchina = macchinaRepository.findById(macchinaId);
        if (macchina == null) {
            throw new IllegalArgumentException("Macchina non trovata: " + macchinaId);
        }
        return macchina;
    }

    /**
     * Processa i messaggi relativi allo stato di una macchina e avvia le manutenzioni necessarie.
     * Gestisce gli stati: guasto, rifornimento cialde necessario, svuotamento cassa necessario.
     *
     * @param topic topic MQTT del messaggio
     * @param message contenuto del messaggio in formato JSON
     * @throws IllegalArgumentException se il messaggio non è valido
     * @throws RuntimeException se si verifica un errore durante l'elaborazione
     */
    public void processaMacchinaStato(String topic, String message) {
        try {
            // Estrai l'ID della macchina dal topic (formato: macchine/{id}/stato)
            int macchinaId = estraiMacchinaIdDaTopic(topic);
            JsonObject statoMacchina = JsonParser.parseString(message).getAsJsonObject();
            
            // Valida la macchina
            Macchina macchina = validaMacchina(macchinaId);
            
            // Processa i diversi tipi di stato
            if (statoMacchina.has("guasto") && statoMacchina.get("guasto").getAsBoolean()) {
                // Avvia manutenzione per guasto
                gestisciGuasto(macchina, statoMacchina);
            }
            
            if (statoMacchina.has("cialde")) {
                // Verifica necessità rifornimento cialde
                gestisciStatoCialde(macchina, statoMacchina.getAsJsonObject("cialde"));
            }
            
            if (statoMacchina.has("cassa")) {
                // Verifica necessità svuotamento cassa
                gestisciStatoCassa(macchina, statoMacchina.getAsJsonObject("cassa"));
            }
            
        } catch (JsonSyntaxException e) {
            throw new IllegalArgumentException("Formato messaggio non valido: " + e.getMessage());
        } catch (Exception e) {
            throw new RuntimeException("Errore nell'elaborazione dello stato macchina: " + e.getMessage());
        }
    }

    private void gestisciGuasto(Macchina macchina, JsonObject statoMacchina) {
        // Se non ci sono già manutenzioni attive per guasto
        List<Manutenzione> manutenzioniAttive = getManutenzioniMacchina(macchina.getId())
                .stream()
                .filter(m -> !m.isCompletata())
                .collect(Collectors.toList());
                
        if (manutenzioniAttive.isEmpty()) {
            String descrizioneGuasto = statoMacchina.has("descrizioneGuasto") ? 
                    statoMacchina.get("descrizioneGuasto").getAsString() : 
                    "Guasto generico";
                    
            avviaManutenzione(
                macchina.getId(),
                0, // Tecnico da assegnare
                "Guasto rilevato: " + descrizioneGuasto
            );
        }
    }

    private void gestisciStatoCialde(Macchina macchina, JsonObject statoCialde) {
        boolean rifornimentoNecessario = false;
        StringBuilder noteCialde = new StringBuilder("Rifornimento cialde necessario: ");
        
        // Verifica soglie cialde per ogni tipo
        for (Map.Entry<String, JsonElement> entry : statoCialde.entrySet()) {
            JsonObject cialda = entry.getValue().getAsJsonObject();
            int quantita = cialda.get("quantita").getAsInt();
            int soglia = cialda.get("soglia").getAsInt();
            
            if (quantita <= soglia) {
                rifornimentoNecessario = true;
                noteCialde.append(entry.getKey())
                        .append(" (")
                        .append(quantita)
                        .append("/")
                        .append(cialda.get("massimo").getAsInt())
                        .append("), ");
            }
        }
        
        if (rifornimentoNecessario) {
            // Se non ci sono già manutenzioni attive per rifornimento
            List<Manutenzione> manutenzioniAttive = getManutenzioniMacchina(macchina.getId())
                    .stream()
                    .filter(m -> !m.isCompletata())
                    .collect(Collectors.toList());
                    
            if (manutenzioniAttive.isEmpty()) {
                avviaManutenzione(
                    macchina.getId(),
                    0, // Tecnico da assegnare
                    noteCialde.toString().replaceAll(", $", "")
                );
            }
        }
    }

    private void gestisciStatoCassa(Macchina macchina, JsonObject statoCassa) {
        double importoAttuale = statoCassa.get("importo").getAsDouble();
        double importoMassimo = statoCassa.get("massimo").getAsDouble();
        
        // Se la cassa ha raggiunto l'80% della capacità
        if (importoAttuale >= (importoMassimo * 0.8)) {
            // Se non ci sono già manutenzioni attive per svuotamento cassa
            List<Manutenzione> manutenzioniAttive = getManutenzioniMacchina(macchina.getId())
                    .stream()
                    .filter(m -> !m.isCompletata())
                    .collect(Collectors.toList());
                    
            if (manutenzioniAttive.isEmpty()) {
                avviaManutenzione(
                    macchina.getId(),
                    0, // Tecnico da assegnare
                    String.format("Svuotamento cassa necessario: %.2f/%.2f euro", importoAttuale, importoMassimo)
                );
            }
        }
    }

    private int estraiMacchinaIdDaTopic(String topic) {
        try {
            String[] parts = topic.split("/");
            return Integer.parseInt(parts[1]);
        } catch (Exception e) {
            throw new IllegalArgumentException("Topic non valido: " + topic);
        }
    }
    }

================
File: src/main/java/com/vending/core/services/RicavoService.java
================
package com.vending.core.services;

import com.vending.core.models.Ricavo;
import com.vending.core.repositories.RicavoRepository;
import java.time.LocalDateTime;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

/**
 * Servizio che gestisce la logica di business relativa ai ricavi delle macchine distributrici.
 * Si occupa della registrazione, del recupero e dell'analisi dei ricavi generati 
 * dalle macchine installate negli istituti.
 */
public class RicavoService {
    private final RicavoRepository ricavoRepository;

    /**
     * Costruisce un nuovo servizio ricavi.
     *
     * @param ricavoRepository repository per l'accesso ai dati dei ricavi
     */
    public RicavoService(RicavoRepository ricavoRepository) {
        this.ricavoRepository = ricavoRepository;
    }

    /**
     * Recupera tutti i ricavi registrati nel sistema, ordinati per data decrescente.
     *
     * @return lista di tutti i ricavi registrati
     * @throws RuntimeException se si verifica un errore durante il recupero dei dati
     */
    public List<Ricavo> getTuttiRicavi() {
        return ricavoRepository.findAll();
    }

    /**
     * Recupera tutti i ricavi di una specifica macchina.
     *
     * @param macchinaId ID della macchina di cui recuperare i ricavi
     * @return lista dei ricavi della macchina specificata
     * @throws RuntimeException se si verifica un errore durante il recupero dei dati
     */
    public List<Ricavo> getRicaviMacchina(int macchinaId) {
        validaMacchinaId(macchinaId);
        return ricavoRepository.findByMacchinaId(macchinaId);
    }

    /**
     * Calcola il totale dei ricavi di una specifica macchina.
     *
     * @param macchinaId ID della macchina di cui calcolare il totale dei ricavi
     * @return totale dei ricavi della macchina
     * @throws IllegalArgumentException se l'ID della macchina non è valido
     * @throws RuntimeException se si verifica un errore durante il calcolo
     */
    public double getTotaleRicaviMacchina(int macchinaId) {
        validaMacchinaId(macchinaId);
        return ricavoRepository.getTotaleRicaviByMacchina(macchinaId);
    }

    /**
     * Calcola il totale dei ricavi in un determinato periodo di tempo.
     *
     * @param dataInizio data e ora di inizio del periodo
     * @param dataFine data e ora di fine del periodo
     * @return totale dei ricavi nel periodo specificato
     * @throws IllegalArgumentException se le date non sono valide
     * @throws RuntimeException se si verifica un errore durante il calcolo
     */
    public double getTotaleRicaviPeriodo(LocalDateTime dataInizio, LocalDateTime dataFine) {
        validaPeriodo(dataInizio, dataFine);
        return ricavoRepository.getTotaleRicaviPeriodo(dataInizio, dataFine);
    }

    /**
     * Recupera il ricavo giornaliero di un istituto per una data specifica.
     *
     * @param istitutoId ID dell'istituto
     * @param data data per cui recuperare il ricavo
     * @return Optional contenente il ricavo giornaliero se presente
     * @throws IllegalArgumentException se l'ID dell'istituto non è valido
     * @throws RuntimeException se si verifica un errore durante il recupero
     */
    public Optional<Double> getRicavoGiornaliero(int istitutoId, LocalDate data) {
        validaIstitutoId(istitutoId);
        if (data == null) {
            throw new IllegalArgumentException("La data non può essere null");
        }
        return ricavoRepository.findRicavoGiornaliero(istitutoId, data);
    }

    /**
     * Registra un nuovo ricavo per una macchina.
     *
     * @param macchinaId ID della macchina che ha generato il ricavo
     * @param importo importo del ricavo
     * @param notaOperatore nota opzionale dell'operatore
     * @return il ricavo registrato
     * @throws IllegalArgumentException se i parametri non sono validi
     * @throws RuntimeException se si verifica un errore durante il salvataggio
     */
    public Ricavo registraRicavo(int macchinaId, double importo, String notaOperatore) {
        validaRicavo(macchinaId, importo);
        
        Ricavo ricavo = new Ricavo();
        ricavo.setMacchinaId(macchinaId);
        ricavo.setImporto(importo);
        ricavo.setDataOra(LocalDateTime.now());
        
        return ricavoRepository.save(ricavo);
    }

    /**
     * Valida i parametri di un ricavo.
     *
     * @param macchinaId ID della macchina da validare
     * @param importo importo da validare
     * @throws IllegalArgumentException se i parametri non sono validi
     */
    private void validaRicavo(int macchinaId, double importo) {
        validaMacchinaId(macchinaId);
        if (importo <= 0) {
            throw new IllegalArgumentException("L'importo deve essere maggiore di zero");
        }
    }

    /**
     * Valida l'ID di una macchina.
     *
     * @param macchinaId ID della macchina da validare
     * @throws IllegalArgumentException se l'ID non è valido
     */
    private void validaMacchinaId(int macchinaId) {
        if (macchinaId <= 0) {
            throw new IllegalArgumentException("L'ID della macchina deve essere maggiore di zero");
        }
    }

    /**
     * Valida l'ID di un istituto.
     *
     * @param istitutoId ID dell'istituto da validare
     * @throws IllegalArgumentException se l'ID non è valido
     */
    private void validaIstitutoId(int istitutoId) {
        if (istitutoId <= 0) {
            throw new IllegalArgumentException("L'ID dell'istituto deve essere maggiore di zero");
        }
    }

    /**
     * Valida un periodo temporale.
     *
     * @param dataInizio data di inizio del periodo
     * @param dataFine data di fine del periodo
     * @throws IllegalArgumentException se le date non sono valide
     */
    private void validaPeriodo(LocalDateTime dataInizio, LocalDateTime dataFine) {
        if (dataInizio == null || dataFine == null) {
            throw new IllegalArgumentException("Le date non possono essere null");
        }
        if (dataInizio.isAfter(dataFine)) {
            throw new IllegalArgumentException("La data di inizio deve essere precedente alla data di fine");
        }
    }
}

================
File: src/main/java/com/vending/core/services/TransazioneService.java
================
package com.vending.core.services;

import com.vending.core.models.Transazione;
import com.vending.core.repositories.TransazioneRepository;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Servizio che gestisce la logica di business relativa alle transazioni delle macchine distributrici.
 * Si occupa della registrazione e dell'analisi delle vendite di bevande effettuate dalle
 * macchine installate negli istituti.
 */
public class TransazioneService {
    private final TransazioneRepository transazioneRepository;

    /**
     * Costruisce un nuovo servizio transazioni.
     *
     * @param transazioneRepository repository per l'accesso ai dati delle transazioni
     */
    public TransazioneService(TransazioneRepository transazioneRepository) {
        this.transazioneRepository = transazioneRepository;
    }

    /**
     * Recupera tutte le transazioni registrate nel sistema, ordinate per data decrescente.
     *
     * @return lista di tutte le transazioni registrate
     * @throws RuntimeException se si verifica un errore durante il recupero dei dati
     */
    public List<Transazione> getTutteTransazioni() {
        return transazioneRepository.findAll();
    }

    /**
     * Recupera le transazioni recenti (ultime 100) dal sistema.
     * Utilizza la vista 'transazionirecenti' del database.
     *
     * @return lista delle transazioni recenti
     * @throws RuntimeException se si verifica un errore durante il recupero dei dati
     */
    public List<Transazione> getTransazioniRecenti() {
        return transazioneRepository.findTransazioniRecenti();
    }

    /**
     * Recupera una transazione specifica tramite il suo ID.
     *
     * @param id ID della transazione da recuperare
     * @return Optional contenente la transazione se trovata
     * @throws RuntimeException se si verifica un errore durante il recupero
     */
    public Optional<Transazione> getTransazione(int id) {
        return transazioneRepository.findById(id);
    }

    /**
     * Recupera tutte le transazioni di una specifica macchina.
     *
     * @param macchinaId ID della macchina di cui recuperare le transazioni
     * @return lista delle transazioni della macchina specificata
     * @throws IllegalArgumentException se l'ID della macchina non è valido
     * @throws RuntimeException se si verifica un errore durante il recupero
     */
    public List<Transazione> getTransazioniMacchina(int macchinaId) {
        validaMacchinaId(macchinaId);
        return transazioneRepository.findByMacchinaId(macchinaId);
    }

    /**
     * Calcola il totale delle transazioni di una macchina in un determinato periodo.
     *
     * @param macchinaId ID della macchina
     * @param dataInizio data e ora di inizio del periodo
     * @param dataFine data e ora di fine del periodo
     * @return totale delle transazioni nel periodo specificato
     * @throws IllegalArgumentException se i parametri non sono validi
     * @throws RuntimeException se si verifica un errore durante il calcolo
     */
    public double calcolaTotaleMacchina(int macchinaId, LocalDateTime dataInizio, LocalDateTime dataFine) {
        validaMacchinaId(macchinaId);
        validaPeriodo(dataInizio, dataFine);
        return transazioneRepository.calcolaTotaleMacchina(macchinaId, dataInizio, dataFine);
    }

    /**
     * Registra una nuova transazione nel sistema.
     *
     * @param transazione transazione da registrare
     * @return la transazione registrata con ID generato
     * @throws IllegalArgumentException se i dati della transazione non sono validi
     * @throws RuntimeException se si verifica un errore durante il salvataggio
     */
    public Transazione registraTransazione(Transazione transazione) {
        validaTransazione(transazione);
        transazione.setDataOra(LocalDateTime.now());
        return transazioneRepository.save(transazione);
    }

    /**
     * Valida i dati di una transazione.
     *
     * @param transazione transazione da validare
     * @throws IllegalArgumentException se i dati della transazione non sono validi
     */
    private void validaTransazione(Transazione transazione) {
        if (transazione == null) {
            throw new IllegalArgumentException("La transazione non può essere null");
        }
        if (transazione.getMacchinaId() <= 0) {
            throw new IllegalArgumentException("L'ID della macchina deve essere maggiore di zero");
        }
        if (transazione.getBevandaId() <= 0) {
            throw new IllegalArgumentException("L'ID della bevanda deve essere maggiore di zero");
        }
        if (transazione.getImporto() <= 0) {
            throw new IllegalArgumentException("L'importo deve essere maggiore di zero");
        }
    }

    /**
     * Valida l'ID di una macchina.
     *
     * @param macchinaId ID della macchina da validare
     * @throws IllegalArgumentException se l'ID non è valido
     */
    private void validaMacchinaId(int macchinaId) {
        if (macchinaId <= 0) {
            throw new IllegalArgumentException("L'ID della macchina deve essere maggiore di zero");
        }
    }

    /**
     * Valida un periodo temporale.
     *
     * @param dataInizio data di inizio del periodo
     * @param dataFine data di fine del periodo
     * @throws IllegalArgumentException se le date non sono valide
     */
    private void validaPeriodo(LocalDateTime dataInizio, LocalDateTime dataFine) {
        if (dataInizio == null || dataFine == null) {
            throw new IllegalArgumentException("Le date non possono essere null");
        }
        if (dataInizio.isAfter(dataFine)) {
            throw new IllegalArgumentException("La data di inizio deve essere precedente alla data di fine");
        }
    }
}

================
File: src/main/java/com/vending/core/services/UtenteService.java
================
package com.vending.core.services;

import com.vending.core.models.Utente;
import com.vending.core.repositories.UtenteRepository;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Servizio che gestisce la logica di business relativa agli utenti del sistema.
 * Gestisce l'autenticazione, la creazione e la modifica degli account utente,
 * utilizzando la crittografia BCrypt integrata nel modello Utente.
 */
public class UtenteService {
    private final UtenteRepository utenteRepository;

    /**
     * Costruisce un nuovo servizio utenti.
     *
     * @param utenteRepository repository per l'accesso ai dati degli utenti
     */
    public UtenteService(UtenteRepository utenteRepository) {
        this.utenteRepository = utenteRepository;
    }

    /**
     * Autentica un utente tramite username e password.
     * In caso di successo, aggiorna anche la data dell'ultimo accesso.
     *
     * @param username nome utente
     * @param password password in chiaro
     * @return utente autenticato o null se l'autenticazione fallisce
     * @throws RuntimeException se si verifica un errore durante l'autenticazione
     */
    public Utente autenticaUtente(String username, String password) {
        Utente utente = utenteRepository.findByUsername(username);
        if (utente != null && utente.verifyPassword(password)) {
            utente.aggiornaUltimoAccesso();
            return utenteRepository.update(utente);
        }
        return null;
    }

    /**
     * Recupera tutti gli utenti registrati nel sistema.
     *
     * @return lista di tutti gli utenti
     * @throws RuntimeException se si verifica un errore durante il recupero
     */
    public List<Utente> getTuttiUtenti() {
        return utenteRepository.findAll();
    }

    /**
     * Recupera gli utenti con un determinato ruolo.
     *
     * @param ruolo ruolo degli utenti da cercare
     * @return lista degli utenti con il ruolo specificato
     * @throws IllegalArgumentException se il ruolo non è valido
     * @throws RuntimeException se si verifica un errore durante il recupero
     */
    public List<Utente> getUtentiPerRuolo(String ruolo) {
        validaRuolo(ruolo);
        return utenteRepository.findByRuolo(ruolo);
    }

    /**
     * Recupera un utente specifico tramite il suo ID.
     *
     * @param id ID dell'utente da recuperare
     * @return Optional contenente l'utente se trovato
     * @throws RuntimeException se si verifica un errore durante il recupero
     */
    public Optional<Utente> getUtenteById(int id) {
        return utenteRepository.findById(id);
    }

    /**
     * Crea un nuovo utente nel sistema.
     * La password viene automaticamente crittografata dal modello Utente.
     *
     * @param utente utente da creare
     * @return l'utente creato con ID generato
     * @throws IllegalArgumentException se i dati dell'utente non sono validi
     * @throws RuntimeException se si verifica un errore durante il salvataggio
     */
    public Utente creaUtente(Utente utente) {
        validaUtente(utente);
        utente.aggiornaUltimoAccesso();
        return utenteRepository.save(utente);
    }

    /**
     * Aggiorna i dati di un utente esistente.
     * Se viene fornita una nuova password, questa viene crittografata.
     *
     * @param utente utente da aggiornare
     * @return l'utente aggiornato
     * @throws IllegalArgumentException se i dati dell'utente non sono validi
     * @throws RuntimeException se si verifica un errore durante l'aggiornamento
     */
    public Utente aggiornaUtente(Utente utente) {
        validaUtente(utente);
        return utenteRepository.update(utente);
    }

    /**
     * Elimina un utente dal sistema.
     *
     * @param id ID dell'utente da eliminare
     * @return true se l'eliminazione ha successo
     * @throws RuntimeException se si verifica un errore durante l'eliminazione
     */
    public boolean eliminaUtente(int id) {
        return utenteRepository.delete(id);
    }

    /**
     * Valida i dati di un utente.
     *
     * @param utente utente da validare
     * @throws IllegalArgumentException se i dati dell'utente non sono validi
     */
    private void validaUtente(Utente utente) {
        if (utente == null) {
            throw new IllegalArgumentException("L'utente non può essere null");
        }
        if (utente.getNome() == null || utente.getNome().trim().isEmpty()) {
            throw new IllegalArgumentException("Il nome è obbligatorio");
        }
        if (utente.getUsername() == null || utente.getUsername().trim().isEmpty()) {
            throw new IllegalArgumentException("Lo username è obbligatorio");
        }
        if (utente.getPasswordHash() == null && 
            (utente.getId() == 0)) { // Solo per nuovi utenti
            throw new IllegalArgumentException("La password è obbligatoria per i nuovi utenti");
        }
        validaRuolo(utente.getRuolo());
    }

    /**
     * Valida il ruolo di un utente.
     *
     * @param ruolo ruolo da validare
     * @throws IllegalArgumentException se il ruolo non è valido
     */
    private void validaRuolo(String ruolo) {
        if (ruolo == null || ruolo.trim().isEmpty()) {
            throw new IllegalArgumentException("Il ruolo è obbligatorio");
        }
        if (!ruolo.equals("Amministratore") && !ruolo.equals("Tecnico") && !ruolo.equals("Operatore")) {
            throw new IllegalArgumentException("Ruolo non valido. I ruoli ammessi sono: Amministratore, Tecnico, Operatore");
        }
    }
}

================
File: src/main/java/com/vending/iot/bridge/BridgeConfig.java
================
package com.vending.iot.bridge;

public class BridgeConfig {
    private final String brokerLocalUrl;
    private final String brokerCentraleUrl;
    private final String prefissoScuola;

    public BridgeConfig(String brokerLocalUrl, String brokerCentraleUrl, String prefissoScuola) {
        this.brokerLocalUrl = brokerLocalUrl;
        this.brokerCentraleUrl = brokerCentraleUrl;
        this.prefissoScuola = prefissoScuola;
    }

    public String getBrokerLocalUrl() {
        return brokerLocalUrl;
    }

    public String getBrokerCentraleUrl() {
        return brokerCentraleUrl;
    }

    public String getTopicCentrale(String scuolaId, String topicLocale) {
        return prefissoScuola + "/" + scuolaId + "/" + topicLocale;
    }

    public String getTopicLocale(String scuolaId, String topicCentrale) {
        String prefix = prefissoScuola + "/" + scuolaId + "/";
        return topicCentrale.startsWith(prefix) ? topicCentrale.substring(prefix.length()) : topicCentrale;
    }
}

================
File: src/main/java/com/vending/iot/bridge/MQTTBridge.java
================
package com.vending.iot.bridge;

import com.vending.iot.mqtt.MQTTClient;
import org.eclipse.paho.client.mqttv3.MqttException;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

public class MQTTBridge {
    private final String scuolaId;
    private final MQTTClient clientLocale;
    private final MQTTClient clientCentrale;
    private final Set<String> topicDaInoltrare;
    private final BridgeConfig config;

    public MQTTBridge(String scuolaId, BridgeConfig config) throws MqttException {
        this.scuolaId = scuolaId;
        this.config = config;
        this.topicDaInoltrare = ConcurrentHashMap.newKeySet();
        this.clientLocale = new MQTTClient("bridge_locale_" + scuolaId);
        this.clientCentrale = new MQTTClient("bridge_centrale_" + scuolaId);
        
        inizializzaBridge();
    }

    private void inizializzaBridge() throws MqttException {
        // Sottoscrizione ai topic locali
        clientLocale.subscribe("#", (topic, messaggio) -> {
            if (deveEssereInoltrato(topic)) {
                inoltraAlCentrale(topic, messaggio);
            }
        });

        // Sottoscrizione ai topic centrali
        clientCentrale.subscribe("#", (topic, messaggio) -> {
            if (deveEssereInoltrato(topic)) {
                inoltraAlLocale(topic, messaggio);
            }
        });
    }

    public void aggiungiTopicDaInoltrare(String topic) {
        topicDaInoltrare.add(topic);
    }

    public void rimuoviTopicDaInoltrare(String topic) {
        topicDaInoltrare.remove(topic);
    }

    private boolean deveEssereInoltrato(String topic) {
        return topicDaInoltrare.stream()
                .anyMatch(pattern -> topic.matches(pattern.replace("+", "[^/]+").replace("#", ".*")));
    }

    private void inoltraAlCentrale(String topic, String messaggio) {
        try {
            String topicCentrale = config.getTopicCentrale(scuolaId, topic);
            clientCentrale.publish(topicCentrale, messaggio);
        } catch (MqttException e) {
            System.err.println("Errore nell'inoltro al broker centrale: " + e.getMessage());
        }
    }

    private void inoltraAlLocale(String topic, String messaggio) {
        try {
            String topicLocale = config.getTopicLocale(scuolaId, topic);
            clientLocale.publish(topicLocale, messaggio);
        } catch (MqttException e) {
            System.err.println("Errore nell'inoltro al broker locale: " + e.getMessage());
        }
    }

    public void spegni() {
        clientLocale.disconnect();
        clientCentrale.disconnect();
    }
}

================
File: src/main/java/com/vending/iot/bridge/TopicManager.java
================
package com.vending.iot.bridge;

import java.util.HashSet;
import java.util.Set;

public class TopicManager {
    private final Set<String> topicMacchine;
    private final Set<String> topicManutenzione;
    private final Set<String> topicMonitoraggio;

    public TopicManager() {
        this.topicMacchine = new HashSet<>();
        this.topicManutenzione = new HashSet<>();
        this.topicMonitoraggio = new HashSet<>();
        inizializzaTopicPredefiniti();
    }

    private void inizializzaTopicPredefiniti() {
        // Topic macchine
        topicMacchine.add("macchine/+/stato");
        topicMacchine.add("macchine/+/allarmi");
        topicMacchine.add("macchine/+/manutenzione");

        // Topic manutenzione
        topicManutenzione.add("manutenzione/+/richieste");
        topicManutenzione.add("manutenzione/+/interventi");

        // Topic monitoraggio
        topicMonitoraggio.add("monitoraggio/+/statistiche");
        topicMonitoraggio.add("monitoraggio/+/alert");
    }

    public Set<String> getTopicMacchine() {
        return new HashSet<>(topicMacchine);
    }

    public Set<String> getTopicManutenzione() {
        return new HashSet<>(topicManutenzione);
    }

    public Set<String> getTopicMonitoraggio() {
        return new HashSet<>(topicMonitoraggio);
    }

    public void aggiungiTopicMacchina(String topic) {
        topicMacchine.add(topic);
    }

    public void aggiungiTopicManutenzione(String topic) {
        topicManutenzione.add(topic);
    }

    public void aggiungiTopicMonitoraggio(String topic) {
        topicMonitoraggio.add(topic);
    }
}

================
File: src/main/java/com/vending/iot/machines/GestoreBevande.java
================
package com.vending.iot.machines;

import com.google.gson.Gson;
import com.vending.iot.mqtt.MQTTClient;
import com.vending.core.models.Bevanda;
import com.vending.core.models.Cialda;
import com.vending.core.models.QuantitaCialde;
import com.vending.core.repositories.CialdaRepository;

import org.eclipse.paho.client.mqttv3.MqttException;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;

public class GestoreBevande {
    private final int idMacchina;
    private final Map<Integer, Bevanda> bevande;
    private final AtomicBoolean inErogazione;
    private final MQTTClient mqttClient;
    private final Gson gson;
    private final GestoreCassa gestoreCassa;
    private final GestoreCialde gestoreCialde;

    public GestoreBevande(int idMacchina, GestoreCassa gestoreCassa, GestoreCialde gestoreCialde) throws MqttException {
        this.idMacchina = idMacchina;
        this.bevande = new ConcurrentHashMap<>();
        this.inErogazione = new AtomicBoolean(false);
        this.gson = new Gson();
        this.mqttClient = new MQTTClient("bevande_" + idMacchina);
        this.gestoreCassa = gestoreCassa;
        this.gestoreCialde = gestoreCialde;
        
        inizializzaSottoscrizioni();
    }

    private void inizializzaSottoscrizioni() throws MqttException {
        String baseTopic = "macchine/" + idMacchina + "/bevande/";
        mqttClient.subscribe(baseTopic + "#", (topic, messaggio) -> {
            String azione = topic.substring(baseTopic.length());
            switch (azione) {
                case "richiesta":
                    gestisciRichiestaBevanda(gson.fromJson(messaggio, RichiestaBevanda.class));
                    break;
                case "aggiorna":
                    gestisciAggiornamentoBevanda(gson.fromJson(messaggio, AggiornamentoBevanda.class));
                    break;
            }
        });
    }

    public void aggiungiBevanda(Bevanda bevanda) {
        bevande.put(bevanda.getId(), bevanda);
        publishAggiornamentoBevande();
    }

    private void publishAggiornamentoBevande() {
            try {
                String topic = "macchine/" + idMacchina + "/bevande/lista";
                
                // Crea una mappa dettagliata con tutte le informazioni delle bevande
                Map<String, Object> dettagliAggiornamento = new HashMap<>();
                List<Map<String, Object>> listaBevande = new ArrayList<>();

                for (Bevanda bevanda : bevande.values()) {
                    Map<String, Object> infoBevanda = new HashMap<>();
                    try {
                        infoBevanda.put("id", bevanda.getId());
                        infoBevanda.put("nome", bevanda.getNome());
                        infoBevanda.put("prezzo", bevanda.getPrezzo());
                        infoBevanda.put("disponibile", verificaDisponibilitaBevanda(bevanda));
                        
                        // Aggiunge informazioni sulle cialde necessarie
                        List<Map<String, Object>> cialde = new ArrayList<>();
                        for (Cialda cialda : bevanda.getCialde()) {
                            Map<String, Object> infoCialda = new HashMap<>();
                            infoCialda.put("id", cialda.getId());
                            infoCialda.put("tipo", cialda.getTipoCialda());
                            infoCialda.put("quantitaDisponibile", getQuantitaCialdaDisponibile(cialda.getId()));
                            cialde.add(infoCialda);
                        }
                        infoBevanda.put("cialde", cialde);
                        
                        listaBevande.add(infoBevanda);
                    } catch (NullPointerException e) {
                        System.err.println("Errore nell'elaborazione della bevanda ID " + 
                            bevanda.getId() + ": " + e.getMessage());
                        // Continua con la prossima bevanda
                        continue;
                    }
                }

                dettagliAggiornamento.put("bevande", listaBevande);
                dettagliAggiornamento.put("timestamp", System.currentTimeMillis());
                dettagliAggiornamento.put("totaleDisponibili", 
                    listaBevande.stream().filter(b -> (boolean)b.get("disponibile")).count());

                // Verifica se ci sono bevande disponibili
                boolean almeno1BevandaDisponibile = listaBevande.stream()
                    .anyMatch(b -> (boolean)b.get("disponibile"));
                
                if (!almeno1BevandaDisponibile) {
                    // Pubblica un avviso se non ci sono bevande disponibili
                    pubblicaAvvisoNessunaBevandaDisponibile();
                }

                // Pubblica l'aggiornamento
                mqttClient.publish(topic, gson.toJson(dettagliAggiornamento));

                // Log dell'aggiornamento
                System.out.println("Aggiornamento bevande pubblicato con successo: " + 
                    gson.toJson(dettagliAggiornamento));

            } catch (MqttException e) {
                System.err.println("Errore durante la pubblicazione dell'aggiornamento bevande: " + 
                    e.getMessage());
            } catch (Exception e) {
                System.err.println("Errore imprevisto durante l'aggiornamento bevande: " + 
                    e.getMessage());
                e.printStackTrace();
            }
            }

            private boolean verificaDisponibilitaBevanda(Bevanda bevanda) {
            try {
                if (bevanda == null) return false;
                
                // Verifica disponibilita'� di tutte le cialde necessarie
                return bevanda.getCialde().stream()
                    .allMatch(cialda -> getQuantitaCialdaDisponibile(cialda.getId()) > 0);
            } catch (Exception e) {
                System.err.println("Errore verifica disponibilita'� bevanda ID " + 
                    bevanda.getId() + ": " + e.getMessage());
                return false;
            }
            }

            private int getQuantitaCialdaDisponibile(int idCialda) {
            try {
                CialdaRepository cialdaRepository = new CialdaRepository();
                Optional<QuantitaCialde> cialda = cialdaRepository.getQuantitaDisponibileByMacchina(idCialda, idMacchina);
                return cialda != null ? cialda.get().getQuantita() : 0;
            } catch (Exception e) {
                System.err.println("Errore recupero quantita'� cialda ID " + 
                    idCialda + ": " + e.getMessage());
                return 0;
            }
            }

            private void pubblicaAvvisoNessunaBevandaDisponibile() {
            try {
                String topicAvviso = "macchine/" + idMacchina + "/bevande/avviso";
                Map<String, Object> avviso = Map.of(
                    "tipo", "NESSUNA_BEVANDA_DISPONIBILE",
                    "messaggio", "Tutte le bevande sono momentaneamente non disponibili",
                    "timestamp", System.currentTimeMillis()
                );
                mqttClient.publish(topicAvviso, gson.toJson(avviso));
            } catch (MqttException e) {
                System.err.println("Errore pubblicazione avviso bevande non disponibili: " + 
                    e.getMessage());
            }
    }


    private void gestisciRichiestaBevanda(RichiestaBevanda richiesta) {
        if (!inErogazione.compareAndSet(false, true)) {
            pubblicaErrore("Macchina occupata");
            return;
        }

        try {
            Bevanda bevanda = bevande.get(richiesta.idBevanda);
            if (bevanda == null) {
                pubblicaErrore("Bevanda non disponibile");
                return;
            }

            // Verifica disponibilita' cialde
            if (!gestoreCialde.verificaDisponibilitaCialde(bevanda.getCialde())) {
                pubblicaErrore("Cialde non sufficienti");
                return;
            }

            // Verifica pagamento
            if (gestoreCassa.processaPagamento(bevanda.getPrezzo())) {
                // Simulazione erogazione
                pubblicaStato("preparazione");
                Thread.sleep(5000); // Simula tempo di preparazione

                // Consuma le cialde
                gestoreCialde.consumaCialde(bevanda.getCialde());
                
                pubblicaStato("completata");
                registraErogazione(bevanda);
            } else {
                pubblicaErrore("Credito insufficiente");
            }
        } catch (Exception e) {
            pubblicaErrore("Errore durante l'erogazione: " + e.getMessage());
        } finally {
            inErogazione.set(false);
        }
    }

    private void gestisciAggiornamentoBevanda(AggiornamentoBevanda aggiornamento) {
        Bevanda bevanda = bevande.get(aggiornamento.idBevanda);
        if (bevanda != null) {
            bevanda.setPrezzo(aggiornamento.nuovoPrezzo);
            pubblicaAggiornamentoBevande();
        }
    }

    private void pubblicaStato(String stato) {
        try {
            String topic = "macchine/" + idMacchina + "/bevande/stato";
            Map<String, Object> statoErogazione = Map.of(
                "stato", stato,
                "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topic, gson.toJson(statoErogazione));
        } catch (MqttException e) {
            System.err.println("Errore pubblicazione stato: " + e.getMessage());
        }
    }

    private void pubblicaAggiornamentoBevande() {
        try {
            String topic = "macchine/" + idMacchina + "/bevande/lista";
            mqttClient.publish(topic, gson.toJson(bevande));
        } catch (MqttException e) {
            System.err.println("Errore pubblicazione bevande: " + e.getMessage());
        }
    }

    private void pubblicaErrore(String messaggio) {
        try {
            String topic = "macchine/" + idMacchina + "/bevande/errore";
            Map<String, Object> errore = Map.of(
                "messaggio", messaggio,
                "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topic, gson.toJson(errore));
        } catch (MqttException e) {
            System.err.println("Errore pubblicazione errore: " + e.getMessage());
        }
    }

    private void registraErogazione(Bevanda bevanda) {
        try {
            String topic = "macchine/" + idMacchina + "/bevande/erogazione";
            Map<String, Object> erogazione = Map.of(
                "bevandaId", bevanda.getId(),
                "nome", bevanda.getNome(),
                "prezzo", bevanda.getPrezzo(),
                "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topic, gson.toJson(erogazione));
        } catch (MqttException e) {
            System.err.println("Errore registrazione erogazione: " + e.getMessage());
        }
    }

    public Map<String, Object> ottieniStato() {
        List<Map<String, Object>> listaBevande = new ArrayList<>();
        
        for (Bevanda bevanda : bevande.values()) {
            Map<String, Object> infoBevanda = new HashMap<>();
            infoBevanda.put("id", bevanda.getId());
            infoBevanda.put("nome", bevanda.getNome());
            infoBevanda.put("prezzo", bevanda.getPrezzo());
            infoBevanda.put("disponibile", verificaDisponibilitaBevanda(bevanda));
            listaBevande.add(infoBevanda);
        }
     
        Map<String, Object> stato = new HashMap<>();
        stato.put("bevande", listaBevande);
        stato.put("inErogazione", inErogazione.get());
        
        return stato;
     }

    private static class RichiestaBevanda {
        public int idBevanda;
    }

    private static class AggiornamentoBevanda {
        public int idBevanda;
        public double nuovoPrezzo;
    }

    public void spegni() {
        mqttClient.disconnect();
    }
}

================
File: src/main/java/com/vending/iot/machines/GestoreCassa.java
================
package com.vending.iot.machines;

import com.google.gson.Gson;
import com.vending.iot.mqtt.MQTTClient;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.concurrent.atomic.AtomicReference;
import java.util.Map;

/**
 * Classe che rappresenta il gestore della cassa di una macchina distributrice.
 * Gestisce l'inserimento di monete, lo svuotamento della cassa e la restituzione del credito.
 * 
 * Un'operazione atomica è un'operazione che viene eseguita in un singolo passo indivisibile. 
 * Questo significa che, in un contesto multi-thread, nessun thread può osservare uno stato intermedio 
 * durante l'esecuzione dell'operazione. 
 */
public class GestoreCassa {
    private static final Logger logger = LoggerFactory.getLogger(GestoreCassa.class);
    private final int idMacchina;
    private final AtomicReference<Double> creditoAttuale;
    private final AtomicReference<Double> cassaAttuale;
    private final double cassaMassima;
    private final MQTTClient mqttClient;
    private final Gson gson;
    private static final double SOGLIA_AVVISO_CASSA_PIENA = 0.9; // 90%

    /**
     * Costruttore del gestore cassa.
     * 
     * @param idMacchina ID della macchina distributrice
     * @param cassaMassima capacità massima della cassa
     * @throws MqttException se si verificano errori nella connessione MQTT
     */
    public GestoreCassa(int idMacchina, double cassaMassima) throws MqttException {
        if (cassaMassima <= 0) {
            throw new IllegalArgumentException("La capacità massima della cassa deve essere positiva");
        }
        
        this.idMacchina = idMacchina;
        this.cassaMassima = cassaMassima;
        this.creditoAttuale = new AtomicReference<>(0.0);
        this.cassaAttuale = new AtomicReference<>(0.0);
        this.gson = new Gson();
        this.mqttClient = new MQTTClient("cassa_" + idMacchina);
        
        logger.info("Inizializzazione GestoreCassa per macchina {}", idMacchina);
        inizializzaSottoscrizioni();
    }

    /**
     * Imposta il saldo corrente della cassa.
     * Viene utilizzato principalmente per inizializzare o sincronizzare lo stato della cassa.
     *
     * @param nuovoSaldo il nuovo saldo da impostare
     * @throws IllegalArgumentException se il saldo è negativo o supera la capacità massima
     */
    public void impostaSaldoCassa(double nuovoSaldo) {
        if (nuovoSaldo < 0) {
            logger.error("Tentativo di impostare un saldo negativo: {}", nuovoSaldo);
            throw new IllegalArgumentException("Il saldo della cassa non può essere negativo");
        }
        if (nuovoSaldo > cassaMassima) {
            logger.error("Tentativo di impostare un saldo superiore alla capacità massima: {} > {}", 
                        nuovoSaldo, cassaMassima);
            throw new IllegalArgumentException("Il saldo supera la capacità massima della cassa");
        }

        cassaAttuale.set(nuovoSaldo);
        logger.info("Saldo cassa impostato a {} per la macchina {}", nuovoSaldo, idMacchina);
        pubblicaStatoCassa();
        
        // Verifica se necessario pubblicare l'avviso di cassa quasi piena
        if ((nuovoSaldo / cassaMassima) > SOGLIA_AVVISO_CASSA_PIENA) {
            pubblicaAvvisoCassaPiena();
        }
    }

    /**
 * Restituisce lo stato attuale della cassa, inclusi credito, saldo e percentuale di occupazione.
 *
 * @return una mappa contenente: creditoAttuale, cassaAttuale, cassaMassima e percentualeOccupazione
 */
public Map<String, Object> ottieniStato() {
        double saldoAttuale = cassaAttuale.get();
        return Map.of(
            "creditoAttuale", creditoAttuale.get(),
            "cassaAttuale", saldoAttuale,
            "cassaMassima", cassaMassima,
            "percentualeOccupazione", (saldoAttuale / cassaMassima) * 100
        );
    }

    /**
 * Inizializza le sottoscrizioni MQTT per gestire le operazioni della cassa.
 * Gestisce le operazioni di inserimento monete, svuotamento cassa e restituzione credito.
 *
 * @throws MqttException se si verificano errori nella sottoscrizione ai topic MQTT
 */
private void inizializzaSottoscrizioni() throws MqttException {
        String baseTopic = "macchine/" + idMacchina + "/cassa/";
        mqttClient.subscribe(baseTopic + "#", (topic, messaggio) -> {
            logger.debug("Ricevuto messaggio sul topic {}: {}", topic, messaggio);
            String azione = topic.substring(baseTopic.length());
            try {
                switch (azione) {
                    case "inserimento":
                        gestisciInserimentoMoneta(gson.fromJson(messaggio, OperazioneMoneta.class));
                        break;
                    case "svuotamento":
                        gestisciSvuotamentoCassa();
                        break;
                    case "resto":
                        gestisciRestituzioneCredito();
                        break;
                    default:
                        logger.warn("Azione non riconosciuta: {}", azione);
                }
            } catch (Exception e) {
                logger.error("Errore durante l'elaborazione del messaggio", e);
                pubblicaErrore("Errore durante l'elaborazione dell'operazione: " + e.getMessage());
            }
        });
        logger.info("Sottoscrizioni inizializzate per la macchina {}", idMacchina);
    }

    /**
 * Gestisce l'inserimento di una moneta nella cassa.
 * Verifica se l'importo può essere accettato e aggiorna il credito attuale.
 *
 * @param operazione l'operazione di inserimento moneta contenente l'importo
 */
private void gestisciInserimentoMoneta(OperazioneMoneta operazione) {
        logger.debug("Gestione inserimento moneta: {}", operazione.importo);
        if (operazione.importo <= 0) {
            pubblicaErrore("L'importo deve essere positivo");
            return;
        }
        
        if (puoAccettareImporto(operazione.importo)) {
            creditoAttuale.updateAndGet(credito -> credito + operazione.importo);
            logger.info("Credito aggiornato a {} per la macchina {}", creditoAttuale.get(), idMacchina);
            pubblicaStatoCredito();
        } else {
            logger.warn("Impossibile accettare l'importo {} - cassa piena", operazione.importo);
            pubblicaErrore("Impossibile accettare l'importo - cassa piena");
        }
    }

    /**
 * Gestisce l'operazione di svuotamento della cassa.
 * Azzera il saldo attuale e pubblica la conferma dell'operazione.
 */
private void gestisciSvuotamentoCassa() {
        double importoSvuotato = cassaAttuale.getAndSet(0.0);
        logger.info("Svuotamento cassa effettuato: {} per la macchina {}", importoSvuotato, idMacchina);
        pubblicaConfermaSvuotamento(importoSvuotato);
        pubblicaStatoCassa();
    }

    /**
 * Gestisce la restituzione del credito all'utente.
 * Azzera il credito attuale e pubblica la conferma dell'operazione.
 */
private void gestisciRestituzioneCredito() {
        double importoRestituito = creditoAttuale.getAndSet(0.0);
        logger.info("Restituzione credito: {} per la macchina {}", importoRestituito, idMacchina);
        pubblicaRestituzione(importoRestituito);
        pubblicaStatoCredito();
    }

    /**
 * Verifica se la cassa può accettare un determinato importo.
 * Controlla che l'importo non faccia superare la capacità massima della cassa.
 *
 * @param importo l'importo da verificare
 * @return true se l'importo può essere accettato, false altrimenti
 */
private boolean puoAccettareImporto(double importo) {
        return (cassaAttuale.get() + creditoAttuale.get() + importo) <= cassaMassima;
    }

    /**
 * Pubblica lo stato attuale della cassa sul topic MQTT appropriato.
 * Include informazioni su saldo attuale, capacità massima e percentuale di occupazione.
 */
private void pubblicaStatoCassa() {
        try {
            String topic = "macchine/" + idMacchina + "/cassa/stato";
            Map<String, Object> stato = Map.of(
                "cassaAttuale", cassaAttuale.get(),
                "cassaMassima", cassaMassima,
                "percentualeOccupazione", (cassaAttuale.get() / cassaMassima) * 100,
                "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topic, gson.toJson(stato));
        } catch (MqttException e) {
            logger.error("Errore pubblicazione stato cassa", e);
        }
    }

    /**
 * Pubblica lo stato del credito attuale sul topic MQTT appropriato.
 */
private void pubblicaStatoCredito() {
        try {
            String topic = "macchine/" + idMacchina + "/cassa/credito";
            Map<String, Object> stato = Map.of(
                "creditoAttuale", creditoAttuale.get(),
                "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topic, gson.toJson(stato));
        } catch (MqttException e) {
            logger.error("Errore pubblicazione stato credito", e);
        }
    }

    /**
 * Pubblica un avviso quando la cassa supera la soglia di riempimento.
 * L'avviso viene inviato quando la cassa supera il 90% della sua capacità.
 */
private void pubblicaAvvisoCassaPiena() {
        try {
            String topicAvviso = "macchine/" + idMacchina + "/cassa/avviso";
            Map<String, Object> avviso = Map.of(
                "tipo", "CASSA_QUASI_PIENA",
                "messaggio", "La cassa ha superato il 90% della capacità",
                "percentualeOccupazione", (cassaAttuale.get() / cassaMassima) * 100,
                "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topicAvviso, gson.toJson(avviso));
            logger.warn("Avviso cassa quasi piena pubblicato per la macchina {}", idMacchina);
        } catch (MqttException e) {
            logger.error("Errore pubblicazione avviso cassa piena", e);
        }
    }

    /**
 * Pubblica la conferma di svuotamento della cassa con l'importo svuotato.
 *
 * @param importo l'importo che è stato prelevato dalla cassa
 */
private void pubblicaConfermaSvuotamento(double importo) {
        try {
            String topic = "macchine/" + idMacchina + "/cassa/svuotamento/conferma";
            Map<String, Object> conferma = Map.of(
                "importo", importo,
                "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topic, gson.toJson(conferma));
        } catch (MqttException e) {
            logger.error("Errore pubblicazione conferma svuotamento", e);
        }
    }

    /**
 * Pubblica la conferma di restituzione del credito all'utente.
 *
 * @param importo l'importo che è stato restituito all'utente
 */
private void pubblicaRestituzione(double importo) {
        try {
            String topic = "macchine/" + idMacchina + "/cassa/resto/conferma";
            Map<String, Object> resto = Map.of(
                "importo", importo,
                "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topic, gson.toJson(resto));
        } catch (MqttException e) {
            logger.error("Errore pubblicazione restituzione", e);
        }
    }

    /**
 * Pubblica un messaggio di errore sul topic MQTT appropriato.
 *
 * @param messaggio il messaggio di errore da pubblicare
 */
private void pubblicaErrore(String messaggio) {
        try {
            String topic = "macchine/" + idMacchina + "/cassa/errore";
            Map<String, Object> errore = Map.of(
                "messaggio", messaggio,
                "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topic, gson.toJson(errore));
            logger.error("Errore cassa: {}", messaggio);
        } catch (MqttException e) {
            logger.error("Errore pubblicazione errore", e);
        }
    }

    /**
 * Processa un pagamento, verificando la disponibilità del credito e aggiornando i saldi.
 * Se il pagamento va a buon fine, aggiorna sia il credito che la cassa e pubblica gli aggiornamenti.
 *
 * @param prezzo l'importo da addebitare
 * @return true se il pagamento è stato processato con successo, false altrimenti
 */
public boolean processaPagamento(double prezzo) {
        if (prezzo <= 0) {
            logger.error("Tentativo di processare un pagamento con prezzo non valido: {}", prezzo);
            return false;
        }

        if (creditoAttuale.get() >= prezzo) {
            creditoAttuale.updateAndGet(credito -> credito - prezzo);
            cassaAttuale.updateAndGet(cassa -> cassa + prezzo);
            
            try {
                pubblicaStatoCredito();
                pubblicaStatoCassa();
                
                if ((cassaAttuale.get() / cassaMassima) > SOGLIA_AVVISO_CASSA_PIENA) {
                    pubblicaAvvisoCassaPiena();
                }
                
                logger.info("Pagamento processato con successo: {} per la macchina {}", prezzo, idMacchina);
                return true;
            } catch (Exception e) {
                logger.error("Errore durante la pubblicazione degli aggiornamenti del pagamento", e);
                return true; // Il pagamento è comunque avvenuto con successo
            }
        }
        
        logger.warn("Credito insufficiente per il pagamento: {} < {}", creditoAttuale.get(), prezzo);
        return false;
    }

    /**
 * Classe interna che rappresenta un'operazione di inserimento moneta.
 */
private static class OperazioneMoneta {
        public double importo;
    }

    /**
 * Spegne il gestore cassa, disconnettendo il client MQTT.
 * Da chiamare quando la macchina viene spenta o riavviata.
 */
public void spegni() {
        try {
            mqttClient.disconnect();
            logger.info("GestoreCassa spento per la macchina {}", idMacchina);
        } catch (Exception e) {
            logger.error("Errore durante lo spegnimento del GestoreCassa", e);
        }
    }
}

================
File: src/main/java/com/vending/iot/machines/GestoreCialde.java
================
package com.vending.iot.machines;

import com.google.gson.Gson;
import com.vending.iot.mqtt.MQTTClient;
import com.vending.core.models.Cialda;
import org.eclipse.paho.client.mqttv3.MqttException;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

public class GestoreCialde {
    private final int idMacchina;
    private final Map<Integer, InfoCialda> cialde;
    private final MQTTClient mqttClient;
    private final Gson gson;
    private static final double SOGLIA_RICARICA = 0.2; // 20%

    public GestoreCialde(int idMacchina) throws MqttException {
        this.idMacchina = idMacchina;
        this.cialde = new ConcurrentHashMap<>();
        this.gson = new Gson();
        this.mqttClient = new MQTTClient("cialde_" + idMacchina);
        
        inizializzaSottoscrizioni();
    }

    private void inizializzaSottoscrizioni() throws MqttException {
        String baseTopic = "macchine/" + idMacchina + "/cialde/";
        mqttClient.subscribe(baseTopic + "#", (topic, messaggio) -> {
            String azione = topic.substring(baseTopic.length());
            switch (azione) {
                case "ricarica":
                    gestisciRicaricaCialde(gson.fromJson(messaggio, RichiestaCialde.class));
                    break;
                case "verifica":
                    verificaStatoCialde();
                    break;
            }
        });
    }

    public void inizializzaCialda(int idCialda, int quantita, int quantitaMassima) {
        cialde.put(idCialda, new InfoCialda(quantita, quantitaMassima));
        pubblicaStatoCialde();
    }

    public boolean verificaDisponibilitaCialde(List<Cialda> cialdeNecessarie) {
        return cialdeNecessarie.stream()
                .allMatch(cialda -> {
                    InfoCialda info = cialde.get(cialda.getId());
                    return info != null && info.quantitaAttuale > 0;
                });
    }

    public void consumaCialde(List<Cialda> cialdeUsate) {
        cialdeUsate.forEach(cialda -> {
            InfoCialda info = cialde.get(cialda.getId());
            if (info != null) {
                info.decrementaQuantita();
                if (info.necessitaRicarica()) {
                    pubblicaAvvisoRicarica(cialda.getId());
                }
            }
        });
        pubblicaStatoCialde();
    }

    private void gestisciRicaricaCialde(RichiestaCialde richiesta) {
        InfoCialda info = cialde.get(richiesta.idCialda);
        if (info != null) {
            info.ricarica();
            pubblicaStatoCialde();
            pubblicaConfermaRicarica(richiesta.idCialda);
        }
    }

    private void verificaStatoCialde() {
        cialde.forEach((id, info) -> {
            if (info.necessitaRicarica()) {
                pubblicaAvvisoRicarica(id);
            }
        });
        pubblicaStatoCialde();
    }

    

    private void pubblicaStatoCialde() {
        try {
            String topic = "macchine/" + idMacchina + "/cialde/stato";
            Map<String, Object> stato = new ConcurrentHashMap<>();
            cialde.forEach((id, info) -> stato.put(String.valueOf(id), info.toMap()));
            mqttClient.publish(topic, gson.toJson(stato));
        } catch (MqttException e) {
            System.err.println("Errore pubblicazione stato cialde: " + e.getMessage());
        }
    }

    private void pubblicaAvvisoRicarica(int idCialda) {
        try {
            String topic = "macchine/" + idMacchina + "/cialde/avviso";
            Map<String, Object> avviso = Map.of(
                "idCialda", idCialda,
                "tipo", "ricarica_necessaria",
                "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topic, gson.toJson(avviso));
        } catch (MqttException e) {
            System.err.println("Errore pubblicazione avviso ricarica: " + e.getMessage());
        }
    }

    private void pubblicaConfermaRicarica(int idCialda) {
        try {
            String topic = "macchine/" + idMacchina + "/cialde/ricarica/conferma";
            Map<String, Object> conferma = Map.of(
                "idCialda", idCialda,
                "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topic, gson.toJson(conferma));
        } catch (MqttException e) {
            System.err.println("Errore pubblicazione conferma ricarica: " + e.getMessage());
        }
    }

    private static class InfoCialda {
        private int quantitaAttuale;
        private final int quantitaMassima;

        public InfoCialda(int quantitaAttuale, int quantitaMassima) {
            this.quantitaAttuale = quantitaAttuale;
            this.quantitaMassima = quantitaMassima;
        }

        public void decrementaQuantita() {
            if (quantitaAttuale > 0) quantitaAttuale--;
        }

        public void ricarica() {
            quantitaAttuale = quantitaMassima;
        }

        public boolean necessitaRicarica() {
            return quantitaAttuale < (quantitaMassima * SOGLIA_RICARICA);
        }

        public Map<String, Object> toMap() {
            return Map.of(
                "quantitaAttuale", quantitaAttuale,
                "quantitaMassima", quantitaMassima,
                "percentuale", (double) quantitaAttuale / quantitaMassima * 100,
                "necessitaRicarica", necessitaRicarica()
            );
        }
    }

    private static class RichiestaCialde {
        public int idCialda;
    }

    public Map<String, Object> ottieniStato() {
        Map<String, Object> statoCialde = new HashMap<>();
        cialde.forEach((id, info) -> 
            statoCialde.put(String.valueOf(id), Map.of(
                "quantitaAttuale", info.quantitaAttuale,
                "quantitaMassima", info.quantitaMassima,
                "necessitaRicarica", info.quantitaAttuale < info.quantitaMassima * 0.2
            ))
        );
        return statoCialde;
        }

    public void spegni() {
        mqttClient.disconnect();
    }
}

================
File: src/main/java/com/vending/iot/machines/GestoreManutenzione.java
================
package com.vending.iot.machines;

import com.google.gson.Gson;
import com.vending.iot.mqtt.MQTTClient;
import org.eclipse.paho.client.mqttv3.MqttException;
import java.util.Map;
import java.util.HashMap;

public class GestoreManutenzione {
   private final int idMacchina;
   private final MQTTClient mqttClient;
   private final Map<String, String> problemiAttivi; // Cambiato in Map<String, String>
   private final Gson gson;

   public GestoreManutenzione(int idMacchina) throws MqttException {
       this.idMacchina = idMacchina;
       this.problemiAttivi = new HashMap<>();
       this.gson = new Gson();
       this.mqttClient = new MQTTClient("manutenzione_" + idMacchina);
       inizializzaSottoscrizioni();
   }

   private void inizializzaSottoscrizioni() throws MqttException {
       String baseTopic = "macchine/" + idMacchina + "/manutenzione/";
       mqttClient.subscribe(baseTopic + "#", (topic, messaggio) -> {
           String azione = topic.substring(baseTopic.length());
           switch (azione) {
               case "segnalazione":
                   gestisciSegnalazione(gson.fromJson(messaggio, SegnalazioneProblema.class));
                   break;
               case "risoluzione":
                   gestisciRisoluzione(gson.fromJson(messaggio, RisoluzioneProblema.class));
                   break;
               case "verifica":
                   verificaStato();
                   break;
           }
       });
   }

   public void segnalaProblema(String tipo, String descrizione, Map<String, Object> dettagliAggiuntivi) {
       try {
           SegnalazioneProblema segnalazione = new SegnalazioneProblema();
           segnalazione.tipo = tipo;
           segnalazione.descrizione = descrizione;
           segnalazione.dettagli = dettagliAggiuntivi;
           
           String topic = "macchine/" + idMacchina + "/manutenzione/segnalazione";
           mqttClient.publish(topic, gson.toJson(segnalazione));

           String descProblema = "Problema " + segnalazione.tipo + ": " + segnalazione.descrizione;
           problemiAttivi.put(String.valueOf(segnalazione.timestamp),descProblema);
           pubblicaStatoManutenzione();

       } catch (MqttException e) {
           System.err.println("Errore durante la segnalazione del problema: " + e.getMessage());
       }
   }

    private static class SegnalazioneProblema {
        String tipo;
        String descrizione;
        Map<String, Object> dettagli;
        long timestamp;

        public SegnalazioneProblema() {
            this.timestamp = System.currentTimeMillis();
        }
    }



   public void risolviProblema(String idProblema, String descrizioneRisoluzione, String tecnico) {
       try {
           RisoluzioneProblema risoluzione = new RisoluzioneProblema();
           risoluzione.idProblema = idProblema;
           risoluzione.descrizioneRisoluzione = descrizioneRisoluzione;
           risoluzione.tecnico = tecnico;
           risoluzione.timestampRisoluzione = System.currentTimeMillis();
           
           String topic = "macchine/" + idMacchina + "/manutenzione/risoluzione";
           String infoRisoluzione = risoluzione.timestampRisoluzione + ": Il problema " + risoluzione.idProblema + "e' stato risolto da  " + risoluzione.tecnico + " - " + risoluzione.descrizioneRisoluzione;
           mqttClient.publish(topic, gson.toJson(risoluzione));

           problemiAttivi.remove(idProblema);
           pubblicaStatoManutenzione();
       } catch (MqttException e) {
           System.err.println("Errore durante la risoluzione del problema: " + e.getMessage());
       }
   }

    private static class RisoluzioneProblema {
        String idProblema;
        String descrizioneRisoluzione;
        String tecnico;
        long timestampRisoluzione;

    }

   private void gestisciSegnalazione(SegnalazioneProblema segnalazione) {
       problemiAttivi.put(String.valueOf(segnalazione.timestamp), segnalazione.descrizione);
       pubblicaStatoManutenzione();
   }

   private void gestisciRisoluzione(RisoluzioneProblema risoluzione) {
       problemiAttivi.remove(risoluzione.idProblema);
       pubblicaStatoManutenzione();
   }

   public Map<String, Object> getStatoManutenzione() {
       return Map.of(
           "problemiAttivi", problemiAttivi,
           "ultimoControllo", System.currentTimeMillis(),
           "richiedeIntervento", !problemiAttivi.isEmpty(),
           "numeroProblemi", problemiAttivi.size()
       );
   }

   private void pubblicaStatoManutenzione() {
       try {
           String topic = "macchine/" + idMacchina + "/manutenzione/stato";
           Map<String, Object> stato = getStatoManutenzione();
           mqttClient.publish(topic, gson.toJson(stato));

           if ((boolean) stato.get("richiedeIntervento")) {
               String topicAvviso = "macchine/" + idMacchina + "/manutenzione/avviso";
               Map<String, Object> avviso = Map.of(
                   "tipo", "RICHIESTA_INTERVENTO",
                   "numeroProblemi", stato.get("numeroProblemi"),
                   "ultimoControllo", stato.get("ultimoControllo"),
                   "timestamp", System.currentTimeMillis()
               );
               mqttClient.publish(topicAvviso, gson.toJson(avviso));
           }
       } catch (MqttException e) {
           System.err.println("Errore durante la pubblicazione dello stato: " + e.getMessage());
       }
   }

   public void verificaStato() {
       boolean interventoUrgente = !problemiAttivi.isEmpty();

       if (interventoUrgente) {
           try {
               String topic = "macchine/" + idMacchina + "/manutenzione/urgente";
               Map<String, Object> avviso = Map.of(
                   "tipo", "INTERVENTO_URGENTE",
                   "timestamp", System.currentTimeMillis(),
                   "problemi", problemiAttivi
               );
               mqttClient.publish(topic, gson.toJson(avviso));
           } catch (MqttException e) {
               System.err.println("Errore durante la pubblicazione dell'avviso urgente: " + e.getMessage());
           }
       }
   }

   public Map<String, Object> ottieniStato() {
        return Map.of(
            "problemiAttivi", problemiAttivi,
            "ultimoControllo", System.currentTimeMillis(),
            "richiedeIntervento", !problemiAttivi.isEmpty(),
            "numeroProblemi", problemiAttivi.size()
        );
    }

   public void spegni() {
       mqttClient.disconnect();
   }
}

================
File: src/main/java/com/vending/iot/machines/MacchinaPrincipale.java
================
package com.vending.iot.machines;

import com.vending.core.models.Macchina;
import com.vending.iot.mqtt.MQTTClient;
import org.eclipse.paho.client.mqttv3.MqttException;
import com.google.gson.Gson;
import java.util.Map;

public class MacchinaPrincipale {
    private final int id;
    private final GestoreCassa gestoreCassa;
    private final GestoreBevande gestoreBevande;
    private final GestoreCialde gestoreCialde;
    private final GestoreManutenzione gestoreManutenzione;
    private final MQTTClient clientMqtt;
    private final Gson gson;

    public MacchinaPrincipale(Macchina macchina) throws MqttException {
        this.id = macchina.getId();
        this.gson = new Gson();
        this.clientMqtt = new MQTTClient("macchina_" + id);
        this.gestoreCassa = new GestoreCassa(id, macchina.getCassaMassima());
        this.gestoreCialde = new GestoreCialde(id);
        this.gestoreBevande = new GestoreBevande(id, gestoreCassa, gestoreCialde);
        this.gestoreManutenzione = new GestoreManutenzione(id);
        
        inizializzaMacchina(macchina);
        configuraSottoscrizioni();
    }

    private void inizializzaMacchina(Macchina macchina) {
        // Inizializza cialde
        macchina.getCialde().forEach(cialda -> 
            gestoreCialde.inizializzaCialda(
                cialda.getCialdaId(), 
                cialda.getQuantita(), 
                cialda.getQuantitaMassima()
            )
        );

        // Inizializza bevande
        macchina.getBevande().forEach(gestoreBevande::aggiungiBevanda);

        // Imposta stato cassa
        gestoreCassa.impostaSaldoCassa(macchina.getCassaAttuale());

        // Pubblica stato iniziale
        pubblicaStatoMacchina();
    }

    private void configuraSottoscrizioni() throws MqttException {
        String topicBase = "macchine/" + id + "/";
        
        // Sottoscrizione a comandi generali
        clientMqtt.subscribe(topicBase + "comandi/#", (topic, messaggio) -> {
            String comando = topic.substring(topicBase.length() + 8);
            switch (comando) {
                case "spegnimento":
                    eseguiSpegnimento();
                    break;
                case "riavvio":
                    eseguiRiavvio();
                    break;
                case "stato":
                    pubblicaStatoMacchina();
                    break;
            }
        });
    }

    public void eseguiSpegnimento() {
        try {
            pubblicaEvento("spegnimento", "Spegnimento macchina in corso");
            gestoreCassa.spegni();
            gestoreBevande.spegni();
            gestoreCialde.spegni();
            gestoreManutenzione.spegni();
            clientMqtt.disconnect();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void eseguiRiavvio() {
        try {
            pubblicaEvento("riavvio", "Riavvio macchina in corso");
            eseguiSpegnimento();
            // Simula riavvio
            Thread.sleep(5000);
            inizializzaMacchina(new Macchina()); // Ricarica stato da DB
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void pubblicaStatoMacchina() {
        try {
            Map<String, Object> stato = Map.of(
                "id", id,
                "statoCassa", gestoreCassa.ottieniStato(),
                "statoBevande", gestoreBevande.ottieniStato(),
                "statoCialde", gestoreCialde.ottieniStato(),
                "statoManutenzione", gestoreManutenzione.ottieniStato()
            );
            
            clientMqtt.publish(
                "macchine/" + id + "/stato",
                gson.toJson(stato)
            );
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void pubblicaEvento(String tipo, String messaggio) {
        try {
            Map<String, Object> evento = Map.of(
                "tipo", tipo,
                "messaggio", messaggio,
                "timestamp", System.currentTimeMillis()
            );
            
            clientMqtt.publish(
                "macchine/" + id + "/eventi",
                gson.toJson(evento)
            );
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

================
File: src/main/java/com/vending/iot/monitor/AlertManager.java
================
package com.vending.iot.monitor;

import com.google.gson.Gson;
import com.vending.iot.mqtt.MQTTClient;
import org.eclipse.paho.client.mqttv3.MqttException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Map;

public class AlertManager {
    private final MQTTClient mqttClient;
    private final Gson gson;
    private final Map<String, Integer> contatoreFallimenti;

    public AlertManager(MQTTClient mqttClient) {
        this.mqttClient = mqttClient;
        this.gson = new Gson();
        this.contatoreFallimenti = new ConcurrentHashMap<>();
    }

    public void inviaAlert(int macchinaId, String tipo, String messaggio, int severita) {
        try {
            Alert alert = new Alert(macchinaId, tipo, messaggio, severita);
            String topic = "monitoraggio/alert/" + macchinaId;
            mqttClient.publish(topic, gson.toJson(alert));
            
            // Reset contatore fallimenti per questa macchina
            contatoreFallimenti.remove(String.valueOf(macchinaId));
            
            // Se severità alta, invia anche notifica di manutenzione
            if (severita == 3) {
                inviaNotificaManutenzione(macchinaId, messaggio);
            }
            
        } catch (MqttException e) {
            gestisciFallimentoInvio(macchinaId);
        }
    }

    private void inviaNotificaManutenzione(int macchinaId, String messaggio) {
        try {
            Map<String, Object> notifica = Map.of(
                "macchinaId", macchinaId,
                "messaggio", messaggio,
                "timestamp", System.currentTimeMillis(),
                "urgente", true
            );
            mqttClient.publish("manutenzione/richieste/" + macchinaId, gson.toJson(notifica));
        } catch (MqttException e) {
            System.err.println("Errore nell'invio notifica manutenzione: " + e.getMessage());
        }
    }

    private void gestisciFallimentoInvio(int macchinaId) {
        String key = String.valueOf(macchinaId);
        int contatore = contatoreFallimenti.getOrDefault(key, 0) + 1;
        contatoreFallimenti.put(key, contatore);
        
        if (contatore >= 3) {
            System.err.println("Errore critico: impossibile inviare alert per la macchina " + macchinaId);
            // Qui potrebbe essere implementata una logica di fallback
        }
    }

    private static class Alert {
        private final int macchinaId;
        private final String tipo;
        private final String messaggio;
        private final int severita;
        private final long timestamp;

        public Alert(int macchinaId, String tipo, String messaggio, int severita) {
            this.macchinaId = macchinaId;
            this.tipo = tipo;
            this.messaggio = messaggio;
            this.severita = severita;
            this.timestamp = System.currentTimeMillis();
        }
    }
}

================
File: src/main/java/com/vending/iot/monitor/Allarme.java
================
package com.vending.iot.monitor;

import java.time.LocalDateTime;

public class Allarme {
    private String tipo;
    private String messaggio;
    private int severita;  // 1: bassa, 2: media, 3: alta
    private LocalDateTime timestamp;

    public Allarme(String tipo, String messaggio, int severita) {
        this.tipo = tipo;
        this.messaggio = messaggio;
        this.severita = severita;
        this.timestamp = LocalDateTime.now();
    }

    // Getters
    public String getTipo() { return tipo; }
    public String getMessaggio() { return messaggio; }
    public int getSeverita() { return severita; }
    public LocalDateTime getTimestamp() { return timestamp; }
}

================
File: src/main/java/com/vending/iot/monitor/MonitorMacchine.java
================
package com.vending.iot.monitor;

import com.google.gson.Gson;
import com.vending.iot.mqtt.MQTTClient;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.eclipse.paho.client.mqttv3.MqttException;

public class MonitorMacchine {
    private final Map<Integer, StatoMacchina> statiMacchine;
    private final MQTTClient mqttClient;
    private final AlertManager alertManager;
    private final Gson gson;

    public MonitorMacchine() throws MqttException {
        this.statiMacchine = new ConcurrentHashMap<>();
        this.mqttClient = new MQTTClient("monitor_macchine");
        this.alertManager = new AlertManager(mqttClient);
        this.gson = new Gson();
        
        inizializzaMonitoraggio();
    }

    private void inizializzaMonitoraggio() throws MqttException {
        // Sottoscrizione agli stati delle macchine
        mqttClient.subscribe("macchine/+/stato", (topic, messaggio) -> {
            int macchinaId = estraiIdMacchina(topic);
            StatoMacchina stato = gson.fromJson(messaggio, StatoMacchina.class);
            aggiornaStatoMacchina(macchinaId, stato);
        });

        // Sottoscrizione agli allarmi
        mqttClient.subscribe("macchine/+/allarmi", (topic, messaggio) -> {
            int macchinaId = estraiIdMacchina(topic);
            Allarme allarme = gson.fromJson(messaggio, Allarme.class);
            gestisciAllarme(macchinaId, allarme);
        });
    }

    private int estraiIdMacchina(String topic) {
        String[] parts = topic.split("/");
        return Integer.parseInt(parts[1]);
    }

    private void aggiornaStatoMacchina(int macchinaId, StatoMacchina stato) {
        StatoMacchina statoPrec = statiMacchine.put(macchinaId, stato);
        
        // Verifica cambiamenti significativi
        if (statoPrec != null) {
            verificaCambiamenti(macchinaId, statoPrec, stato);
        }

        // Pubblica aggiornamento
        pubblicaStatoAggiornato(macchinaId, stato);
    }

    private void verificaCambiamenti(int macchinaId, StatoMacchina statoPrec, StatoMacchina statoNuovo) {
        // Verifica livello cialde
        if (statoNuovo.getLivelloCialde() < (statoNuovo.getCialdeMassime() * 0.2)) {
            alertManager.inviaAlert(
                macchinaId,
                "CIALDE_BASSE",
                "Livello cialde sotto il 20%",
                2
            );
        }

        // Verifica cassa
        if (statoNuovo.getLivelloCassa() > (statoNuovo.getCassaMassima() * 0.9)) {
            alertManager.inviaAlert(
                macchinaId,
                "CASSA_PIENA",
                "Livello cassa sopra il 90%",
                2
            );
        }

        // Verifica cambio stato
        if (!statoPrec.getStato().equals(statoNuovo.getStato())) {
            alertManager.inviaAlert(
                macchinaId,
                "CAMBIO_STATO",
                "Cambio stato da " + statoPrec.getStato() + " a " + statoNuovo.getStato(),
                1
            );
        }
    }

    private void gestisciAllarme(int macchinaId, Allarme allarme) {
        // Aggiorna stato macchina con allarme
        StatoMacchina stato = statiMacchine.get(macchinaId);
        if (stato != null) {
            stato.aggiungiAllarme(allarme);
            statiMacchine.put(macchinaId, stato);
        }

        // Invia alert appropriato
        alertManager.inviaAlert(
            macchinaId,
            allarme.getTipo(),
            allarme.getMessaggio(),
            allarme.getSeverita()
        );
    }

    private void pubblicaStatoAggiornato(int macchinaId, StatoMacchina stato) {
        try {
            String topic = "monitoraggio/macchine/" + macchinaId + "/stato";
            mqttClient.pubblicaConRitenzione(topic, gson.toJson(stato));
        } catch (MqttException e) {
            System.err.println("Errore nella pubblicazione dello stato: " + e.getMessage());
        }
    }

    public Map<Integer, StatoMacchina> getStatiMacchine() {
        return new ConcurrentHashMap<>(statiMacchine);
    }

    public StatoMacchina getStatoMacchina(int macchinaId) {
        return statiMacchine.get(macchinaId);
    }

    public void spegni() {
        mqttClient.disconnect();
    }
}

================
File: src/main/java/com/vending/iot/monitor/StatoMacchina.java
================
package com.vending.iot.monitor;

import java.util.ArrayList;
import java.util.List;
import java.time.LocalDateTime;

public class StatoMacchina {
    private String stato;
    private double livelloCassa;
    private double cassaMassima;
    private int livelloCialde;
    private int cialdeMassime;
    private double creditoAttuale;
    private List<Allarme> allarmi;
    private LocalDateTime ultimoAggiornamento;
    private boolean richiedeManutenzione;
    private String ultimaManutenzione;

    public StatoMacchina() {
        this.allarmi = new ArrayList<>();
        this.ultimoAggiornamento = LocalDateTime.now();
    }

    // Getters e Setters
    public String getStato() { return stato; }
    public void setStato(String stato) { this.stato = stato; }

    public double getLivelloCassa() { return livelloCassa; }
    public void setLivelloCassa(double livelloCassa) { this.livelloCassa = livelloCassa; }

    public double getCassaMassima() { return cassaMassima; }
    public void setCassaMassima(double cassaMassima) { this.cassaMassima = cassaMassima; }

    public int getLivelloCialde() { return livelloCialde; }
    public void setLivelloCialde(int livelloCialde) { this.livelloCialde = livelloCialde; }

    public int getCialdeMassime() { return cialdeMassime; }
    public void setCialdeMassime(int cialdeMassime) { this.cialdeMassime = cialdeMassime; }

    public double getCreditoAttuale() { return creditoAttuale; }
    public void setCreditoAttuale(double creditoAttuale) { this.creditoAttuale = creditoAttuale; }

    public List<Allarme> getAllarmi() { return new ArrayList<>(allarmi); }

    public LocalDateTime getUltimoAggiornamento() { return ultimoAggiornamento; }
    public void aggiornaTimestamp() { this.ultimoAggiornamento = LocalDateTime.now(); }

    public void aggiungiAllarme(Allarme allarme) {
        this.allarmi.add(allarme);
        this.richiedeManutenzione = true;
    }

    public void risolviAllarmi() {
        this.allarmi.clear();
        this.richiedeManutenzione = false;
    }

    public boolean isRichiedeManutenzione() { return richiedeManutenzione; }
    
    public String getUltimaManutenzione() { return ultimaManutenzione; }
    public void setUltimaManutenzione(String ultimaManutenzione) { 
        this.ultimaManutenzione = ultimaManutenzione; 
    }
}

================
File: src/main/java/com/vending/iot/mqtt/MessageHandler.java
================
package com.vending.iot.mqtt;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import java.util.function.Consumer;

public class MessageHandler {
    private final Gson gson;

    public MessageHandler() {
        this.gson = new Gson();
    }

    public <T> void gestisciMessaggio(String payload, Class<T> tipo, Consumer<T> handler) {
        try {
            T oggetto = gson.fromJson(payload, tipo);
            handler.accept(oggetto);
        } catch (JsonSyntaxException e) {
            System.err.println("Errore nella deserializzazione del messaggio: " + e.getMessage());
        } catch (Exception e) {
            System.err.println("Errore nella gestione del messaggio: " + e.getMessage());
        }
    }

    public String creaMessaggio(Object oggetto) {
        try {
            return gson.toJson(oggetto);
        } catch (Exception e) {
            System.err.println("Errore nella serializzazione del messaggio: " + e.getMessage());
            return "{}";
        }
    }

    public static class MessaggioStato {
        public String stato;
        public long timestamp;

        public MessaggioStato(String stato) {
            this.stato = stato;
            this.timestamp = System.currentTimeMillis();
        }
    }

    public static class MessaggioErrore {
        public String codice;
        public String descrizione;
        public long timestamp;

        public MessaggioErrore(String codice, String descrizione) {
            this.codice = codice;
            this.descrizione = descrizione;
            this.timestamp = System.currentTimeMillis();
        }
    }

    public static class MessaggioAllarme {
        public String tipo;
        public String messaggio;
        public int livelloSeverita;
        public long timestamp;

        public MessaggioAllarme(String tipo, String messaggio, int livelloSeverita) {
            this.tipo = tipo;
            this.messaggio = messaggio;
            this.livelloSeverita = livelloSeverita;
            this.timestamp = System.currentTimeMillis();
        }
    }
}

================
File: src/main/java/com/vending/iot/mqtt/MQTTClient.java
================
package com.vending.iot.mqtt;

import org.eclipse.paho.client.mqttv3.*;
import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Map;
import java.util.Properties;
import java.util.function.BiConsumer;

public class MQTTClient {
    private final MqttClient client;
    private final String clientId;
    private final Map<String, BiConsumer<String, String>> topicHandlers;
    private volatile boolean isConnecting;
    private int retryCount;

    public MQTTClient(String prefix) throws MqttException {
        this.clientId = MQTTConfig.CLIENT_ID_PREFIX + prefix + "_" + UUID.randomUUID().toString();
        this.client = new MqttClient(MQTTConfig.BROKER_URL, clientId, new MemoryPersistence());
        this.topicHandlers = new ConcurrentHashMap<>();
        this.retryCount = 0;
        this.isConnecting = false;
        inizializzaClient();
    }

    private void inizializzaClient() throws MqttException {
    	MqttConnectOptions options = new MqttConnectOptions();
        
        // Configurazione base
    	options.setCleanSession(true);
        options.setAutomaticReconnect(false);
        options.setConnectionTimeout(MQTTConfig.CONNECTION_TIMEOUT);
        options.setKeepAliveInterval(MQTTConfig.KEEP_ALIVE_INTERVAL);
        
        // Configurazione autenticazione
        options.setUserName(MQTTConfig.USERNAME);
        options.setPassword(MQTTConfig.PASSWORD.toCharArray());
        
	     // Configurazione SSL
	        try {
	            System.setProperty("javax.net.ssl.trustStore", MQTTConfig.TRUSTSTORE_PATH);
	            System.setProperty("javax.net.ssl.trustStorePassword", MQTTConfig.TRUSTSTORE_PASSWORD);
	            System.setProperty("javax.net.ssl.trustStoreType", MQTTConfig.TRUSTSTORE_TYPE);
	            
	            Properties sslProperties = new Properties();
	            sslProperties.setProperty("com.ibm.ssl.protocol", "TLSv1.2");
	            options.setSSLProperties(sslProperties);
	        } catch (Exception e) {
	            throw new MqttException(new RuntimeException("Errore nella configurazione SSL", e));
	        }

        client.setCallback(new MqttCallback() {
        	 @Override
        	 public void connectionLost(Throwable cause) {
                 System.err.println("Connessione persa per il client " + clientId);
                 System.err.println("Causa: " + (cause != null ? cause.getMessage() : "sconosciuta"));
                 scheduleReconnect();
             }

            @Override
            public void messageArrived(String topic, MqttMessage message) {
                String payload = new String(message.getPayload());
                BiConsumer<String, String> handler = topicHandlers.get(topic);
                if (handler != null) {
                    handler.accept(topic, payload);
                }
            }

            @Override
            public void deliveryComplete(IMqttDeliveryToken token) {
                // Gestione completamento consegna se necessario
            }
        });

        connetti(options);
    }
    
    private void scheduleReconnect() {
        if (!isConnecting && retryCount < MQTTConfig.MAX_RETRY_ATTEMPTS) {
            new Thread(() -> {
                try {
                    Thread.sleep(MQTTConfig.RETRY_INTERVAL);
                    tentaRiconnessione();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        }
    }

    public synchronized void connetti(MqttConnectOptions options) throws MqttException {
    	if (isConnecting) {
            return;
        }
        try {
        	isConnecting = true;
        	if (!client.isConnected()) {
                client.connect(options);
                System.out.println("Client " + clientId + " connesso con successo");
                retryCount = 0;
                
                // Ricrea le sottoscrizioni dopo la riconnessione
                for (String topic : topicHandlers.keySet()) {
                    client.subscribe(topic, MQTTConfig.QOS);
                }
            }
        } finally {
            isConnecting = false;
        }
    }

    private void tentaRiconnessione() {
    	 if (!client.isConnected() && retryCount < MQTTConfig.MAX_RETRY_ATTEMPTS) {
             retryCount++;
             System.out.println("Tentativo di riconnessione " + retryCount + " per il client " + clientId);
             try {
                 MqttConnectOptions options = new MqttConnectOptions();
                 options.setCleanSession(true);
                 options.setAutomaticReconnect(false);
                 options.setUserName(MQTTConfig.USERNAME);
                 options.setPassword(MQTTConfig.PASSWORD.toCharArray());
                 connetti(options);
             } catch (MqttException e) {
                 System.err.println("Riconnessione fallita per il client " + clientId);
                 scheduleReconnect();
             }
         }
     }

    public void subscribe(String topic, BiConsumer<String, String> handler) throws MqttException {
        client.subscribe(topic, MQTTConfig.QOS);
        topicHandlers.put(topic, handler);
        System.out.println("Client " + clientId + " sottoscritto al topic: " + topic);
    }

    public void publish(String topic, String message) throws MqttException {
        MqttMessage mqttMessage = new MqttMessage(message.getBytes());
        mqttMessage.setQos(MQTTConfig.QOS);
        client.publish(topic, mqttMessage);
    }

    public void pubblicaConRitenzione(String topic, String message) throws MqttException {
        MqttMessage mqttMessage = new MqttMessage(message.getBytes());
        mqttMessage.setQos(MQTTConfig.QOS);
        mqttMessage.setRetained(true);
        client.publish(topic, mqttMessage);
    }

    public void rimuoviSottoscrizione(String topic) throws MqttException {
        client.unsubscribe(topic);
        topicHandlers.remove(topic);
    }

    public void disconnect() {
        try {
            if (client.isConnected()) {
                client.disconnect();
            }
            client.close();
            System.out.println("Client " + clientId + " disconnesso con successo");
        } catch (MqttException e) {
            System.err.println("Errore durante la disconnessione del client " + clientId);
        }
    }

    public boolean isConnesso() {
        return client.isConnected();
    }
}

================
File: src/main/java/com/vending/iot/mqtt/MQTTConfig.java
================
package com.vending.iot.mqtt;

public class MQTTConfig {
	// Configurazione broker
    public static final String BROKER_URL = "ssl://localhost:8883";
    public static final String CLIENT_ID_PREFIX = "pissir_";
    public static final String USERNAME = "20019309";
    public static final String PASSWORD = "Pissir2024!";
    public static final int QOS = 1;
    
    // Configurazione SSL
    public static final String TRUSTSTORE_PATH = "C:\\Program Files\\mosquitto\\certs\\mosquitto.jks";
    public static final String TRUSTSTORE_PASSWORD = "mosquitto";
    public static final String TRUSTSTORE_TYPE = "JKS";
    
    // Timeout e retry
    public static final int CONNECTION_TIMEOUT = 10;
    public static final int KEEP_ALIVE_INTERVAL = 30;
    public static final int MAX_RETRY_ATTEMPTS = 3;
    public static final int RETRY_INTERVAL = 5000;
    
    // Topic base per la comunicazione
    public static final String TOPIC_BASE = "distributori/";
    
    // Topic per le macchine
    public static final String TOPIC_MACCHINE = TOPIC_BASE + "macchine/";
    public static final String TOPIC_STATO = TOPIC_BASE + "/stato";
    public static final String TOPIC_CREDITO = "/credito";
    public static final String TOPIC_EROGAZIONE = "/erogazione";
    public static final String TOPIC_MANUTENZIONE = "/manutenzione";
    public static final String TOPIC_CIALDE = "/cialde";
    public static final String TOPIC_CASSA = "/cassa";
    
    // Topic per il monitoraggio
    public static final String TOPIC_MONITORAGGIO = TOPIC_BASE + "monitoraggio/";
    public static final String TOPIC_ALLARMI = TOPIC_MONITORAGGIO + "allarmi/";
    public static final String TOPIC_STATISTICHE = TOPIC_MONITORAGGIO + "statistiche/";
    
    
    
}

================
File: src/main/java/com/vending/Main.java
================
package com.vending;

import com.google.gson.Gson;

import static spark.Spark.*;

import com.vending.api.controllers.*;
import com.vending.api.middleware.AuthMiddleware;
import com.vending.api.middleware.CORSMiddleware;
import com.vending.api.routes.Routes;
import com.vending.core.services.*;
import com.vending.iot.machines.MacchinaPrincipale;
import com.vending.iot.mqtt.MQTTClient;
import com.vending.security.auth.AuthenticationService;
import com.vending.security.auth.PasswordService;
import com.vending.security.jwt.JWTService;
import com.vending.utils.config.ConfigUtil;

import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;

import javax.net.ssl.SSLSocketFactory;

import com.vending.core.models.Cialda;
import com.vending.core.models.Macchina;
import com.vending.core.repositories.BevandaRepository;
import com.vending.core.repositories.CialdaRepository;
import com.vending.core.repositories.IstitutoRepository;
import com.vending.core.repositories.MacchinaRepository;
import com.vending.core.repositories.ManutenzioneRepository;
import com.vending.core.repositories.RicavoRepository;
import com.vending.core.repositories.TransazioneRepository;
import com.vending.core.repositories.UtenteRepository;

/**
 * Classe principale che avvia l'applicazione del sistema di gestione distributori automatici.
 */
public class Main {
    private static final Logger logger = LoggerFactory.getLogger(Main.class);
    private static final Gson gson = new Gson();
    private static Properties config;
    private static MQTTClient mqttClient;
    
    private static final Map<Integer, MacchinaPrincipale> macchineAttive = new ConcurrentHashMap<>();

    public static void main(String[] args) {
        try {
            // Carica la configurazione
            initConfig();

            // Inizializza i servizi
            initServices();

            // Configura Spark
            configureServer();

            // Inizializza MQTT
            initMQTT();

            // Inizializza le macchine
            initMacchine();

            // Configura i controller e le route
            setupRoutes();

            logger.info("Applicazione avviata con successo sulla porta {}", config.getProperty("server.port"));
            
            // Apri il browser con la dashboard
            openDashboard(config.getProperty("server.port", "8080"));

        } catch (Exception e) {
            logger.error("Errore durante l'avvio dell'applicazione", e);
            System.exit(1);
        }
    }

    private static void initConfig() throws Exception {
        config = ConfigUtil.loadProperties("config.properties");
        
        // Imposta la porta del server
        port(Integer.parseInt(config.getProperty("server.port", "8080")));
        
        // Imposta il timeout delle sessioni
        int maxThreads = Integer.parseInt(config.getProperty("server.maxThreads", "100"));
        int minThreads = Integer.parseInt(config.getProperty("server.minThreads", "2"));
        int timeOutMillis = Integer.parseInt(config.getProperty("server.timeOutMillis", "30000"));
        threadPool(maxThreads, minThreads, timeOutMillis);
    }

    private static void initServices() {
    	// Inizializza i repository
        CialdaRepository cialdaRepository = new CialdaRepository();
        BevandaRepository bevandaRepository = new BevandaRepository(cialdaRepository);
        UtenteRepository utenteRepository = new UtenteRepository();
        MacchinaRepository macchinaRepository = new MacchinaRepository();
        ManutenzioneRepository manutenzioneRepository = new ManutenzioneRepository();
        RicavoRepository ricavoRepository = new RicavoRepository();
        TransazioneRepository transazioneRepository = new TransazioneRepository();
        IstitutoRepository istitutoRepository = new IstitutoRepository(macchinaRepository);
        
        // Registra i repository nel ServiceRegistry
        ServiceRegistry.register("istitutoRepository", istitutoRepository);
        ServiceRegistry.register("macchinaRepository", macchinaRepository);
        ServiceRegistry.register("manutenzioneRepository", manutenzioneRepository);
        
        // Inizializza i servizi
        JWTService jwtService = new JWTService();
        BevandaService bevandaService = new BevandaService(bevandaRepository, cialdaRepository);
        UtenteService utenteService = new UtenteService(utenteRepository);
        ManutenzioneService manutenzioneService = new ManutenzioneService(manutenzioneRepository, macchinaRepository);
        RicavoService ricavoService = new RicavoService(ricavoRepository);
        TransazioneService transazioneService = new TransazioneService(transazioneRepository);
        IstitutoService istitutoService = new IstitutoService(istitutoRepository, macchinaRepository);
        MacchinaService macchinaService = new MacchinaService(macchinaRepository, ricavoRepository, transazioneRepository);

        // Registra i servizi
        ServiceRegistry.register("jwtService", jwtService);
        ServiceRegistry.register("authService", new AuthenticationService(utenteRepository, new PasswordService(), jwtService));
        ServiceRegistry.register("bevandaService", bevandaService);
        ServiceRegistry.register("utenteService", utenteService);
        ServiceRegistry.register("macchinaService", macchinaService);
        ServiceRegistry.register("istitutoService", istitutoService);
        ServiceRegistry.register("manutenzioneService", manutenzioneService);
        ServiceRegistry.register("ricavoService", ricavoService);
        ServiceRegistry.register("transazioneService", transazioneService);
    }

    private static void configureServer() {
        // Configura la cartella dei file statici
        staticFiles.location("/public");
        
        // Route per le pagine HTML
        get("/pages/client/machineSelection.html", (req, res) -> {
            res.type("text/html");
            return new java.io.File("src/main/resources/public/pages/client/machineSelection.html");
        });

        // Inizializza il middleware CORS per le richieste HTTP
        CORSMiddleware corsMiddleware = new CORSMiddleware();

        // Applica CORS a tutte le richieste 
        before((request, response) -> corsMiddleware.applicaCORS(request, response));
        
        // Gestisce le richieste OPTIONS per il CORS
        options("/*", (request, response) -> {
            corsMiddleware.applicaCORS(request, response);
            return "OK";
        });

        // Configurazione sicurezza
        AuthController authController = new AuthController(
                ServiceRegistry.get(UtenteService.class)
            );
        before("/api/*", authController::verificaToken);

        // Configurazione parser JSON
        after((request, response) -> {
            response.type("application/json");
        });

        // Gestione errori
        exception(Exception.class, (e, request, response) -> {
            logger.error("Errore non gestito", e);
            response.status(500);
            response.body(gson.toJson(new ErrorResponse("Errore interno del server")));
        });

        notFound((request, response) -> {
            response.type("application/json");
            return gson.toJson(new ErrorResponse("Risorsa non trovata"));
        });
    }

    private static void initMQTT() throws Exception {
        // Configurazione delle opzioni di connessione MQTT
        MqttConnectOptions options = new MqttConnectOptions();
        options.setCleanSession(true);
        options.setConnectionTimeout(30);
        options.setKeepAliveInterval(60);
        options.setAutomaticReconnect(true);
        options.setUserName(config.getProperty("mqtt.client.username"));
        options.setPassword(config.getProperty("mqtt.client.password").toCharArray());

        // Configurazione SSL se necessario
        if (Boolean.parseBoolean(config.getProperty("mqtt.ssl.enabled", "true"))) {
            options.setSocketFactory(SSLSocketFactory.getDefault());
        }

        // Configurazione Last Will and Testament (LWT)
        options.setWill("system/server/status", "offline".getBytes(), 1, true);

        mqttClient = new MQTTClient("server");
        mqttClient.connetti(options);

        // Sottoscrizione ai topic di sistema
        mqttClient.subscribe("macchine/+/stato", (topic, message) -> {
            // Gestione messaggi di stato
            logger.debug("Ricevuto messaggio stato: {} - {}", topic, message);
            ServiceRegistry.get(ManutenzioneService.class)
                         .processaMacchinaStato(topic, message);
            // Estrai l'ID della macchina dal topic
            String[] parts = topic.split("/");
            if (parts.length >= 2) {
                try {
                    int macchinaId = Integer.parseInt(parts[1]);
                    MacchinaPrincipale macchina = macchineAttive.get(macchinaId);
                    if (macchina != null) {
                        // Aggiorna lo stato della macchina
                        macchina.pubblicaStatoMacchina();
                    }
                } catch (NumberFormatException e) {
                    logger.error("ID macchina non valido nel topic: {}", topic);
                }
            }
        });


        logger.info("Client MQTT inizializzato e connesso");
    }

    private static void initMacchine() {
        try {
            MacchinaRepository macchinaRepo = new MacchinaRepository();
            var macchine = macchinaRepo.findAll();
            
            for (Macchina macchina : macchine) {
                try {
                    MacchinaPrincipale macchinaPrincipale = new MacchinaPrincipale(macchina);
                    macchineAttive.put(macchina.getId(), macchinaPrincipale);
                    logger.info("Macchina {} inizializzata con successo", macchina.getId());
                } catch (Exception e) {
                    logger.error("Errore nell'inizializzazione della macchina {}: {}", 
                        macchina.getId(), e.getMessage());
                }
            }
            
            logger.info("Inizializzate {} macchine", macchineAttive.size());
        } catch (Exception e) {
            logger.error("Errore durante l'inizializzazione delle macchine", e);
        }
    }


    private static void setupRoutes() throws MqttException {
    	
    	 // Aggiungi una route per la home
        get("/", (req, res) -> {
            res.redirect("/index.html");
            return null;
        });

        // Aggiungi una route per le pagine client
        get("/pages/client/*", (req, res) -> {
            return new java.io.File("src/main/resources/public" + req.pathInfo());
        });
        
        // Inizializzazione dei controller
        IstitutoController istitutoController = new IstitutoController(
            ServiceRegistry.get(IstitutoRepository.class),
            ServiceRegistry.get(MacchinaRepository.class)
        );
        
        MacchinaController macchinaController = new MacchinaController(
            ServiceRegistry.get(MacchinaRepository.class)
        );
     
        AuthController authController = new AuthController(
            ServiceRegistry.get(UtenteService.class)
        );
        
        ManutenzioneController manutenzioneController = new ManutenzioneController(
            ServiceRegistry.get(ManutenzioneRepository.class)
        );
        
        BevandaController bevandaController = new BevandaController(
                ServiceRegistry.get(BevandaService.class)
        );
        // Autenticazione e gestione utenti
        path("/api/auth", () -> {
            post("/login", authController::login);
            post("/refresh", authController::refreshToken);
            post("/registrazione", authController::registrazione);
        });

        Routes R = new Routes(istitutoController, macchinaController, bevandaController, manutenzioneController);
        if( R != null) {
            logger.info("Routes configurate con successo");
        }
        
    //     // Gestione istituti
    //     path("/api/istituti", () -> {
    //         get("", istitutoController::getAll);
    //         post("", istitutoController::create);
            
    //         path("/:id", () -> {
    //             get("", istitutoController::getById);
    //             delete("", istitutoController::delete);
    //         });
    //     });

    //     // Gestione macchine distributrici
    //     path("/api/macchine", () -> {
    //         get("", macchinaController::getAll);
    //         post("", macchinaController::create);
            
    //         path("/:id", () -> {
    //             get("", macchinaController::getById);
    //             delete("", macchinaController::delete);
                
    //             // Gestione stato e manutenzione
    //             post("/manutenzione", macchinaController::updateStato);
    //         });
    //     });

    //     /* Utenti routes
    //     get("/api/utenti", utenteController::getAllUtenti);
    //     post("/api/utenti", utenteController::createUtente);
    //     get("/api/utenti/:id", utenteController::getUtente);
    //     delete("/api/utenti/:id", utenteController::deleteUtente);*/

    //    // Routes per la gestione delle manutenzioni
    //     path("/api/manutenzione", () -> {
    //         // Recupera tutte le manutenzioni in corso
    //         get("/", manutenzioneController::getManutenzioni);
            
    //         // Gestione manutenzioni per istituto
    //         get("/istituti/:istitutoId", manutenzioneController::getManutenzioniIstituto);
            
    //         // Gestione manutenzioni per tecnico
    //         get("/tecnici/:tecnicoId", manutenzioneController::getManutenzioniTecnico);
            
    //         // Gestione singola macchina
    //         path("/macchine/:id", () -> {
    //             // Imposta macchina fuori servizio
    //             put("/fuori-servizio", manutenzioneController::setFuoriServizio);
                
    //             // Avvia nuova manutenzione
    //             post("/manutenzioni", manutenzioneController::iniziaManutenzione);
                
    //             // Completa una manutenzione esistente
    //             put("/manutenzioni/:id/completa", manutenzioneController::completaManutenzione);
    //         });
    //     });

    //     // Gestione bevande
    //     path("/api/bevande", () -> {
    //         get("", bevandaController::getAll);
    //         post("", bevandaController::create);
            
    //         path("/:id", () -> {
    //             get("", bevandaController::getById);
    //             put("", bevandaController::update);
    //             delete("", bevandaController::delete);
    //         });
    //     });

        //TOPIC MQTT

        // Configurazione MQTT per lo stato delle macchine
        mqttClient.subscribe("macchine/+/stato", (topic, message) -> {
            ServiceRegistry.get(ManutenzioneService.class).processaMacchinaStato(topic, message);
        });

        // Topic MQTT specifici per ogni tipo di stato
        mqttClient.subscribe("macchine/+/guasti", (topic, message) -> {
            // Il formato del topic è: macchine/{id}/guasti
            ServiceRegistry.get(ManutenzioneService.class).processaMacchinaStato(topic, message);
        });

        mqttClient.subscribe("macchine/+/cialde", (topic, message) -> {
            // Il formato del topic è: macchine/{id}/cialde
            ServiceRegistry.get(ManutenzioneService.class).processaMacchinaStato(topic, message);
        });

        mqttClient.subscribe("macchine/+/cassa", (topic, message) -> {
            // Il formato del topic è: macchine/{id}/cassa
            ServiceRegistry.get(ManutenzioneService.class).processaMacchinaStato(topic, message);
        });
        
    }

    /**
     * Apre il browser predefinito del sistema con la dashboard dell'applicazione.
     * 
     * @param port la porta su cui � in ascolto il server
     */
    private static void openDashboard(String port) {
        try {
            // Attendi 1.5 secondi per assicurarsi che il server sia completamente avviato
            Thread.sleep(1500);
            
            String url = "http://localhost:" + port + "/index.html";
            String os = System.getProperty("os.name").toLowerCase();
            
            // Apri il browser in base al sistema operativo
            if (os.contains("win")) {
                // Windows
                Runtime.getRuntime().exec("rundll32 url.dll,FileProtocolHandler " + url);
            } else if (os.contains("mac")) {
                // macOS
                Runtime.getRuntime().exec("open " + url);
            } else if (os.contains("nix") || os.contains("nux")) {
                // Linux
                String[] browsers = {"google-chrome", "firefox", "mozilla", "epiphany", "konqueror", "netscape", "opera", "links", "lynx"};
                
                StringBuffer cmd = new StringBuffer();
                for (int i = 0; i < browsers.length; i++) {
                    if (i == 0) {
                        cmd.append(String.format("%s \"%s\"", browsers[i], url));
                    } else {
                        cmd.append(String.format(" || %s \"%s\"", browsers[i], url));
                    }
                }
                
                Runtime.getRuntime().exec(new String[] {"sh", "-c", cmd.toString()});
            }
            
            logger.info("Dashboard aperta nel browser: {}", url);
        } catch (Exception e) {
            logger.error("Impossibile aprire il browser automaticamente", e);
            logger.info("Per accedere alla dashboard, apri manualmente: http://localhost:{}/dashboard.html", port);
        }
    }

    private static class ErrorResponse {
        private final String message;

        public ErrorResponse(String message) {
            this.message = message;
        }
    }

    // Metodo per lo spegnimento ordinato del sistema
    public static void shutdown() {
        logger.info("Avvio procedura di spegnimento...");
        
        // Spegni tutte le macchine attive
        macchineAttive.values().forEach(macchina -> {
            try {
                macchina.eseguiSpegnimento();
            } catch (Exception e) {
                logger.error("Errore durante lo spegnimento della macchina", e);
            }
        });
        
        // Pulisci la mappa delle macchine
        macchineAttive.clear();
        
        // Disconnetti il client MQTT
        try {
            if (mqttClient != null) {
                mqttClient.disconnect();
            }
        } catch (Exception e) {
            logger.error("Errore durante la disconnessione del client MQTT", e);
        }
        
        logger.info("Spegnimento completato");
    }
}

================
File: src/main/java/com/vending/MainV1.java
================
package com.vending;

import static spark.Spark.*;
import com.google.gson.Gson;
import com.vending.api.controllers.*;
import com.vending.api.middleware.*;
import com.vending.core.services.*;
import com.vending.iot.machines.GestoreCassa;
import com.vending.iot.machines.GestoreCialde;
import com.vending.iot.machines.MacchinaPrincipale;
import com.vending.iot.mqtt.MQTTClient;
import com.vending.security.auth.*;
import com.vending.security.jwt.JWTService;
import com.vending.utils.config.ConfigUtil;
import com.vending.core.models.*;
import com.vending.core.repositories.*;

import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import javax.net.ssl.SSLSocketFactory;

public class MainV1 {

    private static final Logger logger = LoggerFactory.getLogger(Main.class);
    private static final Gson gson = new Gson();
    private static Properties config;
    private static MQTTClient mqttClient;
    private static final Map<Integer, MacchinaPrincipale> macchineAttive = new ConcurrentHashMap<>();

    public static void main(String[] args) {
        try {
            // Carica la configurazione
            initConfig();

            // Inizializza i servizi
            initServices();

            // Configura il server Spark
            configureServer();

            // Inizializza MQTT
            initMQTT();

            // Inizializza le macchine
            initMacchine();

            // Configura i controller e le route
            setupRoutes();

            logger.info("Applicazione avviata con successo sulla porta {}", config.getProperty("server.port"));

            // Apri il browser con la dashboard
            openDashboard(config.getProperty("server.port", "8080"));

        } catch (Exception e) {
            logger.error("Errore durante l'avvio dell'applicazione", e);
            System.exit(1);
        }
    }

    private static void initConfig() throws Exception {
        // Carica il file di configurazione
        config = ConfigUtil.loadProperties("config.properties");

        // Imposta la porta del server
        port(Integer.parseInt(config.getProperty("server.port", "8080")));

        // Configurazione thread pool
        int maxThreads = Integer.parseInt(config.getProperty("server.maxThreads", "100"));
        int minThreads = Integer.parseInt(config.getProperty("server.minThreads", "2"));
        int timeOutMillis = Integer.parseInt(config.getProperty("server.timeOutMillis", "30000"));
        threadPool(maxThreads, minThreads, timeOutMillis);
    }

    private static void initServices() {
        // Inizializza i repository
        CialdaRepository cialdaRepository = new CialdaRepository();
        BevandaRepository bevandaRepository = new BevandaRepository(cialdaRepository);
        UtenteRepository utenteRepository = new UtenteRepository();
        MacchinaRepository macchinaRepository = new MacchinaRepository();
        ManutenzioneRepository manutenzioneRepository = new ManutenzioneRepository();
        RicavoRepository ricavoRepository = new RicavoRepository();
        TransazioneRepository transazioneRepository = new TransazioneRepository();
        IstitutoRepository istitutoRepository = new IstitutoRepository(macchinaRepository);
        AdminLoginRepository adminLoginRepository = new AdminLoginRepository(utenteRepository);

        // Registra i repository nel ServiceRegistry
        ServiceRegistry.register("cialdaRepository", cialdaRepository);
        ServiceRegistry.register("bevandaRepository", bevandaRepository);
        ServiceRegistry.register("utenteRepository", utenteRepository);
        ServiceRegistry.register("macchinaRepository", macchinaRepository);
        ServiceRegistry.register("manutenzioneRepository", manutenzioneRepository);
        ServiceRegistry.register("ricavoRepository", ricavoRepository);
        ServiceRegistry.register("transazioneRepository", transazioneRepository);
        ServiceRegistry.register("istitutoRepository", istitutoRepository);
        ServiceRegistry.register("adminLoginRepository", adminLoginRepository);

        // Inizializza i servizi
        JWTService jwtService = new JWTService();
        PasswordService passwordService = new PasswordService();
        AuthenticationService authService = new AuthenticationService(utenteRepository, passwordService, jwtService);
        BevandaService bevandaService = new BevandaService(bevandaRepository, cialdaRepository);
        UtenteService utenteService = new UtenteService(utenteRepository);
        MacchinaService macchinaService = new MacchinaService(macchinaRepository, ricavoRepository, transazioneRepository);
        IstitutoService istitutoService = new IstitutoService(istitutoRepository, macchinaRepository);
        ManutenzioneService manutenzioneService = new ManutenzioneService(manutenzioneRepository, macchinaRepository);
        RicavoService ricavoService = new RicavoService(ricavoRepository);
        TransazioneService transazioneService = new TransazioneService(transazioneRepository);
        MacchinaController macchinaController = new MacchinaController(macchinaRepository, bevandaRepository);
        PublicController publicController = new PublicController(macchinaRepository, bevandaRepository, istitutoRepository, transazioneRepository);
        AdminLoginService adminLoginService = new AdminLoginService(adminLoginRepository, utenteRepository);

        // Registra i servizi
        ServiceRegistry.register("jwtService", jwtService);
        ServiceRegistry.register("authService", authService);
        ServiceRegistry.register("bevandaService", bevandaService);
        ServiceRegistry.register("utenteService", utenteService);
        ServiceRegistry.register("macchinaService", macchinaService);
        ServiceRegistry.register("istitutoService", istitutoService);
        ServiceRegistry.register("manutenzioneService", manutenzioneService);
        ServiceRegistry.register("ricavoService", ricavoService);
        ServiceRegistry.register("transazioneService", transazioneService);
        ServiceRegistry.register("publicController", publicController);
        ServiceRegistry.register("adminLoginService", adminLoginService);
        ServiceRegistry.register("macchinaController", macchinaController);

    }

    private static void configureServer() {
        // Configura la cartella dei file statici
        staticFiles.location("/public");
        staticFiles.header("Access-Control-Allow-Origin", "*");
        staticFiles.header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
        staticFiles.header("Access-Control-Allow-Headers", "Content-Type, Authorization");

        // Configura CORS
        CORSMiddleware corsMiddleware = new CORSMiddleware();
        before((request, response) -> corsMiddleware.applicaCORS(request, response));

        // Gestione OPTIONS per CORS
        options("/*", (request, response) -> {
            corsMiddleware.applicaCORS(request, response);
            return "OK";
        });

        // Configurazione autenticazione
        AuthController authController = new AuthController(ServiceRegistry.get(AdminLoginService.class),
                ServiceRegistry.get(UtenteService.class));
        before("/api/*", authController::verificaToken);

        // Configurazione parser JSON
        after((request, response) -> {
            response.type("application/json");
        });

        // Gestione errori
        exception(Exception.class, (e, request, response) -> {
            logger.error("Errore non gestito", e);
            response.status(500);
            response.body(gson.toJson(new ErrorResponse("Errore interno del server")));
        });

        notFound((request, response) -> {
            response.type("application/json");
            return gson.toJson(new ErrorResponse("Risorsa non trovata"));
        });
    }

    /* private static void initMQTT() throws Exception {
        // Configurazione opzioni MQTT
        MqttConnectOptions options = new MqttConnectOptions();
        options.setCleanSession(true);
        options.setConnectionTimeout(30);
        options.setKeepAliveInterval(60);
        options.setAutomaticReconnect(true);
        options.setUserName(config.getProperty("mqtt.client.username"));
        options.setPassword(config.getProperty("mqtt.client.password").toCharArray());

        // Configurazione SSL se abilitato
        if (Boolean.parseBoolean(config.getProperty("mqtt.ssl.enabled", "true"))) {
            options.setSocketFactory(SSLSocketFactory.getDefault());
        }

        // Configurazione Last Will and Testament
        options.setWill("system/server/status", "offline".getBytes(), 1, true);

        // Inizializza e connetti il client MQTT
        mqttClient = new MQTTClient("server");
        mqttClient.connetti(options);

        // Sottoscrizione ai topic di sistema
        mqttClient.subscribe("macchine/+/stato", (topic, message) -> {
            logger.debug("Ricevuto messaggio stato: {} - {}", topic, message);
            ServiceRegistry.get(ManutenzioneService.class).processaMacchinaStato(topic, message);
            
            String[] parts = topic.split("/");
            if (parts.length >= 2) {
                try {
                    int macchinaId = Integer.parseInt(parts[1]);
                    MacchinaPrincipale macchina = macchineAttive.get(macchinaId);
                    if (macchina != null) {
                        macchina.pubblicaStatoMacchina();
                    }
                } catch (NumberFormatException e) {
                    logger.error("ID macchina non valido nel topic: {}", topic);
                }
            }
        });

        logger.info("Client MQTT inizializzato e connesso");
    }*/
    private static void initMQTT() throws Exception {
        // Configurazione opzioni MQTT
        MqttConnectOptions options = new MqttConnectOptions();
        options.setCleanSession(true);
        options.setConnectionTimeout(30);
        options.setKeepAliveInterval(60);
        options.setAutomaticReconnect(true);
        options.setUserName(config.getProperty("mqtt.client.username"));
        options.setPassword(config.getProperty("mqtt.client.password").toCharArray());

        // Configurazione SSL
        if (Boolean.parseBoolean(config.getProperty("mqtt.ssl.enabled", "true"))) {
            try {
                String trustStorePath = config.getProperty("mqtt.ssl.truststore");
                String trustStorePassword = config.getProperty("mqtt.ssl.password");
                String trustStoreType = config.getProperty("mqtt.ssl.type", "JKS");

                if (trustStorePath != null && trustStorePassword != null) {
                    System.setProperty("javax.net.ssl.trustStore", trustStorePath);
                    System.setProperty("javax.net.ssl.trustStorePassword", trustStorePassword);
                    System.setProperty("javax.net.ssl.trustStoreType", trustStoreType);

                    Properties sslProperties = new Properties();
                    sslProperties.setProperty("com.ibm.ssl.protocol", "TLSv1.2");
                    options.setSSLProperties(sslProperties);
                } else {
                    logger.warn("SSL enabled but truststore settings not found, using default SSL configuration");
                    options.setSocketFactory(SSLSocketFactory.getDefault());
                }
            } catch (Exception e) {
                logger.error("Error configuring SSL: {}", e.getMessage());
                throw new RuntimeException("Error configuring SSL", e);
            }
        }

        // Configurazione Last Will and Testament (LWT)
        options.setWill("system/server/status", "offline".getBytes(), 1, true);

        // Inizializza e connetti il client MQTT
        mqttClient = new MQTTClient("server");
        mqttClient.connetti(options);

        logger.info("Client MQTT inizializzato e connesso");
    }

    private static void initMacchine() {
        try {
            MacchinaRepository macchinaRepo = ServiceRegistry.get(MacchinaRepository.class);
            var macchine = macchinaRepo.findAll();

            for (Macchina macchina : macchine) {
                try {
                    MacchinaPrincipale macchinaPrincipale = new MacchinaPrincipale(macchina);
                    macchineAttive.put(macchina.getId(), macchinaPrincipale);
                    logger.info("Macchina {} inizializzata con successo", macchina.getId());
                } catch (Exception e) {
                    logger.error("Errore nell'inizializzazione della macchina {}: {}",
                            macchina.getId(), e.getMessage());
                }
            }

            logger.info("Inizializzate {} macchine", macchineAttive.size());
        } catch (Exception e) {
            logger.error("Errore durante l'inizializzazione delle macchine", e);
        }
    }

    private static void setupRoutes() throws MqttException {
        // Middleware per autenticazione e logging
        AuthMiddleware authMiddleware = new AuthMiddleware();
        LogMiddleware logMiddleware = new LogMiddleware();
        CORSMiddleware corsMiddleware = new CORSMiddleware();

        // Controller e servizi
        IstitutoController istitutoController = new IstitutoController(
                ServiceRegistry.get(IstitutoRepository.class),
                ServiceRegistry.get(MacchinaRepository.class)
        );

        MacchinaController macchinaController = new MacchinaController(
                ServiceRegistry.get(MacchinaRepository.class),
                ServiceRegistry.get(BevandaRepository.class)
        );

        AuthController authController = new AuthController(ServiceRegistry.get(AdminLoginService.class),
                ServiceRegistry.get(UtenteService.class)
        );

        ManutenzioneController manutenzioneController = new ManutenzioneController(
                ServiceRegistry.get(ManutenzioneRepository.class)
        );

        BevandaController bevandaController = new BevandaController(
                ServiceRegistry.get(BevandaService.class)
        );
        
        UtenteController utenteController = new UtenteController(
        		ServiceRegistry.get(UtenteRepository.class)
        );
        
        // Register controllers in the ServiceRegistry
        ServiceRegistry.register("istitutoController", istitutoController);
        ServiceRegistry.register("macchinaController", macchinaController);
        ServiceRegistry.register("bevandaController", bevandaController);
        ServiceRegistry.register("manutenzioneController", manutenzioneController);
        ServiceRegistry.register("utenteController", utenteController);

        String base = "/api";
        get("/", (req, res) -> {
            res.redirect("/index.html");
            return null;
        });

        // Configurazione CORS e logging globale
        before((request, response) -> corsMiddleware.applicaCORS(request, response));
        after((request, response) -> logMiddleware.logRequest(request, response));
        
        // Autenticazione
        path("/api/auth", () -> {
            post("/login", authController::login);
            post("/register", authController::registrazione);
            post("/refresh", authController::refreshToken);
            post("/verify", authController::verificaToken);
            post("/anonymous", authController::getAnonymousToken);
        });

        // Root path e redirect alla homepage
        get("/", (req, res) -> {
            res.redirect("/index.html");
            return null;
        });

        // Accesso alle risorse
        get("/api/macchine", ServiceRegistry.get(MacchinaController.class)::getAll);
        get("/api/macchine/:id", ServiceRegistry.get(MacchinaController.class)::getById);
        get("/api/macchine/istituto/:istitutoId", ServiceRegistry.get(MacchinaController.class)::getByIstituto);
        get("/api/macchine/:id/stato", ServiceRegistry.get(MacchinaController.class)::getStatoMacchina);
        get("/api/macchine/:id/bevande", (req, res) -> {
            int macchinaId = Integer.parseInt(req.params(":id"));
            return macchinaController.getBevandeMacchina(macchinaId, res);
        });

        get("/api/istituti", ServiceRegistry.get(IstitutoController.class)::getAll);
        get("/api/istituti/:id", ServiceRegistry.get(IstitutoController.class)::getById);

        get("/api/bevande", bevandaController::getAll);
        get("/api/bevande/:id", bevandaController::getById);
        get("/api/bevande/:id/disponibilita/:macchinaId", (req, res) -> {
            int bevandaId = Integer.parseInt(req.params(":id"));
            int macchinaId = Integer.parseInt(req.params(":macchinaId"));
            return macchinaController.verificaDisponibilitaBevanda(bevandaId, macchinaId, res);
        });

        // Rotte per la gestione del denaro e erogazione bevande
        path("/api/macchine/:id", () -> {
            // Inserimento denaro
            post("/insertMoney", (req, res) -> {
                int macchinaId = Integer.parseInt(req.params(":id"));
                double importo = Double.parseDouble(req.queryParams("importo"));

                // Recupera la macchina e verifica che sia attiva
                Macchina macchina = ServiceRegistry.get(MacchinaRepository.class).findById(macchinaId);
                if (macchina == null) {
                    res.status(404);
                    return gson.toJson(Map.of("error", "Macchina non trovata"));
                }

                if (macchina.getStatoId() != 1) { // 1 = Attiva
                    res.status(400);
                    return gson.toJson(Map.of("error", "Macchina non disponibile"));
                }

                // Crea un'istanza del GestoreCassa per questa macchina
                GestoreCassa gestoreCassa = new GestoreCassa(macchinaId, macchina.getCassaMassima());

                // Tenta di inserire il denaro
                boolean inserimentoRiuscito = gestoreCassa.gestisciInserimentoMoneta(importo);

                if (inserimentoRiuscito) {
                    return gson.toJson(Map.of(
                            "success", true,
                            "message", "Denaro inserito con successo",
                            "creditoAttuale", gestoreCassa.ottieniStato().get("creditoAttuale")
                    ));
                } else {
                    res.status(400);
                    return gson.toJson(Map.of("error", "Impossibile accettare il denaro"));
                }
            });

            // Erogazione bevanda
            post("/erogazione", (req, res) -> {
                int macchinaId = Integer.parseInt(req.params(":id"));
                Map<String, Object> body = gson.fromJson(req.body(), Map.class);
                int bevandaId = ((Number) body.get("bevandaId")).intValue();
                double importo = ((Number) body.get("importo")).doubleValue();

                // Recupera la macchina
                MacchinaPrincipale macchina = macchineAttive.get(macchinaId);
                if (macchina == null) {
                    res.status(404);
                    return gson.toJson(Map.of("error", "Macchina non trovata"));
                }

                // Recupera la bevanda per verificare il prezzo
                BevandaRepository bevandaRepo = ServiceRegistry.get(BevandaRepository.class);
                Optional<Bevanda> bevanda = bevandaRepo.findById(bevandaId);
                if (!bevanda.isPresent()) {
                    res.status(404);
                    return gson.toJson(Map.of("error", "Bevanda non trovata"));
                }

                // Crea la transazione
                TransazioneRepository transazioneRepo = ServiceRegistry.get(TransazioneRepository.class);
                Transazione transazione = new Transazione();
                int idT = transazioneRepo.getLastTransactionId() + 1;
                transazione.setId(idT);
                transazione.setMacchinaId(macchinaId);
                transazione.setBevandaId(bevandaId);
                transazione.setImporto(importo);
                transazione.setDataOra(LocalDateTime.now());

                // Pubblica la richiesta sul topic MQTT appropriato
                String topic = "macchine/" + macchinaId + "/bevande/richiesta";
                Map<String, Object> message = Map.of(
                        "bevandaId", bevandaId,
                        "importo", importo,
                        "timestamp", System.currentTimeMillis(),
                        "transazioneId", transazione.getId()
                );

                try {
                    mqttClient.publish(topic, gson.toJson(message));
                    transazione = transazioneRepo.save(transazione);

                    return gson.toJson(Map.of(
                            "success", true,
                            "message", "Richiesta erogazione inviata",
                            "transazioneId", transazione.getId()
                    ));
                } catch (Exception e) {
                    res.status(500);
                    return gson.toJson(Map.of("error", "Errore durante il salvataggio della transazione: " + e.getMessage()));
                }
            });

            // Annulla inserimento e restituisci credito
            post("/cancelInsert", (req, res) -> {
                int macchinaId = Integer.parseInt(req.params(":id"));

                // Recupera la macchina
                Macchina macchina = ServiceRegistry.get(MacchinaRepository.class).findById(macchinaId);
                if (macchina == null) {
                    res.status(404);
                    return gson.toJson(Map.of("error", "Macchina non trovata"));
                }

                // Crea un'istanza del GestoreCassa
                GestoreCassa gestoreCassa = new GestoreCassa(macchinaId, macchina.getCassaMassima());

                // Gestisci la restituzione del credito
                gestoreCassa.gestisciRestituzioneCredito();

                return gson.toJson(Map.of(
                        "success", true,
                        "message", "Credito restituito"
                ));
            });

            // Verifica stato macchina
            get("/stato", (req, res) -> {
                int macchinaId = Integer.parseInt(req.params(":id"));

                // Recupera la macchina
                MacchinaPrincipale macchina = macchineAttive.get(macchinaId);
                if (macchina == null) {
                    res.status(404);
                    return gson.toJson(Map.of("error", "Macchina non trovata"));
                }

                // Ottieni lo stato completo della macchina
                Map<String, Object> stato = new HashMap<>();
                stato.put("statoMacchina", ServiceRegistry.get(MacchinaRepository.class)
                        .findById(macchinaId));
                stato.put("statoCassa", macchina.gestoreCassa.ottieniStato());
                stato.put("statoBevande", macchina.gestoreBevande.ottieniStato());
                stato.put("statoCialde", macchina.gestoreCialde.ottieniStato());

                return gson.toJson(stato);
            });
        });
        
        // Operazioni admin
        path("/api/admin", () -> {
            before("/*", authMiddleware::autenticazione);
            
            // Gestione Utenti
            path("/utenti", () -> {
                get("", (req, res) -> ServiceRegistry.get(UtenteController.class).getAll(req, res)); //Recuperare tutti gli utenti
                get("/:id", (req, res) -> ServiceRegistry.get(UtenteController.class).getById(req, res)); // Recuperare un utente per ID
                get("/username/:username", (req, res) -> ServiceRegistry.get(UtenteController.class).getByUsername(req, res)); // Recuperare un utente per username
                get("/ruolo/:ruolo", (req, res) -> ServiceRegistry.get(UtenteController.class).getByRuolo(req, res)); //Recuperare utenti per ruolo
                post("", (req, res) -> ServiceRegistry.get(UtenteController.class).create(req, res)); // Creare un nuovo utente
                put("/:id", (req, res) -> ServiceRegistry.get(UtenteController.class).update(req, res)); // Aggiornare un utente
                delete("/:id", (req, res) -> ServiceRegistry.get(UtenteController.class).delete(req, res)); // Eliminare un utente
            });
            
            // Gestione istituti
            post("/istituti", (req, res) -> {
                //authMiddleware.autorizzazioneAdmin(req, res);
                return istitutoController.create(req, res);
            });
            put("/istituti/:id", (req, res) -> {
                authMiddleware.autorizzazioneAdmin(req, res);
                return istitutoController.update(req, res);
            });
            delete("/istituti/:id", (req, res) -> {
                authMiddleware.autorizzazioneAdmin(req, res);
                return istitutoController.delete(req, res);
            });

            // Gestione macchine
            post("/macchine", (req, res) -> {
                authMiddleware.autorizzazioneAdmin(req, res);
                return macchinaController.create(req, res);
            });
            put("/macchine/:id/bevande", (req, res) -> {
                return ServiceRegistry.get(MacchinaController.class).updateBevandeMacchina(req, res);
            });
            put("/macchine/:id/stato", macchinaController::updateStato);
            delete("/macchine/:id", (req, res) -> {
                authMiddleware.autorizzazioneAdmin(req, res);
                return macchinaController.delete(req, res);
            });

            // Gestione bevande
            path("/bevande", () -> {
                post("", (req, res) -> {
                    authMiddleware.autorizzazioneAdmin(req, res);
                    return bevandaController.create(req, res);
                });
                put("/:id", (req, res) -> {
                    authMiddleware.autorizzazioneAdmin(req, res);
                    return bevandaController.update(req, res);
                });
                delete("/:id", (req, res) -> {
                    authMiddleware.autorizzazioneAdmin(req, res);
                    return bevandaController.delete(req, res);
                });
                put("/:id/cialde", (req, res) -> {
                    authMiddleware.autorizzazioneAdmin(req, res);
                    return bevandaController.aggiungiCialda(req, res);
                });
                delete("/:id/cialde/:cialdaId", (req, res) -> {
                    authMiddleware.autorizzazioneAdmin(req, res);
                    return bevandaController.rimuoviCialda(req, res);
                });
            });
        });
        
        // Manutenzioni
        path("/api/manutenzione", () -> {
        	// Verifica autenticazione
        	before("/*", authMiddleware::autenticazione);

        	// Ottieni tutte le manutenzioni
        	get("", (req, res) -> {
        		return manutenzioneController.getManutenzioni(req, res);
        	});

        	// Ottieni manutenzioni per istituto
        	get("/istituto/:istitutoId", (req, res) -> {
        		try {
        			int istitutoId = Integer.parseInt(req.params(":istitutoId"));
        			List<Manutenzione> manutenzioni = (List<Manutenzione>) manutenzioneController.getManutenzioniIstituto(req, res);
        			res.type("application/json");
        			return gson.toJson(manutenzioni);
        		} catch (NumberFormatException e) {
        			res.status(400);
        			return gson.toJson(Map.of("error", "ID istituto non valido"));
        		} catch (Exception e) {
        			res.status(500);
        			return gson.toJson(Map.of("error", "Errore durante il recupero delle manutenzioni per istituto: " + e.getMessage()));
        		}
        	});
        	
        	// Ottieni manutenzioni per tecnico
        	get("/tecnico/:tecnicoId", (req, res) -> {
        		try {
        			int tecnicoId = Integer.parseInt(req.params(":tecnicoId"));
        			List<Manutenzione> manutenzioni = (List<Manutenzione>) manutenzioneController.getManutenzioniTecnico(req, res);
        			res.type("application/json");
        			return gson.toJson(manutenzioni);
        		} catch (NumberFormatException e) {
        			res.status(400);
        			return gson.toJson(Map.of("error", "ID tecnico non valido"));
        		} catch (Exception e) {
        			res.status(500);
        			return gson.toJson(Map.of("error", "Errore durante il recupero delle manutenzioni per tecnico: " + e.getMessage()));
        		}
        	});

        	// Inizia una nuova manutenzione
        	post("", (req, res) -> {
        		try {
        			Map<String, Object> body = gson.fromJson(req.body(), Map.class);
        			int macchinaId = Integer.parseInt(body.get("macchinaId").toString());
        			String tipoIntervento = (String) body.get("tipoIntervento");
        			String descrizione = (String) body.get("descrizione");
        			String urgenza = (String) body.get("urgenza");

        			Manutenzione manutenzione = (Manutenzione) manutenzioneController.iniziaManutenzione(req, res);
        			res.type("application/json");
        			return gson.toJson(manutenzione);
        		} catch (NumberFormatException e) {
        			res.status(400);
        			return gson.toJson(Map.of("error", "ID macchina non valido"));
        		} catch (Exception e) {
        			res.status(500);
        			return gson.toJson(Map.of("error", "Errore durante l'inizio della manutenzione: " + e.getMessage()));
        		}
        	});

        	// Completa una manutenzione esistente
        	put("/:id/completa", (req, res) -> {
        		try {
        			int manutenzioneId = Integer.parseInt(req.params(":id"));
        			Map<String, Object> body = gson.fromJson(req.body(), Map.class);
        			String note = (String) body.get("note");
        			String tecnico = (String) body.get("tecnico");

        			Manutenzione manutenzione = (Manutenzione) manutenzioneController.completaManutenzione(req, res);
        			res.type("application/json");
        			return gson.toJson(manutenzione);
        		} catch (NumberFormatException e) {
        			res.status(400);
        			return gson.toJson(Map.of("error", "ID manutenzione non valido"));
        		} catch (Exception e) {
        			res.status(500);
        			return gson.toJson(Map.of("error", "Errore durante il completamento della manutenzione: " + e.getMessage()));
        		}
        	});

        	// Imposta una manutenzione come fuori servizio
        	put("/:id/fuori-servizio", (req, res) -> {
        		try {
        			int manutenzioneId = Integer.parseInt(req.params(":id"));
        			Manutenzione manutenzione = (Manutenzione) manutenzioneController.setFuoriServizio(req, res);
        			res.type("application/json");
        			return gson.toJson(manutenzione);
        		} catch (NumberFormatException e) {
        			res.status(400);
        			return gson.toJson(Map.of("error", "ID manutenzione non valido"));
        		} catch (Exception e) {
        			res.status(500);
        			return gson.toJson(Map.of("error", "Errore durante l'impostazione della manutenzione come fuori servizio: " + e.getMessage()));
        		}
        	});
        });

        // Setup MQTT topics
        setupMQTTTopics();

        // Rotta per lo spegnimento controllato
        get("/spegni", (req, res) -> {
            logger.info("Richiesta di spegnimento ricevuta");
            new Thread(() -> {
                try {
                    Thread.sleep(1000);
                    shutdown();
                    System.exit(0);
                } catch (InterruptedException e) {
                    logger.error("Errore durante lo spegnimento: {}", e.getMessage());
                }
            }).start();
            res.type("application/json");
            return gson.toJson(Map.of("message", "Spegnimento del sistema in corso...", "status", "success"));
        });

        // Gestione errori
        exception(Exception.class, (e, req, res) -> {
            res.status(500);
            res.type("application/json");
            res.body("{\"errore\": \"" + e.getMessage() + "\"}");
            logMiddleware.logError(req, e);
        });

        notFound((req, res) -> {
            res.type("application/json");
            res.status(404);
            return "{\"errore\": \"Risorsa non trovata\"}";
        });

        internalServerError((req, res) -> {
            res.type("application/json");
            return "{\"errore\": \"Errore interno del server\"}";
        });
    }

    private static void setupMQTTTopics() throws MqttException {

        // Topic per lo stato delle macchine
        mqttClient.subscribe("macchine/+/stato", (topic, message) -> {
            logger.debug("Ricevuto messaggio stato: {} - {}", topic, message);
            ServiceRegistry.get(ManutenzioneService.class).processaMacchinaStato(topic, message);

            String[] parts = topic.split("/");
            if (parts.length >= 2) {
                try {
                    int macchinaId = Integer.parseInt(parts[1]);
                    MacchinaPrincipale macchina = macchineAttive.get(macchinaId);
                    if (macchina != null) {
                        macchina.pubblicaStatoMacchina();
                    }
                } catch (NumberFormatException e) {
                    logger.error("ID macchina non valido nel topic: {}", topic);
                }
            }
        });

        // Topic per le operazioni utente
        mqttClient.subscribe("macchine/+/cassa/#", (topic, message) -> {
            String[] parts = topic.split("/");
            //CHECK PER ZUCCHERO DA FARE
            if (parts.length >= 4) {
                try {
                    int macchinaId = Integer.parseInt(parts[1]);
                    String operazione = parts[3];
                    MacchinaPrincipale macchina = macchineAttive.get(macchinaId);

                    if (macchina != null) {
                        switch (operazione) {
                            case "inserimentoCredito":
                                double importo = Double.parseDouble(message);
                                boolean successo = macchina.gestoreCassa.gestisciInserimentoMoneta(importo);
                                if (successo) {
                                    logger.info("Credito inserito con successo nella macchina {}: {}", macchinaId, importo);
                                } else {
                                    logger.warn("Impossibile inserire credito nella macchina {}: {}", macchinaId, importo);
                                }
                                break;

                            case "richiestaBevanda":
                                int bevandaId = Integer.parseInt(message);
                                macchina.gestisciErogazioneBevanda(bevandaId, 0); // Livello zucchero default
                                logger.info("Richiesta bevanda {} nella macchina {}", bevandaId, macchinaId);
                                break;

                            case "richiestaResto":
                                macchina.gestoreCassa.gestisciRestituzioneCredito();
                                logger.info("Resto richiesto nella macchina {}", macchinaId);
                                break;

                            default:
                                logger.warn("Operazione non riconosciuta: {}", operazione);
                                break;
                        }
                    }
                } catch (Exception e) {
                    logger.error("Errore nell'elaborazione dell'operazione: {}", e.getMessage());
                }
            }
        });

        // Topic per le bevande
        mqttClient.subscribe("macchine/+/bevande/#", (topic, message) -> {
            logger.debug("Ricevuto messaggio bevande: {} - {}", topic, message);
            String[] parts = topic.split("/");
            if (parts.length >= 4) {
                try {
                    int macchinaId = Integer.parseInt(parts[1]);
                    int zucchero = Integer.parseInt(parts[2]);
                    String azione = parts[3];
                    MacchinaPrincipale macchina = macchineAttive.get(macchinaId);

                    if (macchina != null) {
                        switch (azione) {
                            case "aggiorna":
                                // Gestisci l'aggiornamento della bevanda
                                macchina.pubblicaStatoMacchina();
                                break;
                            default:
                                logger.warn("Azione bevanda non riconosciuta: {}", azione);
                                break;
                        }
                    }
                } catch (Exception e) {
                    logger.error("Errore nell'elaborazione della bevanda: {}", e.getMessage());
                }
            }
        });

        // Topic per le cialde
        mqttClient.subscribe("macchine/+/cialde/#", (topic, message) -> {
            logger.debug("Ricevuto messaggio cialde: {} - {}", topic, message);
            String[] parts = topic.split("/");
            if (parts.length >= 4) {
                try {
                    int macchinaId = Integer.parseInt(parts[1]);
                    String azione = parts[3];
                    MacchinaPrincipale macchina = macchineAttive.get(macchinaId);

                    if (macchina != null) {
                        switch (azione) {
                            case "ricarica":
                                // Gestisci la ricarica delle cialde
                                macchina.gestoreCialde.gestisciRicaricaCialde(new GestoreCialde.RichiestaCialde());
                                break;
                            case "verifica":
                                // Verifica lo stato delle cialde
                                macchina.gestoreCialde.verificaStatoCialde();
                                break;
                            default:
                                logger.warn("Azione cialde non riconosciuta: {}", azione);
                                break;
                        }
                    }
                } catch (Exception e) {
                    logger.error("Errore nell'elaborazione delle cialde: {}", e.getMessage());
                }
            }
        });

        // Topic per la manutenzione
        mqttClient.subscribe("macchine/+/manutenzione/#", (topic, message) -> {
            logger.debug("Ricevuto messaggio manutenzione: {} - {}", topic, message);
            String[] parts = topic.split("/");
            if (parts.length >= 4) {
                try {
                    int macchinaId = Integer.parseInt(parts[1]);
                    String azione = parts[3];
                    MacchinaPrincipale macchina = macchineAttive.get(macchinaId);

                    if (macchina != null) {
                        switch (azione) {
                            case "segnalazione":
                                // Gestisci la segnalazione di un problema
                                macchina.gestoreManutenzione.segnalaProblema("tipo_problema", "descrizione_problema", new HashMap<>());
                                break;
                            case "risoluzione":
                                // Gestisci la risoluzione di un problema
                                macchina.gestoreManutenzione.risolviProblema("id_problema", "descrizione_risoluzione", "tecnico");
                                break;
                            case "verifica":
                                // Verifica lo stato della manutenzione
                                macchina.gestoreManutenzione.verificaStato();
                                break;
                            default:
                                logger.warn("Azione manutenzione non riconosciuta: {}", azione);
                                break;
                        }
                    }
                } catch (Exception e) {
                    logger.error("Errore nell'elaborazione della manutenzione: {}", e.getMessage());
                }
            }
        });

        // Topic per gli eventi
        mqttClient.subscribe("macchine/+/eventi", (topic, message) -> {
            logger.debug("Ricevuto evento: {} - {}", topic, message);
            String[] parts = topic.split("/");
            if (parts.length >= 3) {
                try {
                    int macchinaId = Integer.parseInt(parts[1]);
                    MacchinaPrincipale macchina = macchineAttive.get(macchinaId);
                    if (macchina != null) {
                        // Gestisci l'evento
                        logger.debug("Ricevuto evento: {} - {}", topic, message);
                    }
                } catch (NumberFormatException e) {
                    logger.error("ID macchina non valido nel topic: {}", topic);
                }
            }
        });

    }

    private static void openDashboard(String port) {
        try {
            Thread.sleep(1500);
            String url = "http://localhost:" + port + "/index.html";
            String os = System.getProperty("os.name").toLowerCase();

            if (os.contains("win")) {
                Runtime.getRuntime().exec("rundll32 url.dll,FileProtocolHandler " + url);
            } else if (os.contains("mac")) {
                Runtime.getRuntime().exec("open " + url);
            } else if (os.contains("nix") || os.contains("nux")) {
                String[] browsers = {"google-chrome", "firefox", "mozilla", "epiphany",
                    "konqueror", "netscape", "opera", "links", "lynx"};

                StringBuffer cmd = new StringBuffer();
                for (int i = 0; i < browsers.length; i++) {
                    if (i == 0) {
                        cmd.append(String.format("%s \"%s\"", browsers[i], url));
                    } else {
                        cmd.append(String.format(" || %s \"%s\"", browsers[i], url));
                    }
                }

                Runtime.getRuntime().exec(new String[]{"sh", "-c", cmd.toString()});
            }

            logger.info("Dashboard aperta nel browser: {}", url);
        } catch (Exception e) {
            logger.error("Impossibile aprire il browser automaticamente", e);
            logger.info("Per accedere alla dashboard, apri manualmente: http://localhost:{}/index.html", port);
        }
    }

    private static class ErrorResponse {

        private final String message;

        public ErrorResponse(String message) {
            this.message = message;
        }
    }

    public static void shutdown() {
        logger.info("Avvio procedura di spegnimento...");

        macchineAttive.values().forEach(macchina -> {
            try {
                macchina.eseguiSpegnimento();
            } catch (Exception e) {
                logger.error("Errore durante lo spegnimento della macchina", e);
            }
        });

        macchineAttive.clear();

        try {
            if (mqttClient != null) {
                mqttClient.disconnect();
            }
        } catch (Exception e) {
            logger.error("Errore durante la disconnessione del client MQTT", e);
        }

        logger.info("Spegnimento completato");
    }
}

================
File: src/main/java/com/vending/security/auth/AuthenticationService.java
================
package com.vending.security.auth;

import com.vending.core.models.Utente;
import com.vending.security.jwt.JWTService;
import com.vending.core.repositories.UtenteRepository;

public class AuthenticationService {

    private final UtenteRepository utenteRepository;
    private final PasswordService passwordService;
    private final JWTService jwtService;

    public AuthenticationService(UtenteRepository utenteRepository, PasswordService passwordService, JWTService jwtService) {
        this.utenteRepository = utenteRepository;
        this.passwordService = passwordService;
        this.jwtService = jwtService;
    }

    /**
     * Autentica un utente in base a username e password.
     *
     * @param username Il nome utente.
     * @param password La password in chiaro.
     * @return Un token JWT se l'autenticazione ha successo, altrimenti null.
     */
    public String authenticate(String username, String password) {
        // Cerca l'utente nel repository
        Utente utente = utenteRepository.findByUsername(username);

        if (utente != null) {
            // Verifica la password
            if ((passwordService.verificaPassword(password, utente.getPasswordHash())) && (passwordService.verifyPasswordH(password, utente.getPasswordHash()))) {
                // Genera un token JWT
                return jwtService.generaToken(utente);
            }
        }

        // Se l'autenticazione fallisce, restituisci null
        return null;
    }

    /**
     * Verifica se un token JWT è valido.
     *
     * @param token Il token JWT da verificare.
     * @return True se il token è valido, altrimenti false.
     */
    public boolean validateToken(String token) {
        return jwtService.verificaToken(token);
    }
}

================
File: src/main/java/com/vending/security/auth/AuthorizationException.java
================
package com.vending.security.auth;


public class AuthorizationException extends RuntimeException {
    public AuthorizationException(String message) {
        super(message);
    }
 
    public AuthorizationException(String message, Throwable cause) {
        super(message, cause);
    }
 }

================
File: src/main/java/com/vending/security/auth/AuthorizationService.java
================
package com.vending.security.auth;

import com.vending.core.models.Utente;
import com.vending.security.jwt.JWTService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Servizio che gestisce le autorizzazioni degli utenti nel sistema.
 * Implementa la logica per il controllo dei permessi basati sui ruoli.
 */
public class AuthorizationService {
    private static final Logger logger = LoggerFactory.getLogger(AuthorizationService.class);
    private final JWTService jwtService;
    
    // Costanti per i claims del token
    private static final String ROLE_CLAIM = "role";
    
    // Mappa che associa ogni ruolo alle sue azioni permesse
    private static final Map<String, List<String>> ROLE_PERMISSIONS = new HashMap<>();
    
    static {
        // Permessi per amministratori
        ROLE_PERMISSIONS.put("ADMIN", Arrays.asList(
            "VIEW_SCHOOLS",
            "ADD_SCHOOL",
            "REMOVE_SCHOOL",
            "VIEW_MACHINES",
            "ADD_MACHINE",
            "REMOVE_MACHINE",
            "VIEW_MACHINE_STATUS",
            "SEND_TECHNICIAN",
            "VIEW_REVENUES",
            "MANAGE_USERS"
        ));
        
        // Permessi per impiegati
        ROLE_PERMISSIONS.put("EMPLOYEE", Arrays.asList(
            "VIEW_SCHOOLS",
            "VIEW_MACHINES",
            "VIEW_MACHINE_STATUS",
            "SEND_TECHNICIAN"
        ));
    }

    /**
     * Costruttore del servizio di autorizzazione.
     * 
     * @param jwtService servizio JWT per la validazione dei token
     */
    public AuthorizationService(JWTService jwtService) {
        this.jwtService = jwtService;
    }

    /**
     * Verifica se un utente ha il permesso di eseguire una determinata azione.
     * 
     * @param utente l'utente da verificare
     * @param permission il permesso richiesto
     * @return true se l'utente ha il permesso, false altrimenti
     */
    public boolean hasPermission(Utente utente, String permission) {
        if (utente == null || permission == null) {
            logger.warn("Tentativo di verifica permesso con utente o permesso null");
            return false;
        }

        String ruolo = utente.getRuolo().toUpperCase();
        List<String> permissions = ROLE_PERMISSIONS.get(ruolo);
        
        if (permissions == null) {
            logger.warn("Ruolo non trovato: {}", ruolo);
            return false;
        }

        boolean hasPermission = permissions.contains(permission);
        logger.debug("Verifica permesso '{}' per utente {}: {}", 
                    permission, utente.getUsername(), hasPermission);
        
        return hasPermission;
    }

    /**
     * Verifica se un token JWT è valido e se l'utente associato ha il permesso richiesto.
     * 
     * @param token il token JWT da verificare
     * @param permission il permesso richiesto
     * @return true se il token è valido e l'utente ha il permesso, false altrimenti
     */
    public boolean validateTokenAndPermission(String token, String permission) {
        try {
            if (!jwtService.verificaToken(token)) {
                logger.warn("Token JWT non valido");
                return false;
            }

            String ruolo = jwtService.getRuoloDaToken(token);
            List<String> permissions = ROLE_PERMISSIONS.get(ruolo);
            
            if (permissions == null) {
                logger.warn("Ruolo non trovato nel token: {}", ruolo);
                return false;
            }

            return permissions.contains(permission);
            
        } catch (Exception e) {
            logger.error("Errore durante la validazione del token e permesso", e);
            return false;
        }
    }

    /**
     * Verifica se l'utente ha il ruolo di amministratore.
     * 
     * @param utente l'utente da verificare
     * @return true se l'utente è amministratore, false altrimenti
     */
    public boolean isAdmin(Utente utente) {
        if (utente == null) {
            return false;
        }
        return "ADMIN".equalsIgnoreCase(utente.getRuolo());
    }

    /**
     * Verifica se l'utente ha il ruolo di impiegato.
     * 
     * @param utente l'utente da verificare
     * @return true se l'utente è impiegato, false altrimenti
     */
    public boolean isEmployee(Utente utente) {
        if (utente == null) {
            return false;
        }
        return "EMPLOYEE".equalsIgnoreCase(utente.getRuolo());
    }

    /**
     * Ottiene la lista dei permessi associati a un ruolo specifico.
     * 
     * @param ruolo il ruolo di cui ottenere i permessi
     * @return la lista dei permessi associati al ruolo, o null se il ruolo non esiste
     */
    public List<String> getPermissionsForRole(String ruolo) {
        if (ruolo == null) {
            return null;
        }
        return ROLE_PERMISSIONS.get(ruolo.toUpperCase());
    }

    /**
     * Estrae il ruolo da un token JWT.
     * 
     * @param token il token JWT da cui estrarre il ruolo
     * @return il ruolo dell'utente contenuto nel token
     * @throws Exception se il token non è valido o non contiene il claim del ruolo
     */
    public String getRoleFromToken(String token) throws Exception {
        if (token == null || token.isEmpty()) {
            logger.error("Token nullo o vuoto");
            throw new IllegalArgumentException("Token non può essere nullo o vuoto");
        }

        try {
            // Estraiamo il claim 'role' dal token tramite il JWTService
            String role = jwtService.getClaimFromToken(token, ROLE_CLAIM);
            
            if (role == null || role.isEmpty()) {
                logger.error("Ruolo non trovato nel token");
                throw new Exception("Ruolo non trovato nel token");
            }

            // Verifichiamo che il ruolo sia uno di quelli validi
            if (!ROLE_PERMISSIONS.containsKey(role.toUpperCase())) {
                logger.error("Ruolo non valido trovato nel token: {}", role);
                throw new Exception("Ruolo non valido nel token");
            }

            logger.debug("Ruolo estratto dal token: {}", role);
            return role.toUpperCase();

        } catch (Exception e) {
            logger.error("Errore nell'estrazione del ruolo dal token", e);
            throw new Exception("Errore nell'estrazione del ruolo dal token", e);
        }
    }
}

================
File: src/main/java/com/vending/security/auth/PasswordService.java
================
package com.vending.security.auth;

import com.vending.security.config.SecurityConfig;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;

import org.mindrot.jbcrypt.BCrypt;

import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.util.Base64;

public class PasswordService {
    private final SecureRandom random;

    public PasswordService() {
        this.random = new SecureRandom();
    }

    public String hashPassword(String password) {
        try {
            byte[] salt = generaSalt();
            byte[] hash = generaHash(password.toCharArray(), salt);
            
            String saltBase64 = Base64.getEncoder().encodeToString(salt);
            String hashBase64 = Base64.getEncoder().encodeToString(hash);
            
            return String.format("%s:%s", saltBase64, hashBase64);
        } catch (Exception e) {
            throw new RuntimeException("Errore durante l'hashing della password", e);
        }
    }
    public boolean verifyPasswordH(String plainTextPassword, String hashedPassword) {
        return BCrypt.checkpw(plainTextPassword, hashedPassword);
    }

    public boolean verificaPassword(String password, String hashSalvato) {
        try {
            String[] parts = hashSalvato.split(":");
            byte[] salt = Base64.getDecoder().decode(parts[0]);
            byte[] hashSalvatoBytes = Base64.getDecoder().decode(parts[1]);
            
            byte[] hashCalcolato = generaHash(password.toCharArray(), salt);
            
            return comparaHash(hashSalvatoBytes, hashCalcolato);
        } catch (Exception e) {
            throw new RuntimeException("Errore durante la verifica della password", e);
        }
    }

    private byte[] generaSalt() {
        byte[] salt = new byte[SecurityConfig.SALT_LENGTH];
        random.nextBytes(salt);
        return salt;
    }

    private byte[] generaHash(char[] password, byte[] salt) 
            throws NoSuchAlgorithmException, InvalidKeySpecException {
        PBEKeySpec spec = new PBEKeySpec(
            password,
            salt,
            SecurityConfig.HASH_ITERATIONS,
            SecurityConfig.KEY_LENGTH
        );
        
        SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
        return factory.generateSecret(spec).getEncoded();
    }

    private boolean comparaHash(byte[] hash1, byte[] hash2) {
        if (hash1.length != hash2.length) {
            return false;
        }
        
        int result = 0;
        for (int i = 0; i < hash1.length; i++) {
            result |= hash1[i] ^ hash2[i];
        }
        return result == 0;
    }
}

================
File: src/main/java/com/vending/security/config/SecurityConfig.java
================
package com.vending.security.config;

public class SecurityConfig {
    // JWT Configuration
    public static final String JWT_SECRET = "your_jwt_secret_key_here";
    public static final long JWT_EXPIRATION = 864_000_000; // 10 giorni
    
    // Password Configuration
    public static final int SALT_LENGTH = 16;
    public static final int HASH_ITERATIONS = 10000;
    public static final int KEY_LENGTH = 256;
    
    // MQTT Security
    public static final String MQTT_USERNAME = "mqtt_user";
    public static final String MQTT_PASSWORD = "mqtt_password";
    public static final boolean MQTT_REQUIRE_SSL = true;
    
    // API Security
    public static final String[] PUBLIC_ENDPOINTS = {
        "/api/auth/login",
        "/api/auth/register"
    };
    
    public static final String[] ADMIN_ENDPOINTS = {
        "/api/admin/*",
        "/api/istituti/create",
        "/api/istituti/delete/*"
    };
}

================
File: src/main/java/com/vending/security/encryption/EncryptionService.java
================
package com.vending.security.encryption;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import java.security.SecureRandom;
import java.util.Base64;

public class EncryptionService {
    private final SecretKey chiave;
    private final SecureRandom random;

    public EncryptionService() throws Exception {
        KeyGenerator keyGen = KeyGenerator.getInstance("AES");
        keyGen.init(256);
        this.chiave = keyGen.generateKey();
        this.random = new SecureRandom();
    }

    public String cripta(String testo) {
        try {
            byte[] iv = generaIV();
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(Cipher.ENCRYPT_MODE, chiave, new IvParameterSpec(iv));
            
            byte[] testoEncoded = testo.getBytes();
            byte[] testoCifrato = cipher.doFinal(testoEncoded);
            
            byte[] risultato = new byte[iv.length + testoCifrato.length];
            System.arraycopy(iv, 0, risultato, 0, iv.length);
            System.arraycopy(testoCifrato, 0, risultato, iv.length, testoCifrato.length);
            
            return Base64.getEncoder().encodeToString(risultato);
        } catch (Exception e) {
            throw new RuntimeException("Errore durante la cifratura", e);
        }
    }

    public String decripta(String testoCifrato) {
        try {
            byte[] decodedData = Base64.getDecoder().decode(testoCifrato);
            
            byte[] iv = new byte[16];
            byte[] message = new byte[decodedData.length - 16];
            
            System.arraycopy(decodedData, 0, iv, 0, 16);
            System.arraycopy(decodedData, 16, message, 0, message.length);
            
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(Cipher.DECRYPT_MODE, chiave, new IvParameterSpec(iv));
            
            byte[] decrypted = cipher.doFinal(message);
            return new String(decrypted);
        } catch (Exception e) {
            throw new RuntimeException("Errore durante la decifratura", e);
        }
    }

    private byte[] generaIV() {
        byte[] iv = new byte[16];
        random.nextBytes(iv);
        return iv;
    }
}

================
File: src/main/java/com/vending/security/jwt/JWTService.java
================
package com.vending.security.jwt;

import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.vending.core.models.Utente;
import com.vending.security.config.SecurityConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.Date;

/**
 * Servizio per la gestione dei token JWT (JSON Web Token).
 * Gestisce la creazione, verifica e decodifica dei token di autenticazione.
 */
public class JWTService {
    private static final Logger logger = LoggerFactory.getLogger(JWTService.class);
    private final Algorithm algorithm;

    /**
     * Costruttore che inizializza l'algoritmo di firma JWT usando la chiave segreta configurata.
     */
    public JWTService() {
        this.algorithm = Algorithm.HMAC256(SecurityConfig.JWT_SECRET);
    }

    /**
     * Genera un nuovo token JWT per l'utente specificato.
     *
     * @param utente l'utente per cui generare il token
     * @return il token JWT generato
     */
    public String generaToken(Utente utente) {
        try {
            return JWT.create()
                    .withSubject(String.valueOf(utente.getId()))
                    .withClaim("username", utente.getUsername())
                    .withClaim("ruolo", utente.getRuolo())
                    .withIssuedAt(new Date())
                    .withExpiresAt(new Date(System.currentTimeMillis() + SecurityConfig.JWT_EXPIRATION))
                    .sign(algorithm);
        } catch (Exception e) {
            logger.error("Errore durante la generazione del token JWT", e);
            throw new RuntimeException("Impossibile generare il token JWT", e);
        }
    }

    /**
     * Verifica la validità di un token JWT.
     *
     * @param token il token da verificare
     * @return true se il token è valido, false altrimenti
     */
    public boolean verificaToken(String token) {
        if (token == null || token.isEmpty()) {
            return false;
        }
        
        try {
            JWT.require(algorithm)
               .build()
               .verify(token);
            return true;
        } catch (JWTVerificationException e) {
            logger.warn("Token JWT non valido: {}", e.getMessage());
            return false;
        }
    }

    /**
     * Estrae il ruolo dell'utente dal token JWT.
     *
     * @param token il token da cui estrarre il ruolo
     * @return il ruolo dell'utente
     * @throws JWTVerificationException se il token non è valido
     */
    public String getRuoloDaToken(String token) {
        try {
            DecodedJWT jwt = decodificaToken(token);
            return jwt.getClaim("ruolo").asString();
        } catch (Exception e) {
            logger.error("Errore nell'estrazione del ruolo dal token", e);
            throw new JWTVerificationException("Impossibile estrarre il ruolo dal token", e);
        }
    }

    /**
     * Estrae l'ID dell'utente dal token JWT.
     *
     * @param token il token da cui estrarre l'ID
     * @return l'ID dell'utente
     * @throws JWTVerificationException se il token non è valido
     */
    public int getUtenteIdDaToken(String token) {
        try {
            DecodedJWT jwt = decodificaToken(token);
            return Integer.parseInt(jwt.getSubject());
        } catch (Exception e) {
            logger.error("Errore nell'estrazione dell'ID utente dal token", e);
            throw new JWTVerificationException("Impossibile estrarre l'ID utente dal token", e);
        }
    }

    /**
     * Estrae l'username dell'utente dal token JWT.
     *
     * @param token il token da cui estrarre l'username
     * @return l'username dell'utente
     * @throws JWTVerificationException se il token non è valido
     */
    public String getUsernameDaToken(String token) {
        try {
            DecodedJWT jwt = decodificaToken(token);
            return jwt.getClaim("username").asString();
        } catch (Exception e) {
            logger.error("Errore nell'estrazione dell'username dal token", e);
            throw new JWTVerificationException("Impossibile estrarre l'username dal token", e);
        }
    }

    /**
     * Verifica se un token JWT è scaduto.
     *
     * @param token il token da verificare
     * @return true se il token è scaduto, false altrimenti
     */
    public boolean isTokenScaduto(String token) {
        try {
            DecodedJWT jwt = decodificaToken(token);
            return jwt.getExpiresAt().before(new Date());
        } catch (Exception e) {
            logger.error("Errore nella verifica della scadenza del token", e);
            return true;
        }
    }

    /**
     * Estrae un claim specifico dal token JWT.
     *
     * @param token il token da cui estrarre il claim
     * @param claimName il nome del claim da estrarre
     * @return il valore del claim come stringa
     * @throws JWTVerificationException se il token non è valido o il claim non esiste
     */
    public String getClaimFromToken(String token, String claimName) {
        try {
            DecodedJWT jwt = decodificaToken(token);
            String claim = jwt.getClaim(claimName).asString();
            if (claim == null) {
                throw new JWTVerificationException("Claim " + claimName + " non trovato nel token");
            }
            return claim;
        } catch (Exception e) {
            logger.error("Errore nell'estrazione del claim {} dal token", claimName, e);
            throw new JWTVerificationException("Impossibile estrarre il claim dal token", e);
        }
    }

    /**
     * Decodifica un token JWT.
     *
     * @param token il token da decodificare
     * @return il token decodificato
     * @throws JWTVerificationException se il token non è valido
     */
    private DecodedJWT decodificaToken(String token) {
        try {
            return JWT.require(algorithm)
                     .build()
                     .verify(token);
        } catch (Exception e) {
            logger.error("Errore nella decodifica del token JWT", e);
            throw new JWTVerificationException("Token non valido", e);
        }
    }
}

================
File: src/main/java/com/vending/security/JWTUtil.java
================
package com.vending.security;

import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.vending.core.models.Utente;
import java.util.Date;

public class JWTUtil {
    private static final String SECRET = "your-secret-key";
    private static final long EXPIRATION_TIME = 864_000_000; // 10 days
    private final Algorithm algorithm;

    public JWTUtil() {
        this.algorithm = Algorithm.HMAC256(SECRET);
    }

    public String generateToken(Utente utente) {
        return JWT.create()
                .withSubject(String.valueOf(utente.getId()))
                .withClaim("role", utente.getRuolo())
                .withIssuedAt(new Date())
                .withExpiresAt(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
                .sign(algorithm);
    }

    public boolean validateToken(String token) {
        try {
            JWT.require(algorithm).build().verify(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    public String getRoleFromToken(String token) {
        DecodedJWT jwt = JWT.require(algorithm).build().verify(token);
        return jwt.getClaim("role").asString();
    }
}

================
File: src/main/java/com/vending/security/PasswordUtil.java
================
package com.vending.security;

import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.util.Base64;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;

import org.mindrot.jbcrypt.BCrypt;

public class PasswordUtil {
    public String hashPassword(String plainTextPassword) {
        return BCrypt.hashpw(plainTextPassword, BCrypt.gensalt());
    }

    public boolean verifyPassword(String plainTextPassword, String hashedPassword) {
        return BCrypt.checkpw(plainTextPassword, hashedPassword);
    }
    
     public boolean verificaPassword(String password, String passwordUtente) {
       try {
           String[] parts = passwordUtente.split(":");
           byte[] salt = Base64.getDecoder().decode(parts[0]);
           byte[] hashSalvato = Base64.getDecoder().decode(parts[1]);
           byte[] hashCalcolato = generaHash(password.toCharArray(), salt);
           
           return comparaHash(hashSalvato, hashCalcolato);
       } catch (Exception e) {
           throw new RuntimeException("Errore verifica password", e);
       }
   }

   private byte[] generaHash(char[] password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {
       PBEKeySpec spec = new PBEKeySpec(password, salt, 10000, 256);
       SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
       return factory.generateSecret(spec).getEncoded();
   }

   private boolean comparaHash(byte[] hash1, byte[] hash2) {
       if (hash1.length != hash2.length) return false;
       int diff = 0;
       for (int i = 0; i < hash1.length; i++) {
           diff |= hash1[i] ^ hash2[i];
       }
       return diff == 0;
   }
}

================
File: src/main/java/com/vending/ServiceRegistry.java
================
package com.vending;

import java.util.HashMap;
import java.util.Map;

/**
 * Registry per i servizi dell'applicazione
 */
public class ServiceRegistry {
    private static final Map<String, Object> services = new HashMap<>();

    public static void register(String name, Object service) {
        services.put(name, service);
    }

    public static <T> T get(Class<T> serviceClass) {
        return services.values().stream()
                .filter(service -> serviceClass.isInstance(service))
                .map(serviceClass::cast)
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Service not found: " + serviceClass.getName()));
    }

    public static Object get(String name) {
        return services.get(name);
    }
}

================
File: src/main/java/com/vending/utils/config/ConfigUtil.java
================
package com.vending.utils.config;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Utility class per la gestione della configurazione dell'applicazione.
 */
public class ConfigUtil {
    private static final Logger logger = LoggerFactory.getLogger(ConfigUtil.class);

    /**
     * Carica le proprietà da un file di configurazione.
     * Cerca prima nel classpath, poi nella directory corrente.
     *
     * @param filename il nome del file di configurazione
     * @return Properties oggetto contenente le proprietà caricate
     * @throws RuntimeException se il file non può essere caricato
     */
    public static Properties loadProperties(String filename) {
        Properties properties = new Properties();
        boolean loaded = false;

        // Prima prova a caricare dal classpath
        try (InputStream input = ConfigUtil.class.getClassLoader().getResourceAsStream(filename)) {
            if (input != null) {
                properties.load(input);
                loaded = true;
                logger.info("Configurazione caricata dal classpath: {}", filename);
            }
        } catch (IOException e) {
            logger.warn("Impossibile caricare la configurazione dal classpath: {}", e.getMessage());
        }

        // Se non trovato nel classpath, prova nella directory corrente
        if (!loaded) {
            try (FileInputStream input = new FileInputStream(filename)) {
                properties.load(input);
                logger.info("Configurazione caricata dal filesystem: {}", filename);
            } catch (IOException e) {
                logger.error("Impossibile caricare il file di configurazione: {}", filename, e);
                throw new RuntimeException("Impossibile caricare il file di configurazione: " + filename, e);
            }
        }

        // Logga le proprietà caricate (escludendo le password)
        logProperties(properties);

        return properties;
    }

    /**
     * Logga le proprietà caricate, mascherando le informazioni sensibili.
     *
     * @param properties le proprietà da loggare
     */
    private static void logProperties(Properties properties) {
        if (logger.isDebugEnabled()) {
            properties.stringPropertyNames().stream()
                .sorted()
                .forEach(key -> {
                    String value = properties.getProperty(key);
                    // Maschera le password e altre informazioni sensibili
                    if (key.toLowerCase().contains("password") || 
                        key.toLowerCase().contains("secret") ||
                        key.toLowerCase().contains("key")) {
                        value = "********";
                    }
                    logger.debug("{}={}", key, value);
                });
        }
    }

    /**
     * Ottiene una proprietà come stringa, con valore di default.
     *
     * @param properties le proprietà
     * @param key la chiave della proprietà
     * @param defaultValue il valore di default
     * @return il valore della proprietà o il default se non trovata
     */
    public static String getProperty(Properties properties, String key, String defaultValue) {
        String value = properties.getProperty(key);
        if (value == null) {
            logger.debug("Proprietà {} non trovata, uso il default: {}", key, defaultValue);
            return defaultValue;
        }
        return value;
    }

    /**
     * Ottiene una proprietà come intero, con valore di default.
     *
     * @param properties le proprietà
     * @param key la chiave della proprietà
     * @param defaultValue il valore di default
     * @return il valore della proprietà come intero o il default se non trovata/non valida
     */
    public static int getIntProperty(Properties properties, String key, int defaultValue) {
        String value = properties.getProperty(key);
        if (value == null) {
            logger.debug("Proprietà {} non trovata, uso il default: {}", key, defaultValue);
            return defaultValue;
        }
        try {
            return Integer.parseInt(value.trim());
        } catch (NumberFormatException e) {
            logger.warn("Valore non valido per {}: {}, uso il default: {}", key, value, defaultValue);
            return defaultValue;
        }
    }

    /**
     * Ottiene una proprietà come boolean, con valore di default.
     *
     * @param properties le proprietà
     * @param key la chiave della proprietà
     * @param defaultValue il valore di default
     * @return il valore della proprietà come boolean o il default se non trovata
     */
    public static boolean getBooleanProperty(Properties properties, String key, boolean defaultValue) {
        String value = properties.getProperty(key);
        if (value == null) {
            logger.debug("Proprietà {} non trovata, uso il default: {}", key, defaultValue);
            return defaultValue;
        }
        return Boolean.parseBoolean(value.trim());
    }
}

================
File: src/main/java/com/vending/utils/date/DateUtil.java
================
package com.vending.utils.date;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;
import java.util.Date;

public class DateUtil {
    public static final DateTimeFormatter FORMATTER = 
        DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    
    private static final ZoneId DEFAULT_ZONE = ZoneId.systemDefault();

    public static String formattaDateTime(LocalDateTime dateTime) {
        return dateTime.format(FORMATTER);
    }
    public static DateTimeFormatter getFormatter() {
        return FORMATTER;
    }
    public static LocalDateTime parseDateTime(String dateTime) {
        return LocalDateTime.parse(dateTime, FORMATTER);
    }

    public static Date localDateTimeToDate(LocalDateTime localDateTime) {
        return Date.from(localDateTime.atZone(DEFAULT_ZONE).toInstant());
    }

    public static LocalDateTime dateToLocalDateTime(Date date) {
        return LocalDateTime.ofInstant(date.toInstant(), DEFAULT_ZONE);
    }

    public static boolean isScaduto(LocalDateTime dateTime) {
        return dateTime.isBefore(LocalDateTime.now());
    }

    public static long getDifferenzaGiorni(LocalDateTime data1, LocalDateTime data2) {
        return ChronoUnit.DAYS.between(data1, data2);
    }

    public static LocalDateTime inizioGiornata(LocalDateTime dateTime) {
        return dateTime.toLocalDate().atStartOfDay();
    }

    public static LocalDateTime fineGiornata(LocalDateTime dateTime) {
        return dateTime.toLocalDate().atTime(23, 59, 59);
    }
}

================
File: src/main/java/com/vending/utils/log/LogUtil.java
================
package com.vending.utils.log;

import java.io.*;
import java.time.LocalDateTime;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

import com.vending.utils.date.DateUtil;

public class LogUtil {
    private static final String LOG_DIR = "logs";
    private static final BlockingQueue<LogEntry> logQueue = new LinkedBlockingQueue<>();
    private static final Thread loggerThread;
    private static volatile boolean isRunning = true;

    static {
        // Crea directory logs se non esiste
        new File(LOG_DIR).mkdirs();

        // Inizializza thread di logging
        loggerThread = new Thread(() -> {
            while (isRunning || !logQueue.isEmpty()) {
                try {
                    LogEntry entry = logQueue.poll(100, TimeUnit.MILLISECONDS);
                    if (entry != null) {
                        scriviLog(entry);
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        });
        loggerThread.setDaemon(true);
        loggerThread.start();
    }

    public static void info(String message) {
        aggiungiLog(new LogEntry(LogLevel.INFO, message));
    }

    public static void warning(String message) {
        aggiungiLog(new LogEntry(LogLevel.WARNING, message));
    }

    public static void error(String message, Throwable throwable) {
        StringBuilder sb = new StringBuilder();
        sb.append(message).append("\n");
        sb.append("Exception: ").append(throwable.getMessage()).append("\n");
        for (StackTraceElement element : throwable.getStackTrace()) {
            sb.append("\tat ").append(element.toString()).append("\n");
        }
        aggiungiLog(new LogEntry(LogLevel.ERROR, sb.toString()));
    }

    public static void debug(String message) {
        aggiungiLog(new LogEntry(LogLevel.DEBUG, message));
    }

    private static void aggiungiLog(LogEntry entry) {
        try {
            logQueue.put(entry);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    private static void scriviLog(LogEntry entry) {
        String nomeFile = LOG_DIR + File.separator + 
            LocalDateTime.now().toLocalDate() + ".log";
            
        try (PrintWriter writer = new PrintWriter(new FileWriter(nomeFile, true))) {
            writer.println(entry.toString());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void shutdown() {
        isRunning = false;
        loggerThread.interrupt();
        try {
            loggerThread.join(5000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    private static class LogEntry {
        private final LogLevel level;
        private final String message;
        private final LocalDateTime timestamp;

        public LogEntry(LogLevel level, String message) {
            this.level = level;
            this.message = message;
            this.timestamp = LocalDateTime.now();
        }

        @Override
        public String toString() {
            return String.format("[%s] %s - %s",
                timestamp.format(DateUtil.FORMATTER),
                level,
                message);
        }
    }

    private enum LogLevel {
        DEBUG, INFO, WARNING, ERROR
    }
}

================
File: src/main/java/com/vending/utils/money/MoneyUtil.java
================
package com.vending.utils.money;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.text.NumberFormat;
import java.util.Locale;
import java.util.Currency;

public class MoneyUtil {
    private static final Currency EUR = Currency.getInstance("EUR");
    private static final NumberFormat FORMATTER = NumberFormat.getCurrencyInstance(Locale.ITALY);
    private static final double[] MONETE_VALIDE = {0.05, 0.10, 0.20, 0.50, 1.00, 2.00};

    public static BigDecimal arrotondaDueDecimali(BigDecimal importo) {
        return importo.setScale(2, RoundingMode.HALF_UP);
    }

    public static String formattaValuta(BigDecimal importo) {
        return FORMATTER.format(importo);
    }

    public static BigDecimal parseImporto(String importo) {
        try {
            String cleaned = importo.replace(EUR.getSymbol(), "")
                                  .replace(".", "")
                                  .replace(",", ".");
            return new BigDecimal(cleaned).setScale(2, RoundingMode.HALF_UP);
        } catch (Exception e) {
            throw new IllegalArgumentException("Formato importo non valido");
        }
    }

    public static boolean isMonetaValida(double importo) {
        for (double moneta : MONETE_VALIDE) {
            if (Math.abs(importo - moneta) < 0.001) {
                return true;
            }
        }
        return false;
    }

    public static BigDecimal calcolaResto(BigDecimal importoPagato, BigDecimal importoDovuto) {
        if (importoPagato.compareTo(importoDovuto) < 0) {
            throw new IllegalArgumentException("Importo pagato insufficiente");
        }
        return arrotondaDueDecimali(importoPagato.subtract(importoDovuto));
    }
}

================
File: src/main/java/com/vending/utils/validation/ValidationUtil.java
================
package com.vending.utils.validation;

import java.util.regex.Pattern;
import java.math.BigDecimal;

public class ValidationUtil {
    private static final Pattern EMAIL_PATTERN = Pattern.compile(
        "^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,6}$", 
        Pattern.CASE_INSENSITIVE
    );
    
    private static final Pattern PHONE_PATTERN = Pattern.compile(
        "^\\+?[0-9]{10,13}$"
    );

    private static final Pattern PASSWORD_PATTERN = Pattern.compile(
        "^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&+=])(?=\\S+$).{8,}$"
    );

    public static boolean isValidEmail(String email) {
        return email != null && EMAIL_PATTERN.matcher(email).matches();
    }

    public static boolean isValidPhone(String phone) {
        return phone != null && PHONE_PATTERN.matcher(phone).matches();
    }

    public static boolean isValidPassword(String password) {
        return password != null && PASSWORD_PATTERN.matcher(password).matches();
    }

    public static boolean isValidImporto(BigDecimal importo) {
        return importo != null && importo.compareTo(BigDecimal.ZERO) > 0 
            && importo.scale() <= 2;
    }

    public static boolean isValidQuantita(int quantita) {
        return quantita >= 0;
    }

    public static boolean isValidPercentuale(double percentuale) {
        return percentuale >= 0 && percentuale <= 100;
    }

    public static String sanitizeInput(String input) {
        if (input == null) return null;
        // Rimuove caratteri pericolosi e XSS
        return input.replaceAll("[<>\"'%;()&+]", "");
    }

    public static String normalizeString(String input) {
        if (input == null) return null;
        return input.trim().toLowerCase();
    }
}
