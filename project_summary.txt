This file is a merged representation of the entire codebase, combining all repository files into a single document.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.classpath
.project
pom.xml
src/main/java/com/vending/api/controllers/AuthController.java
src/main/java/com/vending/api/controllers/BevandaController.java
src/main/java/com/vending/api/controllers/IstitutoController.java
src/main/java/com/vending/api/controllers/MacchinaController.java
src/main/java/com/vending/api/controllers/ManutenzioneController.java
src/main/java/com/vending/api/controllers/PublicController.java
src/main/java/com/vending/api/controllers/UtenteController.java
src/main/java/com/vending/api/middleware/AuthMiddleware.java
src/main/java/com/vending/api/middleware/CORSMiddleware.java
src/main/java/com/vending/api/middleware/LogMiddleware.java
src/main/java/com/vending/api/routes/Routes.java
src/main/java/com/vending/config.properties
src/main/java/com/vending/core/models/AdminLogin.java
src/main/java/com/vending/core/models/Bevanda.java
src/main/java/com/vending/core/models/Cialda.java
src/main/java/com/vending/core/models/Credenziale.java
src/main/java/com/vending/core/models/Istituto.java
src/main/java/com/vending/core/models/Macchina.java
src/main/java/com/vending/core/models/Manutenzione.java
src/main/java/com/vending/core/models/QuantitaCialde.java
src/main/java/com/vending/core/models/Ricavo.java
src/main/java/com/vending/core/models/StatoMacchina.java
src/main/java/com/vending/core/models/Transazione.java
src/main/java/com/vending/core/models/Utente.java
src/main/java/com/vending/core/repositories/AdminLoginRepository.java
src/main/java/com/vending/core/repositories/BevandaRepository.java
src/main/java/com/vending/core/repositories/CialdaRepository.java
src/main/java/com/vending/core/repositories/DatabaseConnection.java
src/main/java/com/vending/core/repositories/IstitutoRepository.java
src/main/java/com/vending/core/repositories/MacchinaRepository.java
src/main/java/com/vending/core/repositories/ManutenzioneRepository.java
src/main/java/com/vending/core/repositories/RicavoRepository.java
src/main/java/com/vending/core/repositories/TransazioneRepository.java
src/main/java/com/vending/core/repositories/UtenteRepository.java
src/main/java/com/vending/core/services/AdminLoginService.java
src/main/java/com/vending/core/services/BevandaService.java
src/main/java/com/vending/core/services/IstitutoService.java
src/main/java/com/vending/core/services/MacchinaService.java
src/main/java/com/vending/core/services/ManutenzioneService.java
src/main/java/com/vending/core/services/RicavoService.java
src/main/java/com/vending/core/services/TransazioneService.java
src/main/java/com/vending/core/services/UtenteService.java
src/main/java/com/vending/iot/bridge/BridgeConfig.java
src/main/java/com/vending/iot/bridge/MQTTBridge.java
src/main/java/com/vending/iot/bridge/TopicManager.java
src/main/java/com/vending/iot/machines/GestoreBevande.java
src/main/java/com/vending/iot/machines/GestoreCassa.java
src/main/java/com/vending/iot/machines/GestoreCialde.java
src/main/java/com/vending/iot/machines/GestoreManutenzione.java
src/main/java/com/vending/iot/machines/MacchinaPrincipale.java
src/main/java/com/vending/iot/monitor/AlertManager.java
src/main/java/com/vending/iot/monitor/Allarme.java
src/main/java/com/vending/iot/monitor/MonitorMacchine.java
src/main/java/com/vending/iot/monitor/StatoMacchina.java
src/main/java/com/vending/iot/mqtt/MessageHandler.java
src/main/java/com/vending/iot/mqtt/MQTTClient.java
src/main/java/com/vending/iot/mqtt/MQTTConfig.java
src/main/java/com/vending/Main.java
src/main/java/com/vending/MainV1.java
src/main/java/com/vending/security/auth/AuthenticationService.java
src/main/java/com/vending/security/auth/AuthorizationException.java
src/main/java/com/vending/security/auth/AuthorizationService.java
src/main/java/com/vending/security/auth/PasswordService.java
src/main/java/com/vending/security/config/SecurityConfig.java
src/main/java/com/vending/security/encryption/EncryptionService.java
src/main/java/com/vending/security/jwt/JWTService.java
src/main/java/com/vending/security/JWTUtil.java
src/main/java/com/vending/security/PasswordUtil.java
src/main/java/com/vending/ServiceRegistry.java
src/main/java/com/vending/utils/config/ConfigUtil.java
src/main/java/com/vending/utils/date/DateUtil.java
src/main/java/com/vending/utils/date/LocalDateTimeTypeAdapter.java
src/main/java/com/vending/utils/log/LogUtil.java
src/main/java/com/vending/utils/money/MoneyUtil.java
src/main/java/com/vending/utils/validation/ValidationUtil.java
src/main/resources/config.properties
src/main/resources/public/css/admin.css
src/main/resources/public/css/client.css
src/main/resources/public/css/reports.css
src/main/resources/public/css/style.css
src/main/resources/public/homepage.html
src/main/resources/public/index.html
src/main/resources/public/js/admin/dashboard.js
src/main/resources/public/js/admin/institutes.js
src/main/resources/public/js/admin/machines.js
src/main/resources/public/js/admin/maintenance.js
src/main/resources/public/js/admin/pods.js
src/main/resources/public/js/admin/reports.js
src/main/resources/public/js/client/beverageSelection.js
src/main/resources/public/js/client/machineSelection.js
src/main/resources/public/js/client/payment.js
src/main/resources/public/js/common/auth-utils.js
src/main/resources/public/js/common/authentication.js
src/main/resources/public/js/common/mqtt.js
src/main/resources/public/js/common/utils.js
src/main/resources/public/pages/admin/dash_admin.html
src/main/resources/public/pages/admin/dash_impiegati.html
src/main/resources/public/pages/admin/dashboard.html
src/main/resources/public/pages/admin/institutes.html
src/main/resources/public/pages/admin/machines.html
src/main/resources/public/pages/admin/maintenance.html
src/main/resources/public/pages/admin/MonitorMacchine.html
src/main/resources/public/pages/admin/pods.html
src/main/resources/public/pages/admin/reports.html
src/main/resources/public/pages/admin/reports1.html
src/main/resources/public/pages/client/beverageInterface.html
src/main/resources/public/pages/client/login.html
src/main/resources/public/pages/client/machineSelection.html
src/main/resources/public/pages/client/register.html

================================================================
Files
================================================================

================
File: .classpath
================
<?xml version="1.0" encoding="UTF-8"?>
<classpath>
	<classpathentry excluding="**" kind="src" output="target/classes" path="src/main/resources">
		<attributes>
			<attribute name="maven.pomderived" value="true"/>
			<attribute name="optional" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry excluding="**" kind="src" output="target/test-classes" path="src/test/resources">
		<attributes>
			<attribute name="test" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
			<attribute name="optional" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-17">
		<attributes>
			<attribute name="maven.pomderived" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="con" path="org.eclipse.m2e.MAVEN2_CLASSPATH_CONTAINER">
		<attributes>
			<attribute name="maven.pomderived" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="src" output="target/classes" path="src/main/java">
		<attributes>
			<attribute name="optional" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="src" output="target/test-classes" path="src/test/java">
		<attributes>
			<attribute name="test" value="true"/>
			<attribute name="optional" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="src" path="target/generated-sources/annotations">
		<attributes>
			<attribute name="ignore_optional_problems" value="true"/>
			<attribute name="optional" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
			<attribute name="m2e-apt" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
	<classpathentry kind="src" output="target/test-classes" path="target/generated-test-sources/test-annotations">
		<attributes>
			<attribute name="optional" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
			<attribute name="ignore_optional_problems" value="true"/>
			<attribute name="m2e-apt" value="true"/>
			<attribute name="test" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="output" path="target/classes"/>
</classpath>

================
File: .project
================
<?xml version="1.0" encoding="UTF-8"?>
<projectDescription>
	<name>mqtt_20019309</name>
	<comment></comment>
	<projects>
	</projects>
	<buildSpec>
		<buildCommand>
			<name>org.eclipse.jdt.core.javabuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.eclipse.m2e.core.maven2Builder</name>
			<arguments>
			</arguments>
		</buildCommand>
	</buildSpec>
	<natures>
		<nature>org.eclipse.jdt.core.javanature</nature>
		<nature>org.eclipse.m2e.core.maven2Nature</nature>
	</natures>
	<filteredResources>
		<filter>
			<id>1735039323762</id>
			<name></name>
			<type>30</type>
			<matcher>
				<id>org.eclipse.core.resources.regexFilterMatcher</id>
				<arguments>node_modules|\.git|__CREATED_BY_JAVA_LANGUAGE_SERVER__</arguments>
			</matcher>
		</filter>
	</filteredResources>
</projectDescription>

================
File: pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.vending</groupId>
    <artifactId>Progetto_Pissir</artifactId>
    <version>1.0-SNAPSHOT</version>
    
    <properties>
        <maven.compiler.source>17</maven.compiler.source>
    	<maven.compiler.target>17</maven.compiler.target>
        <spark.version>2.9.4</spark.version>
        <paho.version>1.2.5</paho.version>
        <mysql.version>8.0.33</mysql.version>
        <gson.version>2.10.1</gson.version>
        <slf4j.version>2.0.9</slf4j.version>
        <junit.version>5.10.0</junit.version>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <!-- Spark Core for REST API -->
        <dependency>
            <groupId>com.sparkjava</groupId>
            <artifactId>spark-core</artifactId>
            <version>${spark.version}</version>
        </dependency>

        <!-- MQTT Client -->
        <dependency>
            <groupId>org.eclipse.paho</groupId>
            <artifactId>org.eclipse.paho.client.mqttv3</artifactId>
            <version>${paho.version}</version>
        </dependency>

        <!-- MySQL Connector -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>${mysql.version}</version>
        </dependency>

        <!-- JSON Processing -->
        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
            <version>${gson.version}</version>
        </dependency>

        <!-- Logging -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>${slf4j.version}</version>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-simple</artifactId>
            <version>${slf4j.version}</version>
        </dependency>

        <!-- Testing -->
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-api</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>

        <!-- JWT for Authentication -->
        <dependency>
            <groupId>com.auth0</groupId>
            <artifactId>java-jwt</artifactId>
            <version>4.4.0</version>
        </dependency>

        <!-- BCrypt for Password Hashing -->
        <dependency>
            <groupId>org.mindrot</groupId>
            <artifactId>jbcrypt</artifactId>
            <version>0.4</version>
        </dependency>
        <dependency>
        	<groupId>20019309</groupId>
        	<artifactId>20019309P</artifactId>
        	<version>0.0.1-SNAPSHOT</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>${maven.compiler.source}</source>
                    <target>${maven.compiler.target}</target>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.5.0</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <transformers>
                                <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                                    <mainClass>com.vending.Application</mainClass>
                                </transformer>
                            </transformers>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>

================
File: src/main/java/com/vending/api/controllers/AuthController.java
================
package com.vending.api.controllers;

import com.google.gson.Gson;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.vending.Main;
import com.vending.core.models.AdminLogin;
import com.vending.core.models.Utente;
import com.vending.core.services.AdminLoginService;
import com.vending.core.services.UtenteService;
import com.vending.security.jwt.JWTService;
import spark.Request;
import spark.Response;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;

/**
 * Controller responsabile della gestione delle richieste HTTP relative
 * all'autenticazione.
 * Gestisce le operazioni di login, registrazione e gestione token per gli
 * utenti del sistema.
 * 
 * <p>
 * Questo controller utilizza:
 * <ul>
 * <li>{@link AdminLoginService} per la gestione dell'autenticazione e delle
 * credenziali</li>
 * <li>{@link UtenteService} per la gestione degli utenti</li>
 * <li>{@link JWTService} per la generazione e validazione dei token JWT</li>
 * </ul>
 * </p>
 */
public class AuthController {
    private static final Logger logger = LoggerFactory.getLogger(Main.class);
    private final AdminLoginService adminLoginService;
    private final UtenteService utenteService;
    private final JWTService jwtService;
    private final Gson gson;

    /**
     * Costruisce un nuovo AuthController.
     * 
     * @param adminLoginService il servizio per la gestione degli accessi
     *                          amministrativi
     * @param utenteService     il servizio per la gestione degli utenti
     */
    public AuthController(AdminLoginService adminLoginService, UtenteService utenteService) {
        this.adminLoginService = adminLoginService;
        this.utenteService = utenteService;
        this.jwtService = new JWTService();
        this.gson = new Gson();
    }

    /**
     * Gestisce le richieste di login degli utenti.
     * 
     * <p>
     * Questa operazione si aspetta una richiesta POST con un corpo JSON contenente:
     * <ul>
     * <li>username: String - nome utente per l'accesso</li>
     * <li>password: String - password dell'utente</li>
     * </ul>
     * </p>
     * 
     * <p>
     * La risposta può essere:
     * <ul>
     * <li>200 OK: login riuscito, con token JWT e informazioni utente</li>
     * <li>400 Bad Request: dati mancanti o non validi</li>
     * <li>401 Unauthorized: credenziali non valide</li>
     * <li>500 Internal Server Error: errore interno del server</li>
     * </ul>
     * </p>
     *
     * @param req la richiesta HTTP contenente le credenziali
     * @param res la risposta HTTP da inviare al client
     * @return oggetto JSON contenente il risultato dell'operazione
     */
    public Object login(Request req, Response res) {
        try {
            Map<String, String> body = gson.fromJson(req.body(), Map.class);
            String username = body.get("username");
            String password = body.get("password");

            if (username == null || username.isEmpty() || password == null || password.isEmpty()) {
                res.status(400);
                return gson.toJson(Map.of("errore", "Username e password sono obbligatori"));
            }

            Optional<AdminLogin> loginResult = adminLoginService.autenticaUtente(username, password);

            if (loginResult.isPresent()) {
                AdminLogin login = loginResult.get();
                Utente utente = login.getUtente();
                String token = jwtService.generaToken(utente);

                Map<String, String> response = new HashMap<>();
                response.put("token", token);
                response.put("ruolo", utente.getRuolo());
                response.put("username", login.getUsername());

                res.status(200);
                return gson.toJson(response);
            } else {
                res.status(401);
                return gson.toJson(Map.of("errore", "Credenziali non valide"));
            }
        } catch (Exception e) {
            logger.error("Errore durante il login", e);
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore interno del server"));
        }
    }

    /**
     * Gestisce le richieste di registrazione di nuovi utenti.
     * 
     * <p>
     * Questa operazione si aspetta una richiesta POST con un corpo JSON contenente:
     * <ul>
     * <li>nome: String - nome completo dell'utente</li>
     * <li>username: String - nome utente desiderato per l'accesso</li>
     * <li>password: String - password desiderata</li>
     * <li>ruolo: String - ruolo dell'utente nel sistema</li>
     * </ul>
     * </p>
     * 
     * <p>
     * La risposta può essere:
     * <ul>
     * <li>201 Created: registrazione riuscita, con dettagli utente</li>
     * <li>400 Bad Request: dati mancanti o non validi</li>
     * <li>500 Internal Server Error: errore interno del server</li>
     * </ul>
     * </p>
     *
     * @param req la richiesta HTTP contenente i dati di registrazione
     * @param res la risposta HTTP da inviare al client
     * @return oggetto JSON contenente il risultato dell'operazione
     */
    public Object registrazione(Request req, Response res) {
        try {
            Map<String, String> body = gson.fromJson(req.body(), Map.class);
            String nome = body.get("nome");
            String username = body.get("username");
            String password = body.get("password");
            String ruolo = body.get("ruolo");

            if (nome == null || username == null || password == null || ruolo == null) {
                res.status(400);
                return gson.toJson(Map.of("errore", "Tutti i campi sono obbligatori"));
            }

            if (!adminLoginService.isUsernameDisponibile(username)) {
                res.status(400);
                return gson.toJson(Map.of("errore", "Username già in uso"));
            }

            int idRuolo = utenteService.trovaIdRuolo(ruolo);
            if (idRuolo == -1) {
                res.status(400);
                return gson.toJson(Map.of("errore", "Ruolo non valido"));
            }

            Utente nuovoUtente = new Utente();
            nuovoUtente.setNome(nome);
            nuovoUtente.setUsername(username);
            nuovoUtente.setPassword(password);
            nuovoUtente.setRuoloId(idRuolo);
            if (ruolo == "1" || ruolo == "tecnico" || ruolo == "Tecnico") {
                nuovoUtente.setRuolo("Tecnico");
            }
            if (ruolo == "2" || ruolo == "amministratore" || ruolo == "Amministratore") {
                nuovoUtente.setRuolo("Amministratore");
            }
            if (ruolo == "3" || ruolo == "operatore" || ruolo == "Operatore") {
                nuovoUtente.setRuolo("Operatore");
            }

            Utente utenteSalvato = utenteService.creaUtente(nuovoUtente);
            AdminLogin accessoCreato = adminLoginService.creaAccessoAmministrativo(
                    utenteSalvato.getId(),
                    username,
                    password);

            Map<String, Object> response = new HashMap<>();
            response.put("utente", utenteSalvato);
            response.put("username", accessoCreato.getUsername());

            res.status(201);
            return gson.toJson(response);

        } catch (IllegalArgumentException e) {
            logger.warn("Errore di validazione durante la registrazione", e);
            res.status(400);
            return gson.toJson(Map.of("errore", e.getMessage()));
        } catch (Exception e) {
            logger.error("Errore durante la registrazione", e);
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore interno del server"));
        }
    }

    /**
     * Verifica la validità di un token JWT.
     * 
     * <p>
     * Questa operazione si aspetta un header 'Authorization'
     * contenente il token JWT nel formato 'Bearer {token}'.
     * </p>
     *
     * @param req la richiesta HTTP contenente il token da verificare
     * @param res la risposta HTTP da inviare al client
     * @return oggetto JSON contenente il risultato della verifica
     */
    public Object verificaToken(Request req, Response res) {
        try {
            String token = req.headers("Authorization");

            if (token == null || !token.startsWith("Bearer ")) {
                res.status(401);
                return gson.toJson(Map.of("errore", "Token mancante o non valido"));
            }

            token = token.substring(7);
            boolean isValid = jwtService.verificaToken(token);

            if (!isValid) {
                res.status(401);
                return gson.toJson(Map.of("errore", "Token non valido"));
            }

            res.type("application/json");
            return gson.toJson(Map.of("valido", true));

        } catch (Exception e) {
            logger.error("Errore durante la verifica del token", e);
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nella verifica del token"));
        }
    }

    /**
     * Genera un nuovo token di accesso anonimo.
     * Utile per accessi temporanei o funzionalità limitate.
     *
     * @param req la richiesta HTTP
     * @param res la risposta HTTP da inviare al client
     * @return oggetto JSON contenente il token anonimo generato
     */
    public Object getAnonymousToken(Request req, Response res) {
        try {
            Map<String, Object> claims = new HashMap<>();
            claims.put("id", "anonymous_" + UUID.randomUUID().toString());
            claims.put("role", "anonymous");
            claims.put("createdAt", System.currentTimeMillis());

            String token = jwtService.generateAnonymousToken(claims);

            Map<String, Object> response = new HashMap<>();
            response.put("token", token);
            response.put("role", "anonymous");

            res.type("application/json");
            res.status(200);
            return gson.toJson(response);
        } catch (Exception e) {
            logger.error("Errore nella generazione del token anonimo", e);
            res.status(500);
            return gson.toJson(Map.of("error", "Errore nella generazione del token anonimo"));
        }
    }

    /**
     * Rinnova un token JWT esistente.
     * Verifica la validità del token attuale e ne genera uno nuovo se valido.
     * 
     * <p>
     * Questa operazione richiede un token valido nell'header Authorization
     * nel formato 'Bearer {token}'
     * </p>
     *
     * <p>
     * La risposta può essere:
     * <ul>
     * <li>200 OK: token rinnovato con successo</li>
     * <li>401 Unauthorized: token non valido o scaduto</li>
     * <li>500 Internal Server Error: errore durante il rinnovo</li>
     * </ul>
     * </p>
     *
     * @param req la richiesta HTTP contenente il token da rinnovare
     * @param res la risposta HTTP
     * @return oggetto JSON contenente il nuovo token o un messaggio di errore
     */
    public Object refreshToken(Request req, Response res) {
        try {
            String token = req.headers("Authorization");

            if (token == null || !token.startsWith("Bearer ")) {
                res.status(401);
                return gson.toJson(Map.of("errore", "Token mancante o non valido"));
            }

            token = token.substring(7); // Rimuove "Bearer "

            // Verifica la validità del token
            if (!jwtService.verificaToken(token)) {
                res.status(401);
                return gson.toJson(Map.of("errore", "Token non valido"));
            }

            // Estrae l'ID utente dal token
            int userId = jwtService.getUtenteIdDaToken(token);

            // Recupera i dati di login dell'utente
            Optional<AdminLogin> loginOpt = adminLoginService.getAccessoPerUtente(userId);

            if (loginOpt.isEmpty()) {
                res.status(401);
                return gson.toJson(Map.of("errore", "Utente non trovato"));
            }

            AdminLogin login = loginOpt.get();
            Utente utente = login.getUtente();

            // Aggiorna l'ultimo accesso
            login.aggiornaUltimoAccesso();
            // adminLoginRepository.updateUltimoAccesso(login);

            // Genera un nuovo token
            String nuovoToken = jwtService.generaToken(utente);

            // Prepara la risposta
            Map<String, Object> response = new HashMap<>();
            response.put("token", nuovoToken);
            response.put("ruolo", utente.getRuolo());
            response.put("username", login.getUsername());
            response.put("timestamp", System.currentTimeMillis());

            res.type("application/json");
            res.status(200);
            return gson.toJson(response);

        } catch (Exception e) {
            logger.error("Errore nel refresh del token", e);
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel refresh del token: " + e.getMessage()));
        }
    }
}

================
File: src/main/java/com/vending/api/controllers/BevandaController.java
================
package com.vending.api.controllers;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.vending.core.models.Bevanda;
import com.vending.core.models.Macchina;
import com.vending.core.models.QuantitaCialde;
import com.vending.core.services.BevandaService;
import spark.Request;
import spark.Response;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Controller per la gestione delle richieste HTTP relative alle bevande.
 */
public class BevandaController {
    private final BevandaService bevandaService;
    private final Gson gson;

    /**
     * Costruttore del controller.
     *
     * @param bevandaService servizio per la gestione delle bevande
     */
    public BevandaController(BevandaService bevandaService) {
        this.bevandaService = bevandaService;
        this.gson = new Gson();
    }

    /**
     * Recupera tutte le bevande.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return lista JSON delle bevande
     */
    public Object getAll(Request req, Response res) {
        try {
            List<Bevanda> bevande = bevandaService.getTutteBevande();
            res.type("application/json");
            return gson.toJson(bevande);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero delle bevande: " + e.getMessage()));
        }
    }

    /**
     * Recupera una bevanda tramite ID.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return JSON della bevanda
     */
    public Object getById(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            Optional<Bevanda> bevanda = bevandaService.getBevandaById(id);

            if (bevanda.isPresent()) {
                res.type("application/json");
                return gson.toJson(bevanda.get());
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Bevanda non trovata"));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero della bevanda: " + e.getMessage()));
        }
    }
    
    /**
     * Crea una nuova bevanda.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return JSON della bevanda creata
     */
    public Object create(Request req, Response res) {
        try {
            Type requestType = new TypeToken<Map<String, Object>>() {
            }.getType();
            Map<String, Object> requestData = gson.fromJson(req.body(), requestType);

            String nome = (String) requestData.get("nome");
            Double prezzo = ((Number) requestData.get("prezzo")).doubleValue();
            @SuppressWarnings("unchecked")
            List<Integer> cialdeIds = (List<Integer>) requestData.get("cialdeIds");

            if (nome == null || prezzo == null || cialdeIds == null) {
                res.status(400);
                return gson.toJson(Map.of("errore", "Parametri mancanti"));
            }

            Bevanda nuovaBevanda = bevandaService.creaBevanda(nome, prezzo, cialdeIds);
            res.status(201);
            res.type("application/json");
            return gson.toJson(nuovaBevanda);
        } catch (IllegalArgumentException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", e.getMessage()));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nella creazione della bevanda: " + e.getMessage()));
        }
    }

    /**
     * Aggiorna una bevanda esistente.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return JSON della bevanda aggiornata
     */
    public Object update(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            Type requestType = new TypeToken<Map<String, Object>>() {
            }.getType();
            Map<String, Object> requestData = gson.fromJson(req.body(), requestType);

            String nome = (String) requestData.get("nome");
            Double prezzo = requestData.get("prezzo") != null ? ((Number) requestData.get("prezzo")).doubleValue()
                    : null;
            @SuppressWarnings("unchecked")
            List<Integer> cialdeIds = (List<Integer>) requestData.get("cialdeIds");

            try {
                Bevanda bevandaAggiornata = bevandaService.aggiornaBevanda(id, nome, prezzo, cialdeIds);
                res.type("application/json");
                return gson.toJson(bevandaAggiornata);
            } catch (IllegalArgumentException e) {
                res.status(404);
                return gson.toJson(Map.of("errore", e.getMessage()));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'aggiornamento della bevanda: " + e.getMessage()));
        }
    }

    /**
     * Elimina una bevanda.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return risposta vuota o errore
     */
    public Object delete(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            if (bevandaService.eliminaBevanda(id)) {
                res.status(204);
                return "";
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Bevanda non trovata"));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'eliminazione della bevanda: " + e.getMessage()));
        }
    }

    /**
     * Aggiunge una cialda a una bevanda.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return risposta vuota o errore
     */
    @SuppressWarnings("unused")
    public Object aggiungiCialda(Request req, Response res) {
        try {
            int bevandaId = Integer.parseInt(req.params(":id"));
            Type requestType = new TypeToken<Map<String, Object>>() {
            }.getType();
            Map<String, Object> requestData = gson.fromJson(req.body(), requestType);

            Integer cialdaId = ((Number) requestData.get("cialdaId")).intValue();
            if (cialdaId == null) {
                res.status(400);
                return gson.toJson(Map.of("errore", "ID cialda mancante"));
            }

            bevandaService.aggiungiCialda(bevandaId, cialdaId);
            res.status(204);
            return "";
        } catch (IllegalArgumentException e) {
            res.status(404);
            return gson.toJson(Map.of("errore", e.getMessage()));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'aggiunta della cialda: " + e.getMessage()));
        }
    }

    /**
     * Rimuove una cialda da una bevanda.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return risposta vuota o errore
     */
    public Object rimuoviCialda(Request req, Response res) {
        try {
            int bevandaId = Integer.parseInt(req.params(":id"));
            int cialdaId = Integer.parseInt(req.params(":cialdaId"));

            bevandaService.rimuoviCialda(bevandaId, cialdaId);
            res.status(204);
            return "";
        } catch (IllegalArgumentException e) {
            res.status(404);
            return gson.toJson(Map.of("errore", e.getMessage()));
        } catch (IllegalStateException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", e.getMessage()));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nella rimozione della cialda: " + e.getMessage()));
        }
    }
}

================
File: src/main/java/com/vending/api/controllers/IstitutoController.java
================
package com.vending.api.controllers;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.vending.core.models.Istituto;
import com.vending.core.models.Macchina;
import com.vending.core.repositories.IstitutoRepository;
import com.vending.core.repositories.MacchinaRepository;
import spark.Request;
import spark.Response;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Controller per la gestione delle richieste HTTP relative agli istituti.
 */
public class IstitutoController {
    private final IstitutoRepository istitutoRepository;
    private final MacchinaRepository macchinaRepository;
    private final Gson gson;

    /**
     * Costruttore del controller.
     *
     * @param istitutoRepository repository per gli istituti
     * @param macchinaRepository repository per le macchine
     */
    public IstitutoController(IstitutoRepository istitutoRepository, MacchinaRepository macchinaRepository) {
        this.istitutoRepository = istitutoRepository;
        this.macchinaRepository = macchinaRepository;
        this.gson = new Gson();
    }

    /**
     * Recupera tutti gli istituti.
     */
    public Object getAll(Request req, Response res) {
        try {
            List<Istituto> istituti = istitutoRepository.findAll();
            res.type("application/json");
            return gson.toJson(istituti);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero degli istituti: " + e.getMessage()));
        }
    }

    /**
     * Recupera un istituto tramite ID.
     */
    public Object getById(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            Optional<Istituto> istituto = istitutoRepository.findById(id);

            if (istituto.isPresent()) {
                Map<String, Object> response = new HashMap<>();
                response.put("istituto", istituto.get());
                response.put("macchineAttive", istitutoRepository.contaMacchineAttive(id));

                res.type("application/json");
                return gson.toJson(response);
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Istituto non trovato"));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero dell'istituto: " + e.getMessage()));
        }
    }

    /**
     * Crea un nuovo istituto.
     */
    public Object create(Request req, Response res) {
        try {
            Type requestType = new TypeToken<Map<String, String>>() {
            }.getType();
            Map<String, String> requestData = gson.fromJson(req.body(), requestType);

            String nome = requestData.get("nome");
            String indirizzo = requestData.get("indirizzo");

            if (nome == null || nome.trim().isEmpty() || indirizzo == null || indirizzo.trim().isEmpty()) {
                res.status(400);
                return gson.toJson(Map.of("errore", "Nome e indirizzo sono obbligatori"));
            }

            if (istitutoRepository.existsByNome(nome)) {
                res.status(400);
                return gson.toJson(Map.of("errore", "Esiste già un istituto con questo nome"));
            }

            Istituto istituto = new Istituto();
            istituto.setNome(nome);
            istituto.setIndirizzo(indirizzo);

            Istituto created = istitutoRepository.save(istituto);
            res.status(201);
            res.type("application/json");
            return gson.toJson(created);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nella creazione dell'istituto: " + e.getMessage()));
        }
    }

    /**
     * Aggiorna un istituto esistente.
     */
    public Object update(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            Optional<Istituto> esistente = istitutoRepository.findById(id);

            if (esistente.isEmpty()) {
                res.status(404);
                return gson.toJson(Map.of("errore", "Istituto non trovato"));
            }

            Type requestType = new TypeToken<Map<String, String>>() {
            }.getType();
            Map<String, String> requestData = gson.fromJson(req.body(), requestType);

            Istituto istituto = esistente.get();
            String nuovoNome = requestData.get("nome");
            String nuovoIndirizzo = requestData.get("indirizzo");

            if (nuovoNome != null && !nuovoNome.equals(istituto.getNome())) {
                if (istitutoRepository.existsByNome(nuovoNome)) {
                    res.status(400);
                    return gson.toJson(Map.of("errore", "Esiste già un istituto con questo nome"));
                }
                istituto.setNome(nuovoNome);
            }

            if (nuovoIndirizzo != null) {
                istituto.setIndirizzo(nuovoIndirizzo);
            }

            Istituto updated = istitutoRepository.update(istituto);
            res.type("application/json");
            return gson.toJson(updated);
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'aggiornamento dell'istituto: " + e.getMessage()));
        }
    }

    /**
     * Elimina un istituto.
     */
    public Object delete(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            try {
                boolean deleted = istitutoRepository.delete(id);
                if (deleted) {
                    res.status(204);
                    return "";
                } else {
                    res.status(404);
                    return gson.toJson(Map.of("errore", "Istituto non trovato"));
                }
            } catch (IllegalStateException e) {
                res.status(400);
                return gson.toJson(Map.of("errore", e.getMessage()));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'eliminazione dell'istituto: " + e.getMessage()));
        }
    }
}

================
File: src/main/java/com/vending/api/controllers/MacchinaController.java
================
package com.vending.api.controllers;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.vending.core.models.*;
import com.vending.core.repositories.MacchinaRepository;
import com.vending.core.repositories.BevandaRepository;

import spark.Request;
import spark.Response;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Controller per la gestione delle richieste HTTP relative alle macchine
 * distributrici.
 */
public class MacchinaController {
    private final MacchinaRepository macchinaRepository;
    private final BevandaRepository bevandaRepository;
    private final Gson gson;

    /**
     * Costruttore del controller.
     *
     * @param macchinaRepository repository per le macchine
     */
    public MacchinaController(MacchinaRepository macchinaRepository, BevandaRepository bevandaRepository) {
        this.macchinaRepository = macchinaRepository;
        this.bevandaRepository = bevandaRepository;
        this.gson = new Gson();
    }

    /**
     * Recupera tutte le macchine.
     */
    public Object getAll(Request req, Response res) {
        try {
            List<Macchina> macchine = macchinaRepository.findAll();
            res.type("application/json");
            return gson.toJson(macchine);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero delle macchine: " + e.getMessage()));
        }
    }

    /**
     * Recupera una macchina tramite ID.
     */
    public Object getById(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            Macchina macchina = macchinaRepository.findById(id);

            if (macchina != null) {
                res.type("application/json");
                return gson.toJson(macchina);
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero della macchina: " + e.getMessage()));
        }
    }

    /**
     * Recupera le macchine di un istituto.
     */
    public Object getByIstituto(Request req, Response res) {
        try {
            int istitutoId = Integer.parseInt(req.params(":istitutoId"));
            List<Macchina> macchine = macchinaRepository.findByIstitutoId(istitutoId);

            res.type("application/json");
            return gson.toJson(macchine);
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID istituto non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero delle macchine: " + e.getMessage()));
        }
    }

    public Object getBevandeMacchina(int macchinaId, Response res) {
        try {
            // Verifica esistenza macchina
            Macchina macchina = macchinaRepository.findById(macchinaId);
            if (macchina == null) {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }

            // Verifica stato macchina
            if (macchina.getStatoId() != 1) { // 1 = Attiva
                res.status(400);
                return gson.toJson(Map.of("errore", "Macchina non attiva"));
            }

            // Recupera le bevande disponibili per la macchina
            List<Map<String, Object>> bevande = macchina.getBevande().stream()
                    .map(bevanda -> {
                        Map<String, Object> bevandaInfo = new HashMap<>();
                        bevandaInfo.put("id", bevanda.getId());
                        bevandaInfo.put("nome", bevanda.getNome());
                        bevandaInfo.put("prezzo", bevanda.getPrezzo());

                        // Verifica disponibilità cialde per la bevanda
                        boolean disponibile = bevanda.isDisponibile(macchina.getCialde());
                        bevandaInfo.put("disponibile", disponibile);

                        // Aggiunge informazioni sulle cialde necessarie
                        List<Map<String, Object>> cialdeInfo = bevanda.getCialde().stream()
                                .map(cialda -> {
                                    Map<String, Object> info = new HashMap<>();
                                    info.put("id", cialda.getId());
                                    info.put("nome", cialda.getNome());
                                    info.put("tipo", cialda.getTipoCialda());

                                    // Trova la quantità disponibile della cialda
                                    Optional<QuantitaCialde> quantita = macchina.getCialde().stream()
                                            .filter(qc -> qc.getCialdaId() == cialda.getId())
                                            .findFirst();

                                    info.put("quantitaDisponibile",
                                            quantita.map(QuantitaCialde::getQuantita).orElse(0));
                                    return info;
                                })
                                .collect(Collectors.toList());

                        bevandaInfo.put("cialde", cialdeInfo);
                        return bevandaInfo;
                    })
                    .collect(Collectors.toList());

            res.type("application/json");
            return gson.toJson(bevande);

        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero delle bevande: " + e.getMessage()));
        }
    }

    public Object verificaDisponibilitaBevanda(int bevandaId, int macchinaId, Response res) {
        try {
            // Verifica esistenza macchina
            Macchina macchina = macchinaRepository.findById(macchinaId);
            if (macchina == null) {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }

            // Verifica stato macchina
            if (macchina.getStatoId() != 1) { // 1 = Attiva
                res.status(400);
                return gson.toJson(Map.of("errore", "Macchina non attiva"));
            }

            // Trova la bevanda nella macchina
            Optional<Bevanda> bevandaOpt = macchina.getBevande().stream()
                    .filter(b -> b.getId() == bevandaId)
                    .findFirst();

            if (bevandaOpt.isEmpty()) {
                res.status(404);
                return gson.toJson(Map.of("errore", "Bevanda non disponibile in questa macchina"));
            }

            Bevanda bevanda = bevandaOpt.get();
            boolean disponibile = bevanda.isDisponibile(macchina.getCialde());

            Map<String, Object> risultato = new HashMap<>();
            risultato.put("bevandaId", bevandaId);
            risultato.put("disponibile", disponibile);

            // Se non è disponibile, aggiungi informazioni sulle cialde mancanti
            if (!disponibile) {
                List<Map<String, Object>> cialdeMancanti = bevanda.getCialde().stream()
                        .filter(cialda -> {
                            Optional<QuantitaCialde> qc = macchina.getCialde().stream()
                                    .filter(q -> q.getCialdaId() == cialda.getId())
                                    .findFirst();
                            return qc.isEmpty() || qc.get().getQuantita() == 0;
                        })
                        .map(cialda -> {
                            Map<String, Object> info = new HashMap<>();
                            info.put("id", cialda.getId());
                            info.put("nome", cialda.getNome());
                            info.put("tipo", cialda.getTipoCialda());
                            return info;
                        })
                        .collect(Collectors.toList());

                risultato.put("cialdeMancanti", cialdeMancanti);
            }

            res.type("application/json");
            return gson.toJson(risultato);

        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nella verifica disponibilità: " + e.getMessage()));
        }
    }

    public Object getStatoMacchina(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            com.vending.core.models.Macchina macchina = macchinaRepository.findById(id);

            if (macchina != null) {
                Map<String, Object> stato = Map.of(
                        "id", macchina.getId(),
                        "stato", macchina.getStatoId(),
                        "statoDescrizione", macchina.getStatoDescrizione(),
                        "creditoAttuale", macchina.getCreditoAttuale(),
                        "bevande", macchina.getBevande(),
                        "cialde", macchina.getCialde());

                res.type("application/json");
                return gson.toJson(stato);
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero dello stato: " + e.getMessage()));
        }
    }
    
    /**
     * Aggiorna lo stato di una macchina.
     */
    public Object updateStato(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            Type requestType = new TypeToken<Map<String, Object>>() {
            }.getType();
            Map<String, Object> requestData = gson.fromJson(req.body(), requestType);

            int nuovoStatoId = ((Number) requestData.get("statoId")).intValue();
            if (nuovoStatoId < 1 || nuovoStatoId > 3) {
                res.status(400);
                return gson.toJson(Map.of("errore", "Stato non valido"));
            }

            boolean aggiornato = macchinaRepository.aggiornaStato(id, nuovoStatoId);
            if (aggiornato) {
                return gson.toJson(macchinaRepository.findById(id));
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'aggiornamento dello stato: " + e.getMessage()));
        }
    }
    
    /**
     * Aggiorna le bevande associate a una macchina.
     *
     * @param req richiesta HTTP contenente l'ID della macchina e la lista delle bevande
     * @param res risposta HTTP
     * @return JSON della macchina aggiornata
     */
    public Object updateBevandeMacchina(Request req, Response res) {
        try {
            int macchinaId = Integer.parseInt(req.params(":id"));
            
            // Parsa il corpo della richiesta
            Type requestType = new TypeToken<Map<String, Object>>() {}.getType();
            Map<String, Object> requestData = gson.fromJson(req.body(), requestType);
            
            // Estrae la lista delle bevande dal corpo della richiesta
            @SuppressWarnings("unchecked")
            List<Integer> bevandeIds = (List<Integer>) requestData.get("bevandeIds");
            
            if (bevandeIds == null) {
                res.status(400);
                return gson.toJson(Map.of("errore", "Lista delle bevande mancante"));
            }
            
            // Recupera la macchina
            Macchina macchina = macchinaRepository.findById(macchinaId);
            if (macchina == null) {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }
            
            // Aggiorna le bevande della macchina
            macchinaRepository.aggiornaBevande(macchina, bevandeIds);
            
            // Restituisce la macchina aggiornata
            res.type("application/json");
            return gson.toJson(macchina);
            
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID macchina non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'aggiornamento delle bevande della macchina: " + e.getMessage()));
        }
    }

    /**
     * Crea una nuova macchina.
     */
    public Object create(Request req, Response res) {
        try {
            Type requestType = new TypeToken<Map<String, Object>>() {
            }.getType();
            Map<String, Object> requestData = gson.fromJson(req.body(), requestType);

            Macchina macchina = new Macchina();
            macchina.setIstitutoId(((Number) requestData.get("istitutoId")).intValue());
            macchina.setStatoId(1); // Stato iniziale: Attiva
            macchina.setCassaAttuale(0.0);
            macchina.setCassaMassima(((Number) requestData.get("cassaMassima")).doubleValue());

            Macchina nuovaMacchina = macchinaRepository.save(macchina);
            res.status(201);
            res.type("application/json");
            return gson.toJson(nuovaMacchina);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nella creazione della macchina: " + e.getMessage()));
        }
    }

    /**
     * Elimina una macchina.
     */
    public Object delete(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            boolean deleted = macchinaRepository.delete(id);
            if (deleted) {
                res.status(204);
                return "";
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'eliminazione della macchina: " + e.getMessage()));
        }
    }

    /**
     * Gestisce l'inserimento di denaro nella macchina.
     * 
     * @param req richiesta HTTP contenente ID macchina e importo
     * @param res risposta HTTP
     * @return esito operazione in formato JSON
     */
    public Object insertMoney(Request req, Response res) {
        try {
            int machineId = Integer.parseInt(req.params(":id"));

            // Parsa il corpo della richiesta
            Type requestType = new TypeToken<Map<String, Object>>() {
            }.getType();
            Map<String, Object> requestData = gson.fromJson(req.body(), requestType);

            double importo = ((Number) requestData.get("importo")).doubleValue();

            // Validazione importo
            if (importo <= 0) {
                res.status(400);
                return gson.toJson(Map.of("errore", "Importo non valido"));
            }

            // Verifica esistenza macchina
            Macchina macchina = macchinaRepository.findById(machineId);
            if (macchina == null) {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }

            // Verifica stato macchina
            if (macchina.getStatoId() != 1) { // 1 = Attiva
                res.status(400);
                return gson.toJson(Map.of("errore", "Macchina non disponibile"));
            }

            // Verifica capienza cassa
            if (!macchina.puoAccettareDenaro(importo)) {
                res.status(400);
                return gson.toJson(Map.of("errore", "Cassa piena"));
            }

            // Pubblica comando inserimento denaro su MQTT
            Map<String, Object> comando = new HashMap<>();
            comando.put("tipo", "inserimento_denaro");
            comando.put("importo", importo);
            comando.put("timestamp", System.currentTimeMillis());

            String topic = String.format("macchine/%d/comandi/cassa", machineId);
            // MQTTClient.publish(topic, gson.toJson(comando));

            res.type("application/json");
            return gson.toJson(Map.of("success", true));

        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "Parametri non validi"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore durante l'inserimento del denaro: " + e.getMessage()));
        }
    }

    
    /**
     * Gestisce la richiesta di restituzione del credito.
     * 
     * @param req richiesta HTTP contenente ID macchina
     * @param res risposta HTTP
     * @return esito operazione in formato JSON
     */
    public Object returnCredit(Request req, Response res) {
        try {
            int machineId = Integer.parseInt(req.params(":id"));

            // Verifica esistenza macchina
            Macchina macchina = macchinaRepository.findById(machineId);
            if (macchina == null) {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }

            // Pubblica comando restituzione credito su MQTT
            Map<String, Object> comando = new HashMap<>();
            comando.put("tipo", "restituisci_credito");
            comando.put("timestamp", System.currentTimeMillis());

            String topic = String.format("macchine/%d/comandi/cassa", machineId);
            // MQTTClient mqttClient = new MQTTClient(null);
            // mqttClient.publish(topic, gson.toJson(comando));

            res.type("application/json");
            return gson.toJson(Map.of("success", true));

        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID macchina non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore durante la restituzione del credito: " + e.getMessage()));
        }
    }


    /**
     * Gestisce la richiesta di erogazione di una bevanda.
     * 
     * @param req richiesta HTTP contenente ID macchina e dettagli bevanda
     * @param res risposta HTTP
     * @return esito operazione in formato JSON
     */
    public Object dispense(Request req, Response res) {
        try {
            // Estrae l'ID della macchina dai parametri
            int machineId = Integer.parseInt(req.params(":id"));

            // Parsa il corpo della richiesta
            Type requestType = new TypeToken<Map<String, Object>>() {
            }.getType();
            Map<String, Object> requestData = gson.fromJson(req.body(), requestType);

            int beverageId = ((Number) requestData.get("beverageId")).intValue();
            double amount = ((Number) requestData.get("amount")).doubleValue();

            // Verifica esistenza macchina
            Macchina macchina = macchinaRepository.findById(machineId);
            if (macchina == null) {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }

            // Verifica stato macchina
            if (macchina.getStatoId() != 1) { // 1 = Attiva
                res.status(400);
                return gson.toJson(Map.of("errore", "Macchina non disponibile"));
            }

            // Pubblica il comando di erogazione su MQTT
            Map<String, Object> comando = new HashMap<>();
            comando.put("tipo", "erogazione");
            comando.put("beverageId", beverageId);
            comando.put("amount", amount);
            comando.put("timestamp", System.currentTimeMillis());

            String topic = String.format("macchine/%d/comandi/erogazione", machineId);
            String payload = gson.toJson(comando);
            //MQTTClient.publish(topic, payload);

            res.type("application/json");
            return gson.toJson(Map.of("success", true));

        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "Parametri non validi"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore durante l'erogazione: " + e.getMessage()));
        }
    }

}

================
File: src/main/java/com/vending/api/controllers/ManutenzioneController.java
================
package com.vending.api.controllers;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.vending.core.models.Manutenzione;
import com.vending.core.repositories.ManutenzioneRepository;
import spark.Request;
import spark.Response;

import java.lang.reflect.Type;
import java.util.List;
import java.util.Map;

/**
 * Controller per la gestione delle richieste HTTP relative alle manutenzioni.
 */
public class ManutenzioneController {
    private final ManutenzioneRepository manutenzioneRepository;
    private final Gson gson;

    /**
     * Costruttore del controller.
     *
     * @param manutenzioneRepository repository per le manutenzioni
     */
    public ManutenzioneController(ManutenzioneRepository manutenzioneRepository) {
        this.manutenzioneRepository = manutenzioneRepository;
        this.gson = new Gson();
    }

    /**
     * Recupera tutte le manutenzioni in corso.
     */
    public Object getManutenzioni(Request req, Response res) {
        try {
            List<Manutenzione> manutenzioni = manutenzioneRepository.findAll();
            res.type("application/json");
            return gson.toJson(manutenzioni);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero delle manutenzioni: " + e.getMessage()));
        }
    }

    /**
     * Recupera le manutenzioni di un istituto.
     */
    public Object getManutenzioniIstituto(Request req, Response res) {
        try {
            int istitutoId = Integer.parseInt(req.params(":istitutoId"));
            List<Manutenzione> manutenzioni = manutenzioneRepository.findByIstitutoId(istitutoId);
            res.type("application/json");
            return gson.toJson(manutenzioni);
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID istituto non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero delle manutenzioni: " + e.getMessage()));
        }
    }

    /**
     * Recupera le manutenzioni assegnate a un tecnico.
     */
    public Object getManutenzioniTecnico(Request req, Response res) {
        try {
            int tecnicoId = Integer.parseInt(req.params(":tecnicoId"));
            List<Manutenzione> manutenzioni = manutenzioneRepository.findByTecnicoId(tecnicoId);
            res.type("application/json");
            return gson.toJson(manutenzioni);
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID tecnico non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero delle manutenzioni: " + e.getMessage()));
        }
    }

    /**
     * Inizia una nuova manutenzione.
     */
    public Object iniziaManutenzione(Request req, Response res) {
        try {
            Type requestType = new TypeToken<Map<String, Object>>() {
            }.getType();
            Map<String, Object> requestData = gson.fromJson(req.body(), requestType);

            int macchinaId = ((Number) requestData.get("macchinaId")).intValue();
            int tecnicoId = ((Number) requestData.get("tecnicoId")).intValue();

            if (macchinaId <= 0 || tecnicoId <= 0) {
                res.status(400);
                return gson.toJson(Map.of("errore", "ID macchina o tecnico non validi"));
            }

            Manutenzione manutenzione = new Manutenzione();
            manutenzione.setMacchinaId(macchinaId);
            manutenzione.setTecnicoId(tecnicoId);

            Manutenzione nuovaManutenzione = manutenzioneRepository.save(manutenzione);
            res.status(201);
            res.type("application/json");
            return gson.toJson(nuovaManutenzione);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'avvio della manutenzione: " + e.getMessage()));
        }
    }

    /**
     * Completa una manutenzione.
     */
    public Object completaManutenzione(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));

            return manutenzioneRepository.findById(id)
                    .map(manutenzione -> {
                        try {
                            Manutenzione manutenzioneCompletata = manutenzioneRepository
                                    .completaManutenzione(manutenzione);
                            res.type("application/json");
                            return gson.toJson(manutenzioneCompletata);
                        } catch (Exception e) {
                            res.status(500);
                            return gson.toJson(
                                    Map.of("errore", "Errore nel completamento della manutenzione: " + e.getMessage()));
                        }
                    })
                    .orElseGet(() -> {
                        res.status(404);
                        return gson.toJson(Map.of("errore", "Manutenzione non trovata"));
                    });
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel completamento della manutenzione: " + e.getMessage()));
        }
    }

    /**
     * Imposta una macchina come fuori servizio.
     */
    public Object setFuoriServizio(Request req, Response res) {
        try {
            int macchinaId = Integer.parseInt(req.params(":id"));
            if (manutenzioneRepository.setFuoriServizio(macchinaId)) {
                res.status(204);
                return "";
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'impostazione fuori servizio: " + e.getMessage()));
        }
    }
}

================
File: src/main/java/com/vending/api/controllers/PublicController.java
================
package com.vending.api.controllers;

import com.google.gson.Gson;
import com.vending.core.models.*;
import com.vending.core.repositories.*;
import spark.Request;
import spark.Response;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Controller che gestisce tutti gli endpoint pubblici del sistema.
 * Fornisce accesso alle funzionalità base per gli utenti non autenticati.
 */
public class PublicController {
    private final MacchinaRepository macchinaRepository;
    private final BevandaRepository bevandaRepository;
    private final IstitutoRepository istitutoRepository;
    private final TransazioneRepository transazioneRepository;
    private final Gson gson;

    /**
     * Costruttore del controller pubblico.
     */
    public PublicController(
            MacchinaRepository macchinaRepository,
            BevandaRepository bevandaRepository,
            IstitutoRepository istitutoRepository,
            TransazioneRepository transazioneRepository) {
        this.macchinaRepository = macchinaRepository;
        this.bevandaRepository = bevandaRepository;
        this.istitutoRepository = istitutoRepository;
        this.transazioneRepository = transazioneRepository;
        this.gson = new Gson();
    }

    /**
     * Recupera tutte le macchine attive.
     */
    public Object getMacchine(Request req, Response res) {
        try {
            List<com.vending.core.models.Macchina> macchine = macchinaRepository.findAll();
            res.type("application/json");
            return gson.toJson(macchine);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero delle macchine: " + e.getMessage()));
        }
    }

    /**
     * Recupera una macchina specifica per ID.
     */
    public Object getMacchinaById(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            com.vending.core.models.Macchina macchina = macchinaRepository.findById(id);

            if (macchina != null) {
                res.type("application/json");
                return gson.toJson(macchina);
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero della macchina: " + e.getMessage()));
        }
    }

    /**
     * Recupera tutte le macchine di un istituto.
     */
    public Object getMacchineByIstituto(Request req, Response res) {
        try {
            int istitutoId = Integer.parseInt(req.params(":istitutoId"));
            List<com.vending.core.models.Macchina> macchine = macchinaRepository.findByIstitutoId(istitutoId);
            res.type("application/json");
            return gson.toJson(macchine);
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID istituto non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero delle macchine: " + e.getMessage()));
        }
    }

    /**
     * Recupera lo stato attuale di una macchina.
     */
    public Object getStatoMacchina(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            com.vending.core.models.Macchina macchina = macchinaRepository.findById(id);

            if (macchina != null) {
                Map<String, Object> stato = Map.of(
                        "id", macchina.getId(),
                        "stato", macchina.getStatoId(),
                        "statoDescrizione", macchina.getStatoDescrizione(),
                        "creditoAttuale", macchina.getCreditoAttuale(),
                        "bevande", macchina.getBevande(),
                        "cialde", macchina.getCialde());

                res.type("application/json");
                return gson.toJson(stato);
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero dello stato: " + e.getMessage()));
        }
    }

    /**
     * Recupera tutte le bevande disponibili.
     */
    public Object getBevande(Request req, Response res) {
        try {
            List<Bevanda> bevande = bevandaRepository.findAll();
            res.type("application/json");
            return gson.toJson(bevande);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero delle bevande: " + e.getMessage()));
        }
    }

    /**
     * Recupera una bevanda specifica per ID.
     */
    public Object getBevandaById(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            Optional<Bevanda> bevanda = bevandaRepository.findById(id);

            if (bevanda.isPresent()) {
                res.type("application/json");
                return gson.toJson(bevanda.get());
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Bevanda non trovata"));
            }
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero della bevanda: " + e.getMessage()));
        }
    }

    /**
     * Recupera tutti gli istituti.
     */
    public Object getIstituti(Request req, Response res) {
        try {
            List<Istituto> istituti = istitutoRepository.findAll();
            res.type("application/json");
            return gson.toJson(istituti);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero degli istituti: " + e.getMessage()));
        }
    }

    /**
     * Recupera un istituto specifico per ID.
     */
    public Object getIstitutoById(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            Optional<Istituto> istituto = istitutoRepository.findById(id);

            if (istituto.isPresent()) {
                res.type("application/json");
                return gson.toJson(istituto.get());
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Istituto non trovato"));
            }
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero dell'istituto: " + e.getMessage()));
        }
    }

    /**
     * Gestisce l'erogazione di una bevanda.
     */
    public Object erogaBevanda(Request req, Response res) {
        try {
            int macchinaId = Integer.parseInt(req.params(":id"));
            Map<String, Object> body = gson.fromJson(req.body(), Map.class);
            int bevandaId = ((Number) body.get("bevandaId")).intValue();

            com.vending.core.models.Macchina macchina = macchinaRepository.findById(macchinaId);
            if (macchina == null) {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }

            // Crea una nuova transazione
            Transazione transazione = new Transazione();
            transazione.setMacchinaId(macchinaId);
            transazione.setBevandaId(bevandaId);
            transazione = transazioneRepository.save(transazione);

            res.status(201);
            return gson.toJson(transazione);

        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore durante l'erogazione: " + e.getMessage()));
        }
    }

    /**
     * Gestisce l'inserimento del credito.
     */
    public Object inserisciCredito(Request req, Response res) {
        try {
            int macchinaId = Integer.parseInt(req.params(":id"));
            Map<String, Object> body = gson.fromJson(req.body(), Map.class);
            double importo = ((Number) body.get("importo")).doubleValue();

            com.vending.core.models.Macchina macchina = macchinaRepository.findById(macchinaId);
            if (macchina == null) {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }

            // Aggiorna il credito
            double att = macchina.getCreditoAttuale();
            macchina.setCreditoAttuale(att + importo);
            macchinaRepository.update(macchina);

            return gson.toJson(Map.of(
                    "creditoAttuale", att,
                    "messaggio", "Credito aggiornato con successo"));

        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore durante l'inserimento del credito: " + e.getMessage()));
        }
    }

    public Object getBevandeMacchina(int macchinaId, Response res) {
        try {
            // Verifica esistenza macchina
            Macchina macchina = macchinaRepository.findById(macchinaId);
            if (macchina == null) {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }

            // Verifica stato macchina
            if (macchina.getStatoId() != 1) { // 1 = Attiva
                res.status(400);
                return gson.toJson(Map.of("errore", "Macchina non attiva"));
            }

            // Recupera le bevande disponibili per la macchina
            List<Map<String, Object>> bevande = macchina.getBevande().stream()
                    .map(bevanda -> {
                        Map<String, Object> bevandaInfo = new HashMap<>();
                        bevandaInfo.put("id", bevanda.getId());
                        bevandaInfo.put("nome", bevanda.getNome());
                        bevandaInfo.put("prezzo", bevanda.getPrezzo());

                        // Verifica disponibilità cialde per la bevanda
                        boolean disponibile = bevanda.isDisponibile(macchina.getCialde());
                        bevandaInfo.put("disponibile", disponibile);

                        // Aggiunge informazioni sulle cialde necessarie
                        List<Map<String, Object>> cialdeInfo = bevanda.getCialde().stream()
                                .map(cialda -> {
                                    Map<String, Object> info = new HashMap<>();
                                    info.put("id", cialda.getId());
                                    info.put("nome", cialda.getNome());
                                    info.put("tipo", cialda.getTipoCialda());

                                    // Trova la quantità disponibile della cialda
                                    Optional<QuantitaCialde> quantita = macchina.getCialde().stream()
                                            .filter(qc -> qc.getCialdaId() == cialda.getId())
                                            .findFirst();

                                    info.put("quantitaDisponibile",
                                            quantita.map(QuantitaCialde::getQuantita).orElse(0));
                                    return info;
                                })
                                .collect(Collectors.toList());

                        bevandaInfo.put("cialde", cialdeInfo);
                        return bevandaInfo;
                    })
                    .collect(Collectors.toList());

            res.type("application/json");
            return gson.toJson(bevande);

        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero delle bevande: " + e.getMessage()));
        }
    }

    public Object verificaDisponibilitaBevanda(int bevandaId, int macchinaId, Response res) {
        try {
            // Verifica esistenza macchina
            Macchina macchina = macchinaRepository.findById(macchinaId);
            if (macchina == null) {
                res.status(404);
                return gson.toJson(Map.of("errore", "Macchina non trovata"));
            }

            // Verifica stato macchina
            if (macchina.getStatoId() != 1) { // 1 = Attiva
                res.status(400);
                return gson.toJson(Map.of("errore", "Macchina non attiva"));
            }

            // Trova la bevanda nella macchina
            Optional<Bevanda> bevandaOpt = macchina.getBevande().stream()
                    .filter(b -> b.getId() == bevandaId)
                    .findFirst();

            if (bevandaOpt.isEmpty()) {
                res.status(404);
                return gson.toJson(Map.of("errore", "Bevanda non disponibile in questa macchina"));
            }

            Bevanda bevanda = bevandaOpt.get();
            boolean disponibile = bevanda.isDisponibile(macchina.getCialde());

            Map<String, Object> risultato = new HashMap<>();
            risultato.put("bevandaId", bevandaId);
            risultato.put("disponibile", disponibile);

            // Se non è disponibile, aggiungi informazioni sulle cialde mancanti
            if (!disponibile) {
                List<Map<String, Object>> cialdeMancanti = bevanda.getCialde().stream()
                        .filter(cialda -> {
                            Optional<QuantitaCialde> qc = macchina.getCialde().stream()
                                    .filter(q -> q.getCialdaId() == cialda.getId())
                                    .findFirst();
                            return qc.isEmpty() || qc.get().getQuantita() == 0;
                        })
                        .map(cialda -> {
                            Map<String, Object> info = new HashMap<>();
                            info.put("id", cialda.getId());
                            info.put("nome", cialda.getNome());
                            info.put("tipo", cialda.getTipoCialda());
                            return info;
                        })
                        .collect(Collectors.toList());

                risultato.put("cialdeMancanti", cialdeMancanti);
            }

            res.type("application/json");
            return gson.toJson(risultato);

        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nella verifica disponibilità: " + e.getMessage()));
        }
    }
}

================
File: src/main/java/com/vending/api/controllers/UtenteController.java
================
package com.vending.api.controllers;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import com.vending.core.models.Utente;
import com.vending.core.repositories.UtenteRepository;
import com.vending.utils.date.LocalDateTimeTypeAdapter;

import spark.Request;
import spark.Response;

import java.lang.reflect.Type;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Controller per la gestione delle richieste HTTP relative agli utenti.
 */
public class UtenteController {
    private final UtenteRepository utenteRepository;
    private final Gson gson;

    /**
     * Costruttore del controller.
     *
     * @param utenteRepository repository per la gestione degli utenti
     */
    public UtenteController(UtenteRepository utenteRepository) {
        this.utenteRepository = utenteRepository;
        this.gson = new GsonBuilder()
            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeTypeAdapter())
            .create();
    }

    /**
     * Recupera tutti gli utenti.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return lista JSON degli utenti
     */
    public Object getAll(Request req, Response res) {
        try {
            List<Utente> utenti = utenteRepository.findAll();
            res.type("application/json");
            return gson.toJson(utenti);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero degli utenti: " + e.getMessage()));
        }
    }

    /**
     * Recupera un utente tramite ID.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return JSON dell'utente
     */
    public Object getById(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            Optional<Utente> utente = utenteRepository.findById(id);

            if (utente.isPresent()) {
                res.type("application/json");
                return gson.toJson(utente.get());
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Utente non trovato"));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero dell'utente: " + e.getMessage()));
        }
    }

    /**
     * Recupera un utente tramite username.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return JSON dell'utente
     */
    public Object getByUsername(Request req, Response res) {
        try {
            String username = req.params(":username");
            Utente utente = utenteRepository.findByUsername(username);

            if (utente != null) {
                res.type("application/json");
                return gson.toJson(utente);
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Utente non trovato"));
            }
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero dell'utente: " + e.getMessage()));
        }
    }

    /**
     * Recupera gli utenti per ruolo.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return lista JSON degli utenti con il ruolo specificato
     */
    public Object getByRuolo(Request req, Response res) {
        try {
            String ruolo = req.params(":ruolo");
            List<Utente> utenti = utenteRepository.findByRuolo(ruolo);
            res.type("application/json");
            return gson.toJson(utenti);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nel recupero degli utenti per ruolo: " + e.getMessage()));
        }
    }

    /**
     * Crea un nuovo utente.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return JSON dell'utente creato
     */
    public Object create(Request req, Response res) {
        try {
            Type requestType = new TypeToken<Map<String, Object>>() {}.getType();
            Map<String, Object> requestData = gson.fromJson(req.body(), requestType);

            String nome = (String) requestData.get("nome");
            String ruolo = (String) requestData.get("ruolo");
            String username = (String) requestData.get("username");
            String password = (String) requestData.get("password");

            if (nome == null || ruolo == null || username == null || password == null) {
                res.status(400);
                return gson.toJson(Map.of("errore", "Parametri mancanti"));
            }

            Utente utente = new Utente();
            utente.setNome(nome);
            utente.setRuolo(ruolo);
            utente.setUsername(username);
            utente.setPassword(password);

            Utente nuovoUtente = utenteRepository.save(utente);
            res.status(201);
            res.type("application/json");
            return gson.toJson(nuovoUtente);
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nella creazione dell'utente: " + e.getMessage()));
        }
    }

    /**
     * Aggiorna un utente esistente.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return JSON dell'utente aggiornato
     */
    public Object update(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            Type requestType = new TypeToken<Map<String, Object>>() {}.getType();
            Map<String, Object> requestData = gson.fromJson(req.body(), requestType);

            String nome = (String) requestData.get("nome");
            String ruolo = (String) requestData.get("ruolo");

            if (nome == null || ruolo == null) {
                res.status(400);
                return gson.toJson(Map.of("errore", "Parametri mancanti"));
            }

            Utente utente = new Utente();
            utente.setId(id);
            utente.setNome(nome);
            utente.setRuolo(ruolo);

            Utente utenteAggiornato = utenteRepository.update(utente);
            res.type("application/json");
            return gson.toJson(utenteAggiornato);
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'aggiornamento dell'utente: " + e.getMessage()));
        }
    }

    /**
     * Elimina un utente.
     *
     * @param req richiesta HTTP
     * @param res risposta HTTP
     * @return risposta vuota o errore
     */
    public Object delete(Request req, Response res) {
        try {
            int id = Integer.parseInt(req.params(":id"));
            boolean deleted = utenteRepository.delete(id);

            if (deleted) {
                res.status(204);
                return "";
            } else {
                res.status(404);
                return gson.toJson(Map.of("errore", "Utente non trovato"));
            }
        } catch (NumberFormatException e) {
            res.status(400);
            return gson.toJson(Map.of("errore", "ID non valido"));
        } catch (Exception e) {
            res.status(500);
            return gson.toJson(Map.of("errore", "Errore nell'eliminazione dell'utente: " + e.getMessage()));
        }
    }
}

================
File: src/main/java/com/vending/api/middleware/AuthMiddleware.java
================
package com.vending.api.middleware;

import com.google.gson.Gson;
import com.vending.security.jwt.JWTService;
import spark.Request;
import spark.Response;

import java.util.Map;

/**
 * Middleware per la gestione dell'autenticazione e autorizzazione delle
 * richieste HTTP.
 * Questa classe gestisce la verifica dei token JWT, l'accesso agli endpoint
 * pubblici
 * e i controlli di autorizzazione basati sui ruoli.
 *
 * @author Edoardo Giovanni Fracchia
 * @see com.vending.security.jwt.JWTService
 */
public class AuthMiddleware {
    private final JWTService jwtService;
    private final Gson gson;

    /**
     * Costruttore della classe AuthMiddleware.
     * Inizializza il servizio JWT e l'oggetto Gson per la serializzazione JSON.
     */
    public AuthMiddleware() {
        this.jwtService = new JWTService();
        this.gson = new Gson();
    }

    /**
     * Verifica l'autenticazione di una richiesta HTTP.
     * Controlla se l'endpoint è pubblico, verifica la presenza e validità del token
     * JWT,
     * e gestisce i token anonimi.
     *
     * @param req l'oggetto Request di Spark contenente gli headers e il path della
     *            richiesta
     * @param res l'oggetto Response di Spark per impostare lo status e il corpo
     *            della risposta
     * @return true se l'autenticazione ha successo, false altrimenti
     */
    public boolean autenticazione(Request req, Response res) {
        // Verifica se il path è pubblico
        if (isPublicEndpoint(req.pathInfo())) {
            return true;
        }

        String authHeader = req.headers("Authorization");

        // Verifica la presenza e il formato dell'header Authorization
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            res.status(401);
            res.body(gson.toJson(Map.of("errore", "Token di autorizzazione mancante o malformato")));
            return false;
        }

        String token = authHeader.substring(7); // Rimuove "Bearer "

        // Gestione token anonimi
        if (token.startsWith("anonymous_")) {
            return true;
        }

        // Verifica del token JWT
        try {
            if (!jwtService.verificaToken(token)) {
                res.status(401);
                res.body(gson.toJson(Map.of("errore", "Token non valido")));
                return false;
            }
            return true;
        } catch (Exception e) {
            res.status(401);
            res.body(gson.toJson(Map.of("errore", "Errore nella verifica del token: " + e.getMessage())));
            return false;
        }
    }

    /**
     * Verifica se un path corrisponde a un endpoint pubblico.
     * Supporta sia path esatti che pattern con wildcard.
     *
     * @param path il path della richiesta da verificare
     * @return true se il path corrisponde a un endpoint pubblico, false altrimenti
     */
    private boolean isPublicEndpoint(String path) {
        // Lista degli endpoint pubblici con supporto per wildcard
        String[] publicEndpoints = {
                "/api/istituti",
                "/api/istituti/*",
                "/api/macchine",
                "/api/macchine/*",
                "/api/macchine/istituto/*",
                "/api/bevande",
                "/api/bevande/*",
                "/api/auth/*",
                "/api/auth/*"
        };

        for (String endpoint : publicEndpoints) {
            if (endpoint.endsWith("/*")) {
                String baseEndpoint = endpoint.substring(0, endpoint.length() - 2);
                if (path.startsWith(baseEndpoint)) {
                    return true;
                }
            } else {
                if (path.equals(endpoint)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Verifica se l'utente ha i privilegi di amministratore.
     * Controlla il ruolo presente nel token JWT.
     *
     * @param req l'oggetto Request di Spark contenente l'header di autorizzazione
     * @param res l'oggetto Response di Spark per impostare lo status e il corpo
     *            della risposta
     * @return true se l'utente è un amministratore, false altrimenti
     */
    public boolean autorizzazioneAdmin(Request req, Response res) {
        String authHeader = req.headers("Authorization");
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            res.status(401);
            res.body(gson.toJson(Map.of("errore", "Token di autorizzazione mancante o malformato")));
            return false;
        }

        String token = authHeader.substring(7);

        try {
            String ruolo = jwtService.getRuoloDaToken(token);
            if (!"Amministratore".equals(ruolo) || !"Impiegato".equals(ruolo) || !"Tecnico".equals(ruolo) || ruolo == "") {
                res.status(403);
                res.body(gson.toJson(Map.of("errore", "Accesso non autorizzato!")));
                return false;
            }
            else return true;
        } catch (Exception e) {
            res.status(403);
            res.body(gson.toJson(Map.of("errore", "Accesso non autorizzato: " + e.getMessage())));
            return false;
        }
    }
}

================
File: src/main/java/com/vending/api/middleware/CORSMiddleware.java
================
package com.vending.api.middleware;

import spark.Request;
import spark.Response;

/**
 * Middleware per la gestione delle policy CORS (Cross-Origin Resource Sharing).
 * Questa classe fornisce metodi per configurare le intestazioni CORS
 * appropriate
 * nelle risposte HTTP, consentendo le richieste cross-origin in modo sicuro.
 * 
 * @author Edoardo Giovanni Fracchia
 */
public class CORSMiddleware {

    /**
     * Applica le intestazioni CORS di base alla risposta HTTP.
     * Configura le policy per consentire richieste cross-origin con impostazioni
     * predefinite.
     * 
     * @param req l'oggetto Request di Spark che rappresenta la richiesta HTTP in
     *            arrivo
     * @param res l'oggetto Response di Spark che rappresenta la risposta HTTP da
     *            inviare
     */
    public void applicaCORS(Request req, Response res) {
        // Consente richieste da qualsiasi origine
        res.header("Access-Control-Allow-Origin", "*");
        // Specifica i metodi HTTP consentiti
        res.header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
        // Definisce le intestazioni HTTP consentite
        res.header("Access-Control-Allow-Headers", "Content-Type, Authorization");
    }

    /**
     * Gestisce le richieste OPTIONS di preflight CORS.
     * Questo metodo configura le intestazioni appropriate in risposta alle
     * richieste
     * di preflight inviate dal browser prima delle richieste CORS effettive.
     * 
     * @param req l'oggetto Request di Spark che rappresenta la richiesta HTTP di
     *            preflight
     * @param res l'oggetto Response di Spark che rappresenta la risposta HTTP da
     *            inviare
     */
    public void gestisciOpzioniPreflight(Request req, Response res) {
        // Recupera le intestazioni richieste dal client
        String accessControlRequestHeaders = req.headers("Access-Control-Request-Headers");
        if (accessControlRequestHeaders != null) {
            // Configura le intestazioni consentite in base alla richiesta
            res.header("Access-Control-Allow-Headers", accessControlRequestHeaders);
        }

        // Recupera il metodo HTTP richiesto dal client
        String accessControlRequestMethod = req.headers("Access-Control-Request-Method");
        if (accessControlRequestMethod != null) {
            // Configura i metodi HTTP consentiti in base alla richiesta
            res.header("Access-Control-Allow-Methods", accessControlRequestMethod);
        }
    }
}

================
File: src/main/java/com/vending/api/middleware/LogMiddleware.java
================
package com.vending.api.middleware;

import com.vending.utils.log.LogUtil;
import spark.Request;
import spark.Response;

/**
 * Middleware per la gestione dei log delle richieste HTTP e degli errori.
 * Questa classe fornisce funzionalità per registrare informazioni dettagliate
 * sulle richieste in arrivo e gli eventuali errori che si verificano durante
 * l'elaborazione delle richieste.
 * 
 * @author Edoardo Giovanni Fracchia
 */
public class LogMiddleware {

    /**
     * Registra i dettagli di una richiesta HTTP e della sua risposta.
     * Il log include il metodo HTTP, il percorso richiesto, lo status code
     * della risposta e l'indirizzo IP del client.
     * 
     * @param req l'oggetto Request di Spark che contiene i dettagli della richiesta
     * @param res l'oggetto Response di Spark che contiene i dettagli della risposta
     */
    public void logRequest(Request req, Response res) {
        // Formatta il messaggio di log con i dettagli della richiesta
        String logMessage = String.format(
                "Request: %s %s - Status: %d - IP: %s",
                req.requestMethod(), // Metodo HTTP (GET, POST, etc.)
                req.pathInfo(), // Percorso della richiesta
                res.status(), // Status code HTTP
                req.ip() // Indirizzo IP del client
        );
        // Registra il messaggio come informazione
        LogUtil.info(logMessage);
    }

    /**
     * Registra i dettagli di un errore verificatosi durante l'elaborazione
     * di una richiesta HTTP. Include il metodo HTTP, il percorso e il
     * messaggio di errore.
     * 
     * @param req l'oggetto Request di Spark associato alla richiesta che ha
     *            generato l'errore
     * @param e   l'eccezione che si è verificata durante l'elaborazione della
     *            richiesta
     */
    public void logError(Request req, Exception e) {
        // Formatta il messaggio di errore con i dettagli della richiesta
        String errorMessage = String.format(
                "Error in %s %s: %s",
                req.requestMethod(), // Metodo HTTP della richiesta
                req.pathInfo(), // Percorso della richiesta
                e.getMessage() // Messaggio di errore dell'eccezione
        );
        // Registra il messaggio come errore, includendo lo stack trace
        LogUtil.error(errorMessage, e);
    }
}

================
File: src/main/java/com/vending/api/routes/Routes.java
================
package com.vending.api.routes;

import com.vending.ServiceRegistry;
import com.vending.api.controllers.*;
import com.vending.api.middleware.*;
import com.vending.core.services.UtenteService;
import com.vending.core.services.AdminLoginService;

import static spark.Spark.*;

/**
 * Configurazione delle rotte dell'applicazione.
 * Gestisce il routing delle richieste HTTP ai rispettivi controller
 * e applica i middleware necessari per autenticazione, logging e CORS.
 * 
 * @author Edoardo Giovanni Fracchia
 */
public class Routes {
	private final IstitutoController istitutoController;
	private final MacchinaController macchinaController;
	private final BevandaController bevandaController;
	private final ManutenzioneController manutenzioneController;
	private final AuthController authController;
	private final AuthMiddleware authMiddleware;
	private final LogMiddleware logMiddleware;
	private final CORSMiddleware corsMiddleware;

	/**
	 * Costruttore che inizializza i controller e i middleware necessari.
	 *
	 * @param istitutoController     controller per la gestione degli istituti
	 * @param macchinaController     controller per la gestione delle macchine
	 * @param bevandaController      controller per la gestione delle bevande
	 * @param manutenzioneController controller per la gestione delle manutenzioni
	 */
	public Routes(	IstitutoController istitutoController,
					MacchinaController macchinaController,
					BevandaController bevandaController,
					ManutenzioneController manutenzioneController) {
		this.istitutoController = istitutoController;
		this.macchinaController = macchinaController;
		this.bevandaController = bevandaController;
		this.manutenzioneController = manutenzioneController;
		this.authController = new AuthController(
				ServiceRegistry.get(AdminLoginService.class),
				ServiceRegistry.get(UtenteService.class));
		this.authMiddleware = new AuthMiddleware();
		this.logMiddleware = new LogMiddleware();
		this.corsMiddleware = new CORSMiddleware();

		setupRoutes();
	}

	/**
	 * Configura tutte le rotte dell'applicazione.
	 * Le rotte sono organizzate per entità (istituti, macchine, bevande,
	 * manutenzioni)
	 * e protette da autenticazione. Alcune operazioni richiedono privilegi
	 * amministrativi.
	 *
	 * Pattern delle rotte:
	 * - GET /api/{entità} - recupera tutti gli elementi
	 * - GET /api/{entità}/:id - recupera un elemento specifico
	 * - POST /api/{entità} - crea un nuovo elemento (richiede admin)
	 * - PUT /api/{entità}/:id - aggiorna un elemento (richiede admin)
	 * - DELETE /api/{entità}/:id - elimina un elemento (richiede admin)
	 */
	private void setupRoutes() {
		// Configurazione CORS e logging globale
		before((request, response) -> corsMiddleware.applicaCORS(request, response));
		after((request, response) -> logMiddleware.logRequest(request, response));

		// Root path
		get("/", (req, res) -> {
			res.redirect("/index.html");
			return null;
		});

		// Rotte pubbliche
		get("/istituti", istitutoController::getAll);
		get("/istituti/:id", istitutoController::getById);
		get("/macchine", macchinaController::getAll);
		get("/macchine/:id", macchinaController::getById);
		get("/macchine/istituto/:istitutoId", macchinaController::getByIstituto);
		get("/bevande", bevandaController::getAll);
		get("/bevande/:id", bevandaController::getById);

		// API Routes
		path("/api", () -> {
			// Auth routes (pubbliche)
			path("/auth", () -> {
				post("/login", authController::login);
				post("/register", authController::registrazione);
				post("/refresh", authController::refreshToken);
				post("/verify", authController::verificaToken);
				post("/anonymous", authController::getAnonymousToken);
			});
			;

			// Protected routes
			// Applica il middleware di autenticazione a tutte le rotte protette
			before("/protected/*", authMiddleware::autenticazione);
			path("/protected", () -> {
				// Istituti
				post("/istituti", (req, res) -> {
					authMiddleware.autorizzazioneAdmin(req, res);
					return istitutoController.create(req, res);
				});
				put("/istituti/:id", (req, res) -> {
					authMiddleware.autorizzazioneAdmin(req, res);
					return istitutoController.update(req, res);
				});
				delete("/istituti/:id", (req, res) -> {
					authMiddleware.autorizzazioneAdmin(req, res);
					return istitutoController.delete(req, res);
				});

				// Macchine
				post("/macchine", (req, res) -> {
					authMiddleware.autorizzazioneAdmin(req, res);
					return macchinaController.create(req, res);
				});
				put("/macchine/:id/stato", macchinaController::updateStato);
				delete("/macchine/:id", (req, res) -> {
					authMiddleware.autorizzazioneAdmin(req, res);
					return macchinaController.delete(req, res);
				});

				// Bevande
				path("/bevande", () -> {
					post("", (req, res) -> {
						authMiddleware.autorizzazioneAdmin(req, res);
						return bevandaController.create(req, res);
					});
					put("/:id", (req, res) -> {
						authMiddleware.autorizzazioneAdmin(req, res);
						return bevandaController.update(req, res);
					});
					delete("/:id", (req, res) -> {
						authMiddleware.autorizzazioneAdmin(req, res);
						return bevandaController.delete(req, res);
					});
					put("/:id/cialde", (req, res) -> {
						authMiddleware.autorizzazioneAdmin(req, res);
						return bevandaController.aggiungiCialda(req, res);
					});
					delete("/:id/cialde/:cialdaId", (req, res) -> {
						authMiddleware.autorizzazioneAdmin(req, res);
						return bevandaController.rimuoviCialda(req, res);
					});
				});

				// Manutenzioni
				path("/manutenzioni", () -> {
					get("", manutenzioneController::getManutenzioni);
					get("/istituto/:istitutoId", manutenzioneController::getManutenzioniIstituto);
					get("/tecnico/:tecnicoId", manutenzioneController::getManutenzioniTecnico);
					post("", manutenzioneController::iniziaManutenzione);
					put("/:id/completa", manutenzioneController::completaManutenzione);
					put("/:id/fuori-servizio", manutenzioneController::setFuoriServizio);
				});
			});
		});

		// Gestione errori
		configureErrorHandling();
	}

	private void configureErrorHandling() {
		exception(Exception.class, (e, req, res) -> {
			res.status(500);
			res.type("application/json");
			res.body("{\"errore\": \"" + e.getMessage() + "\"}");
			logMiddleware.logError(req, e);
		});

		notFound((req, res) -> {
			res.type("application/json");
			res.status(404);
			return "{\"errore\": \"Risorsa non trovata\"}";
		});

		internalServerError((req, res) -> {
			res.type("application/json");
			return "{\"errore\": \"Errore interno del server\"}";
		});
	}
}

================
File: src/main/java/com/vending/config.properties
================
# Configurazioni Server
server.port=8080
server.host=0.0.0.0
server.context-path=/api
server.ssl.enabled=true
server.ssl.key-store=keystore.p12
server.ssl.key-store-password=Pissir2024Keystore!
server.ssl.key-store-type=PKCS12

# Database
db.url=jdbc:mysql://localhost:3306/pissir
db.username=root
db.password=Pissir2024!
db.driver=com.mysql.cj.jdbc.Driver
db.pool.initial=5
db.pool.min=5
db.pool.max=20

# MQTT Broker
mqtt.broker.url=tcp://localhost:8883
mqtt.client.username=20019309
mqtt.client.password=Pissir2024!
mqtt.client.clean.session=true
mqtt.client.connection.timeout=10
mqtt.client.keep-alive=60

# JWT Security
jwt.secret=LGzxTfE1ANOl8OOQjKlJ6wNI1g7MxCwz
jwt.expiration=3600000
jwt.issuer=20019309

# Logging
logging.level.root=INFO
logging.level.com.vending=DEBUG
logging.file.path=/var/log/vending
logging.file.name=vending-service.log
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
logging.pattern.console=%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n

# Cache
cache.type=caffeine
cache.spec=maximumSize=500,expireAfterWrite=30m

# Gestione Macchine
macchine.cassa.max-default=1000.00
macchine.cialde.max-default=100
macchine.threshold.cassa=0.9
macchine.threshold.cialde=0.2

# # Email Notifications
# mail.smtp.host=smtp.gmail.com
# mail.smtp.port=587
# mail.username=your_email@gmail.com
# mail.password=your_email_password
# mail.from=noreply@vendingsystem.com
# mail.enable.ssl=true

# Monitoring
management.endpoints.web.exposure.include=health,metrics,prometheus
management.endpoint.health.show-details=always
management.metrics.tags.application=vending-service

# # Cross-Origin Resource Sharing (CORS)
# cors.allowed-origins=http://localhost:3000,https://your-domain.com
# cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
# cors.allowed-headers=Authorization,Content-Type
# cors.max-age=3600


# Async Executor
async.core-pool-size=2
async.max-pool-size=5
async.queue-capacity=10

================
File: src/main/java/com/vending/core/models/AdminLogin.java
================
package com.vending.core.models;

import java.time.LocalDateTime;
import org.mindrot.jbcrypt.BCrypt;

/**
 * Classe che rappresenta le credenziali di accesso amministrativo al sistema.
 * Questa classe riflette la struttura della tabella 'adminlogin' nel database
 * e gestisce l'autenticazione degli utenti amministrativi.
 */
public class AdminLogin {
    private int id;
    private int utenteId;
    private String username;
    private String passwordHash;
    private LocalDateTime ultimoAccesso;
    private Utente utente;  // Relazione con l'entità Utente

    /**
     * Costruttore predefinito.
     */
    public AdminLogin() {
        this.ultimoAccesso = LocalDateTime.now();
    }

    /**
     * Costruttore con parametri principali.
     *
     * @param utenteId ID dell'utente associato
     * @param username Nome utente per l'accesso
     * @param password Password in chiaro che verrà crittografata
     */
    public AdminLogin(int utenteId, String username, String password) {
        this();
        this.utenteId = utenteId;
        this.username = username;
        setPassword(password);
    }

    /**
     * Restituisce l'ID univoco del login amministrativo.
     *
     * @return ID del login
     */
    public int getId() {
        return id;
    }

    /**
     * Imposta l'ID del login amministrativo.
     *
     * @param id Nuovo ID da impostare
     */
    public void setId(int id) {
        this.id = id;
    }

    /**
     * Restituisce l'ID dell'utente associato.
     *
     * @return ID dell'utente
     */
    public int getUtenteId() {
        return utenteId;
    }

    /**
     * Imposta l'ID dell'utente associato.
     *
     * @param utenteId Nuovo ID dell'utente
     */
    public void setUtenteId(int utenteId) {
        this.utenteId = utenteId;
    }

    /**
     * Restituisce il nome utente per l'accesso.
     *
     * @return Nome utente
     */
    public String getUsername() {
        return username;
    }

    /**
     * Imposta il nome utente per l'accesso.
     *
     * @param username Nuovo nome utente
     */
    public void setUsername(String username) {
        this.username = username;
    }

    /**
     * Restituisce l'hash della password.
     *
     * @return Hash della password
     */
    public String getPasswordHash() {
        return passwordHash;
    }

    /**
     * Imposta direttamente l'hash della password.
     * Utile per operazioni di caricamento dal database o sincronizzazione.
     * 
     * @param passwordHash Hash della password da impostare
     */
    public void setPasswordHash(String passwordHash) {
        this.passwordHash = passwordHash;
    }

    /**
     * Imposta e cripta la password.
     * La password viene sottoposta a hashing prima del salvataggio.
     *
     * @param password Password in chiaro da crittografare
     */
    public void setPassword(String password) {
        if (password != null && !password.isEmpty()) {
            this.passwordHash = BCrypt.hashpw(password, BCrypt.gensalt(12));
        }
    }

    /**
     * Restituisce la data e ora dell'ultimo accesso.
     *
     * @return Data e ora dell'ultimo accesso
     */
    public LocalDateTime getUltimoAccesso() {
        return ultimoAccesso;
    }

    /**
     * Imposta la data e ora dell'ultimo accesso.
     *
     * @param ultimoAccesso Nuova data e ora dell'ultimo accesso
     */
    public void setUltimoAccesso(LocalDateTime ultimoAccesso) {
        this.ultimoAccesso = ultimoAccesso;
    }

    /**
     * Restituisce l'utente associato a questo login.
     *
     * @return Oggetto Utente associato
     */
    public Utente getUtente() {
        return utente;
    }

    /**
     * Imposta l'utente associato a questo login.
     *
     * @param utente Nuovo utente da associare
     */
    public void setUtente(Utente utente) {
        this.utente = utente;
        if (utente != null) {
            this.utenteId = utente.getId();
        }
    }

    /**
     * Verifica se la password fornita corrisponde all'hash memorizzato.
     *
     * @param plainTextPassword Password in chiaro da verificare
     * @return true se la password è corretta
     */
    public boolean verificaPassword(String plainTextPassword) {
        if (plainTextPassword == null || plainTextPassword.isEmpty() || passwordHash == null) {
            return false;
        }
        return BCrypt.checkpw(plainTextPassword, passwordHash);
    }

    /**
     * Aggiorna l'ultimo accesso al momento corrente.
     */
    public void aggiornaUltimoAccesso() {
        this.ultimoAccesso = LocalDateTime.now();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        AdminLogin that = (AdminLogin) o;
        return id == that.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }

    @Override
    public String toString() {
        return "AdminLogin{" +
               "id=" + id +
               ", utenteId=" + utenteId +
               ", username='" + username + '\'' +
               ", ultimoAccesso=" + ultimoAccesso +
               '}';
    }
}

================
File: src/main/java/com/vending/core/models/Bevanda.java
================
package com.vending.core.models;

import java.util.ArrayList;
import java.util.List;

/**
 * Modello che rappresenta una bevanda disponibile nei distributori automatici.
 * Questa classe riflette la struttura della tabella 'bevanda' nel database
 * e gestisce le relazioni con le cialde attraverso la tabella 'bevandahacialda'.
 */
public class Bevanda {
    private int id;
    private String nome;
    private double prezzo;
    private List<Cialda> cialde;
    private String composizioneCialde; // Campo per la vista BevandeCialdeECosti

    /**
     * Costruttore predefinito.
     * Inizializza la lista delle cialde associate alla bevanda.
     */
    public Bevanda() {
        this.cialde = new ArrayList<>();
    }

    /**
     * Costruttore con parametri principali.
     *
     * @param nome Nome della bevanda
     * @param prezzo Prezzo della bevanda
     */
    public Bevanda(String nome, double prezzo) {
        this();
        this.nome = nome;
        this.prezzo = prezzo;
    }

    /**
     * Restituisce l'ID univoco della bevanda.
     *
     * @return ID della bevanda
     */
    public int getId() {
        return id;
    }

    /**
     * Imposta l'ID della bevanda.
     *
     * @param id Nuovo ID da impostare
     */
    public void setId(int id) {
        this.id = id;
    }

    /**
     * Restituisce il nome della bevanda.
     *
     * @return Nome della bevanda
     */
    public String getNome() {
        return nome;
    }

    /**
     * Imposta il nome della bevanda.
     *
     * @param nome Nuovo nome da impostare
     */
    public void setNome(String nome) {
        this.nome = nome;
    }

    /**
     * Restituisce il prezzo della bevanda.
     *
     * @return Prezzo della bevanda in double
     */
    public double getPrezzo() {
        return prezzo;
    }

    /**
     * Imposta il prezzo della bevanda.
     *
     * @param prezzo Nuovo prezzo da impostare
     */
    public void setPrezzo(double prezzo) {
        this.prezzo = prezzo;
    }

    /**
     * Restituisce la lista delle cialde necessarie per preparare la bevanda.
     *
     * @return Lista delle cialde associate
     */
    public List<Cialda> getCialde() {
        return cialde;
    }

    /**
     * Imposta la lista delle cialde necessarie per la bevanda.
     *
     * @param cialde Nuova lista di cialde
     */
    public void setCialde(List<Cialda> cialde) {
        this.cialde = cialde;
    }

    /**
     * Restituisce la descrizione della composizione delle cialde.
     * Questo campo viene popolato dalla vista BevandeCialdeECosti.
     *
     * @return Stringa contenente l'elenco delle cialde
     */
    public String getComposizioneCialde() {
        return composizioneCialde;
    }

    /**
     * Imposta la descrizione della composizione delle cialde.
     *
     * @param composizioneCialde Nuova descrizione della composizione
     */
    public void setComposizioneCialde(String composizioneCialde) {
        this.composizioneCialde = composizioneCialde;
    }

    /**
     * Verifica se la bevanda è disponibile in base alla presenza delle cialde necessarie.
     *
     * @param quantitaCialde Mappa delle quantità di cialde disponibili
     * @return true se tutte le cialde necessarie sono disponibili in quantità sufficiente
     */
    public boolean isDisponibile(List<QuantitaCialde> quantitaCialde) {
        for (Cialda cialda : cialde) {
            boolean cialdaDisponibile = quantitaCialde.stream()
                .anyMatch(qc -> qc.getCialdaId() == cialda.getId() && qc.getQuantita() > 0);
            if (!cialdaDisponibile) {
                return false;
            }
        }
        return true;
    }

    /**
     * Aggiunge una cialda alla lista delle cialde necessarie per la bevanda.
     * Verifica che la cialda non sia già presente prima di aggiungerla.
     *
     * @param cialda Cialda da aggiungere
     */
    public void aggiungiCialda(Cialda cialda) {
        if (!cialde.contains(cialda)) {
            cialde.add(cialda);
        }
    }

    /**
     * Rimuove una cialda dalla lista delle cialde necessarie per la bevanda.
     *
     * @param cialda Cialda da rimuovere
     */
    public void rimuoviCialda(Cialda cialda) {
        cialde.remove(cialda);
    }

    /**
     * Calcola il numero totale di cialde necessarie per preparare la bevanda.
     *
     * @return Numero totale di cialde richieste
     */
    public int getNumeroCialdeNecessarie() {
        return cialde.size();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Bevanda bevanda = (Bevanda) o;
        return id == bevanda.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }
}

================
File: src/main/java/com/vending/core/models/Cialda.java
================
package com.vending.core.models;

/**
 * Modello che rappresenta una cialda utilizzata nelle macchine distributrici.
 * Questa classe riflette la struttura della tabella 'cialda' nel database
 * e viene utilizzata nelle relazioni con le bevande attraverso la tabella 'bevandahacialda'.
 */
public class Cialda {
    private int id;
    private String nome;
    private String tipoCialda;

    /**
     * Costruttore predefinito.
     * Inizializza una nuova istanza di Cialda senza parametri.
     */
    public Cialda() {}

    /**
     * Costruttore con parametri principali.
     *
     * @param nome Nome della cialda
     * @param tipoCialda Tipo della cialda (es. Caffè, Tè, Tisana, Additivo)
     */
    public Cialda(String nome, String tipoCialda) {
        this.nome = nome;
        this.tipoCialda = tipoCialda;
    }

    /**
     * Restituisce l'ID univoco della cialda.
     *
     * @return ID della cialda
     */
    public int getId() {
        return id;
    }

    /**
     * Imposta l'ID della cialda.
     *
     * @param id Nuovo ID da impostare
     */
    public void setId(int id) {
        this.id = id;
    }

    /**
     * Restituisce il nome della cialda.
     *
     * @return Nome della cialda
     */
    public String getNome() {
        return nome;
    }

    /**
     * Imposta il nome della cialda.
     *
     * @param nome Nuovo nome da impostare
     */
    public void setNome(String nome) {
        this.nome = nome;
    }

    /**
     * Restituisce il tipo della cialda.
     * I tipi possibili includono: Caffè, Tè, Tisana, Additivo, ecc.
     *
     * @return Tipo della cialda
     */
    public String getTipoCialda() {
        return tipoCialda;
    }

    /**
     * Imposta il tipo della cialda.
     *
     * @param tipoCialda Nuovo tipo da impostare
     */
    public void setTipoCialda(String tipoCialda) {
        this.tipoCialda = tipoCialda;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Cialda cialda = (Cialda) o;
        return id == cialda.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }

    @Override
    public String toString() {
        return "Cialda{" +
               "id=" + id +
               ", nome='" + nome + '\'' +
               ", tipoCialda='" + tipoCialda + '\'' +
               '}';
    }
}

================
File: src/main/java/com/vending/core/models/Credenziale.java
================
package com.vending.core.models;

import java.time.LocalDateTime;

public class Credenziale {
    private int ID_Credenziale;
    private int ID_Utente;
    private String Username;
    private String PasswordHash;
    private LocalDateTime UltimoAccesso;

    // Getter e Setter
    public int getID_Credenziale() { return ID_Credenziale; }
    public void setID_Credenziale(int ID_Credenziale) { this.ID_Credenziale = ID_Credenziale; }

    public int getID_Utente() { return ID_Utente; }
    public void setID_Utente(int ID_Utente) { this.ID_Utente = ID_Utente; }

    public String getUsername() { return Username; }
    public void setUsername(String Username) { this.Username = Username; }

    public String getPasswordHash() { return PasswordHash; }
    public void setPasswordHash(String PasswordHash) { this.PasswordHash = PasswordHash; }

    public LocalDateTime getUltimoAccesso() { return UltimoAccesso; }
    public void setUltimoAccesso(LocalDateTime UltimoAccesso) { this.UltimoAccesso = UltimoAccesso; }
}

================
File: src/main/java/com/vending/core/models/Istituto.java
================
package com.vending.core.models;

import java.util.ArrayList;
import java.util.List;

/**
 * Modello che rappresenta un istituto dove sono installate le macchine distributrici.
 * Questa classe riflette la struttura della tabella 'istituto' nel database
 * e gestisce la relazione one-to-many con le macchine.
 */
public class Istituto {
    private int ID_istituto;
    private String nome;
    private String indirizzo;
    private List<Macchina> macchine;

    /**
     * Costruttore predefinito.
     * Inizializza la lista delle macchine associate all'istituto.
     */
    public Istituto() {
        this.macchine = new ArrayList<>();
    }

    /**
     * Costruttore con parametri principali.
     *
     * @param nome Nome dell'istituto
     * @param indirizzo Indirizzo completo dell'istituto
     */
    public Istituto(String nome, String indirizzo) {
        this();
        this.nome = nome;
        this.indirizzo = indirizzo;
    }

    /**
     * Restituisce l'ID univoco dell'istituto.
     *
     * @return ID dell'istituto
     */
    public int getId() {
        return ID_istituto;
    }

    /**
     * Imposta l'ID dell'istituto.
     *
     * @param id Nuovo ID da impostare
     */
    public void setId(int id) {
        this.ID_istituto = id;
    }

    /**
     * Restituisce il nome dell'istituto.
     *
     * @return Nome dell'istituto
     */
    public String getNome() {
        return nome;
    }

    /**
     * Imposta il nome dell'istituto.
     *
     * @param nome Nuovo nome da impostare
     */
    public void setNome(String nome) {
        this.nome = nome;
    }

    /**
     * Restituisce l'indirizzo dell'istituto.
     *
     * @return Indirizzo completo dell'istituto
     */
    public String getIndirizzo() {
        return indirizzo;
    }

    /**
     * Imposta l'indirizzo dell'istituto.
     *
     * @param indirizzo Nuovo indirizzo da impostare
     */
    public void setIndirizzo(String indirizzo) {
        this.indirizzo = indirizzo;
    }

    /**
     * Restituisce la lista delle macchine installate nell'istituto.
     *
     * @return Lista delle macchine associate
     */
    public List<Macchina> getMacchine() {
        return macchine;
    }

    /**
     * Imposta la lista delle macchine installate nell'istituto.
     *
     * @param macchine Nuova lista di macchine
     */
    public void setMacchine(List<Macchina> macchine) {
        this.macchine = macchine;
    }

    /**
     * Aggiunge una macchina alla lista delle macchine dell'istituto.
     *
     * @param macchina Macchina da aggiungere
     */
    public void aggiungiMacchina(Macchina macchina) {
        macchine.add(macchina);
    }

    /**
     * Rimuove una macchina dalla lista delle macchine dell'istituto.
     *
     * @param macchina Macchina da rimuovere
     */
    public void rimuoviMacchina(Macchina macchina) {
        macchine.remove(macchina);
    }

    /**
     * Conta il numero di macchine attive nell'istituto.
     *
     * @return Numero di macchine con stato "Attiva"
     */
    public long contaMacchineAttive() {
        return macchine.stream()
                .filter(m -> m.getStatoId() == 1) // 1 = Attiva nella tabella statomacchina
                .count();
    }

    /**
     * Verifica se l'istituto ha almeno una macchina installata.
     *
     * @return true se l'istituto ha almeno una macchina
     */
    public boolean haMacchine() {
        return !macchine.isEmpty();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Istituto istituto = (Istituto) o;
        return ID_istituto == istituto.ID_istituto;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(ID_istituto);
    }

    @Override
    public String toString() {
        return "Istituto{" +
               "ID_istituto=" + ID_istituto +
               ", nome='" + nome + '\'' +
               ", indirizzo='" + indirizzo + '\'' +
               ", numeroMacchine=" + macchine.size() +
               '}';
    }
}

================
File: src/main/java/com/vending/core/models/Macchina.java
================
package com.vending.core.models;

import java.util.ArrayList;
import java.util.List;

/**
 * Modello che rappresenta una macchina distributrice automatica.
 * Si basa sulla struttura del database definita nella tabella 'macchina'
 * e nelle sue relazioni.
 */
public class Macchina {
    private int id;
    private int istitutoId;
    private String nomeIstituto;
    private int statoId;
    private String statoDescrizione;
    private double cassaAttuale;
    private double cassaMassima;
    private double creditoAttuale;
    private List<QuantitaCialde> cialde;
    private List<Bevanda> bevande;

    /**
     * Costruttore predefinito che inizializza le liste e imposta i valori predefiniti.
     * Lo stato predefinito è 1 (Attiva) come definito nella tabella 'statomacchina'.
     */
    public Macchina() {
        this.cialde = new ArrayList<>();
        this.bevande = new ArrayList<>();
        this.creditoAttuale = 0.0;
        this.statoId = 1; // Stato "Attiva" come da tabella statomacchina
        this.cassaAttuale = 0.0;
    }

    // Getters e Setters
    /**
     * @return ID univoco della macchina
     */
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }

    /**
     * @return ID dell'istituto dove è installata la macchina
     */
    public int getIstitutoId() { return istitutoId; }
    public void setIstitutoId(int istitutoId) { this.istitutoId = istitutoId; }

    /**
     * @return Nome dell'istituto dove è installata la macchina
     */
    public String getNomeIstituto() { return nomeIstituto; }
    public void setNomeIstituto(String nomeIstituto) { this.nomeIstituto = nomeIstituto; }

    /**
     * @return ID dello stato della macchina dalla tabella 'statomacchina'
     */
    public int getStatoId() { return statoId; }
    public void setStatoId(int statoId) { this.statoId = statoId; }

    /**
     * @return Descrizione testuale dello stato della macchina
     */
    public String getStatoDescrizione() { return statoDescrizione; }
    public void setStatoDescrizione(String statoDescrizione) { this.statoDescrizione = statoDescrizione; }

    /**
     * @return Ammontare corrente in cassa
     */
    public double getCassaAttuale() { return cassaAttuale; }
    public void setCassaAttuale(double cassaAttuale) { this.cassaAttuale = cassaAttuale; }

    /**
     * @return Capacità  massima della cassa
     */
    public double getCassaMassima() { return cassaMassima; }
    public void setCassaMassima(double cassaMassima) { this.cassaMassima = cassaMassima; }

    /**
     * @return Credito attualmente inserito dall'utente
     */
    public double getCreditoAttuale() { return creditoAttuale; }
    public void setCreditoAttuale(double creditoAttuale) { this.creditoAttuale = creditoAttuale; }

    /**
     * @return Lista delle quantità  di cialde disponibili
     */
    public List<QuantitaCialde> getCialde() { return cialde; }
    public void setCialde(List<QuantitaCialde> cialde) { this.cialde = cialde; }

    /**
     * @return Lista delle bevande disponibili
     */
    public List<Bevanda> getBevande() { return bevande; }
    public void setBevande(List<Bevanda> bevande) { this.bevande = bevande; }

    
    /**
     * Verifica se la macchina può accettare un determinato importo.
     * 
     * @param importo Importo da verificare
     * @return true se l'importo può essere accettato
     */
    public boolean puoAccettareDenaro(double importo) {
        if(cassaAttuale+creditoAttuale+importo > cassaMassima) {
            return false;
        }
        else {
            return true;
        }
    }

    /**
     * Verifica se c'è credito sufficiente per una erogazione.
     * 
     * @param importo Importo da verificare
     * @return true se il credito è sufficiente
     */
    public boolean hasCreditorSufficiente(double importo) {
        if(creditoAttuale >= importo) {
            return true;
        }
        else {
            return false;
        }
    }

    /**
     * Verifica se la cassa ha raggiunto la capacità  massima.
     * 
     * @return true se la cassa è piena
     */
    public boolean isCassaPiena() {
        if(cassaAttuale == cassaMassima) {
            return true;
        }
        else {
            return false;
        }
    }

    /**
     * Verifica se la macchina è attiva e operativa.
     * 
     * @return true se la macchina è attiva
     */
    public boolean isAttiva() {
        return statoId == 1; // 1 = Attiva nella tabella statomacchina
    }

    /**
     * Aggiunge una bevanda alla lista delle bevande disponibili.
     * 
     * @param bevanda Bevanda da aggiungere
     */
    public void aggiungiBevanda(Bevanda bevanda) {
        bevande.add(bevanda);
    }

    /**
     * Aggiunge una quantità  di cialde alla lista.
     * 
     * @param cialda QuantitaCialde da aggiungere
     */
    public void aggiungiCialda(QuantitaCialde cialda) {
        cialde.add(cialda);
    }
}

================
File: src/main/java/com/vending/core/models/Manutenzione.java
================
package com.vending.core.models;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * Modello che rappresenta una richiesta di manutenzione per una macchina distributrice.
 * La classe gestisce le informazioni relative agli interventi di manutenzione,
 * integrando i dati dello stato della macchina e delle necessità di rifornimento.
 */
public class Manutenzione {
    private int id;
    private int macchinaId;
    private String tipoIntervento;  // Tipo di intervento (es. RIFORNIMENTO_CIALDE, SVUOTAMENTO_CASSA)
    private String descrizione;     // Descrizione del problema o dell'intervento
    private LocalDateTime dataRichiesta;
    private LocalDateTime dataCompletamento;
    private String stato;           // Stato della manutenzione (IN_ATTESA, IN_CORSO, COMPLETATA)
    private String urgenza;         // Urgenza dell'intervento (BASSA, MEDIA, ALTA)
    private int tecnicoId;          // ID del tecnico assegnato
    private String note;            // Note aggiuntive
    private List<QuantitaCialde> cialdeDaRifornire; // Lista delle cialde da rifornire

    /**
     * Costruttore predefinito.
     * Inizializza una nuova richiesta di manutenzione con data corrente e stato "IN_ATTESA".
     */
    public Manutenzione() {
        this.dataRichiesta = LocalDateTime.now();
        this.stato = "IN_ATTESA";
        this.urgenza = "MEDIA"; // Urgenza predefinita
        this.cialdeDaRifornire = new ArrayList<>();
    }

    /**
     * Costruttore con parametri principali.
     *
     * @param macchinaId ID della macchina che richiede manutenzione
     * @param tipoIntervento Tipo di intervento richiesto
     * @param descrizione Descrizione del problema o dell'intervento
     * @param urgenza Urgenza dell'intervento (BASSA, MEDIA, ALTA)
     */
    public Manutenzione(int macchinaId, String tipoIntervento, String descrizione, String urgenza) {
        this();
        this.macchinaId = macchinaId;
        this.tipoIntervento = tipoIntervento;
        this.descrizione = descrizione;
        this.urgenza = urgenza;
    }

    // Getters e Setters

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getMacchinaId() {
        return macchinaId;
    }

    public void setMacchinaId(int macchinaId) {
        this.macchinaId = macchinaId;
    }

    public String getTipoIntervento() {
        return tipoIntervento;
    }

    public void setTipoIntervento(String tipoIntervento) {
        this.tipoIntervento = tipoIntervento;
    }

    public String getDescrizione() {
        return descrizione;
    }

    public void setDescrizione(String descrizione) {
        this.descrizione = descrizione;
    }

    public LocalDateTime getDataRichiesta() {
        return dataRichiesta;
    }

    public void setDataRichiesta(LocalDateTime dataRichiesta) {
        this.dataRichiesta = dataRichiesta;
    }

    public LocalDateTime getDataCompletamento() {
        return dataCompletamento;
    }

    public void setDataCompletamento(LocalDateTime dataCompletamento) {
        this.dataCompletamento = dataCompletamento;
    }

    public String getStato() {
        return stato;
    }

    public void setStato(String stato) {
        this.stato = stato;
    }

    public String getUrgenza() {
        return urgenza;
    }

    public void setUrgenza(String urgenza) {
        this.urgenza = urgenza;
    }

    public int getTecnicoId() {
        return tecnicoId;
    }

    public void setTecnicoId(int tecnicoId) {
        this.tecnicoId = tecnicoId;
    }

    public String getNote() {
        return note;
    }

    public void setNote(String note) {
        this.note = note;
    }

    public List<QuantitaCialde> getCialdeDaRifornire() {
        return cialdeDaRifornire;
    }

    public void setCialdeDaRifornire(List<QuantitaCialde> cialdeDaRifornire) {
        this.cialdeDaRifornire = cialdeDaRifornire;
    }

    /**
     * Verifica se la manutenzione è in attesa.
     *
     * @return true se la manutenzione è in attesa, false altrimenti
     */
    public boolean isInAttesa() {
        return "IN_ATTESA".equals(stato);
    }

    /**
     * Verifica se la manutenzione è in corso.
     *
     * @return true se la manutenzione è in corso, false altrimenti
     */
    public boolean isInCorso() {
        return "IN_CORSO".equals(stato);
    }

    /**
     * Verifica se la manutenzione è completata.
     *
     * @return true se la manutenzione è completata, false altrimenti
     */
    public boolean isCompletata() {
        return "COMPLETATA".equals(stato);
    }

    /**
     * Imposta la manutenzione come completata.
     *
     * @param note Note di completamento
     * @param tecnicoId ID del tecnico che ha completato la manutenzione
     */
    public void completaManutenzione(String note, int tecnicoId) {
        this.stato = "COMPLETATA";
        this.dataCompletamento = LocalDateTime.now();
        this.note = note;
        this.tecnicoId = tecnicoId;
    }

    /**
     * Imposta la manutenzione come fuori servizio.
     */
    public void setFuoriServizio() {
        this.stato = "FUORI_SERVIZIO";
    }

    /**
     * Calcola la durata della manutenzione in minuti.
     *
     * @return Durata in minuti, -1 se la manutenzione non è completata
     */
    public long getDurataInMinuti() {
        if (dataCompletamento == null) {
            return -1;
        }
        return java.time.Duration.between(dataRichiesta, dataCompletamento).toMinutes();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Manutenzione that = (Manutenzione) o;
        return id == that.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }

    @Override
    public String toString() {
        return "Manutenzione{" +
                "id=" + id +
                ", macchinaId=" + macchinaId +
                ", tipoIntervento='" + tipoIntervento + '\'' +
                ", descrizione='" + descrizione + '\'' +
                ", dataRichiesta=" + dataRichiesta +
                ", dataCompletamento=" + dataCompletamento +
                ", stato='" + stato + '\'' +
                ", urgenza='" + urgenza + '\'' +
                ", tecnicoId=" + tecnicoId +
                ", note='" + note + '\'' +
                '}';
    }
}

================
File: src/main/java/com/vending/core/models/QuantitaCialde.java
================
package com.vending.core.models;

/**
 * Modello che rappresenta la quantità di cialde disponibili in una macchina.
 * Questa classe riflette la struttura della tabella 'quantitacialde' nel database
 * e gestisce le relazioni con le tabelle 'macchina' e 'cialda'.
 */
public class QuantitaCialde {
    private int id;
    private int macchinaId;
    private int cialdaId;
    private String nomeCialda;    // Dal JOIN con la tabella cialda
    private String tipoCialda;    // Dal JOIN con la tabella cialda
    private int quantita;
    private int quantitaMassima;
    private int sogliaMinima;     // Calcolato come 20% della quantità massima

    /**
     * Costruttore predefinito.
     */
    public QuantitaCialde() {
        this.sogliaMinima = 0;
    }

    /**
     * Costruttore con parametri principali.
     *
     * @param macchinaId ID della macchina
     * @param cialdaId ID della cialda
     * @param quantita Quantità attuale di cialde
     * @param quantitaMassima Quantità massima di cialde
     */
    public QuantitaCialde(int macchinaId, int cialdaId, int quantita, int quantitaMassima) {
        this.macchinaId = macchinaId;
        this.cialdaId = cialdaId;
        this.quantita = quantita;
        this.quantitaMassima = quantitaMassima;
        this.sogliaMinima = calcolaSogliaMinima();
    }

    /**
     * Restituisce l'ID univoco del record.
     *
     * @return ID del record di quantità cialde
     */
    public int getId() {
        return id;
    }

    /**
     * Imposta l'ID del record.
     *
     * @param id Nuovo ID da impostare
     */
    public void setId(int id) {
        this.id = id;
    }

    /**
     * Restituisce l'ID della macchina.
     *
     * @return ID della macchina
     */
    public int getMacchinaId() {
        return macchinaId;
    }

    /**
     * Imposta l'ID della macchina.
     *
     * @param macchinaId Nuovo ID della macchina
     */
    public void setMacchinaId(int macchinaId) {
        this.macchinaId = macchinaId;
    }

    /**
     * Restituisce l'ID della cialda.
     *
     * @return ID della cialda
     */
    public int getCialdaId() {
        return cialdaId;
    }

    /**
     * Imposta l'ID della cialda.
     *
     * @param cialdaId Nuovo ID della cialda
     */
    public void setCialdaId(int cialdaId) {
        this.cialdaId = cialdaId;
    }

    /**
     * Restituisce il nome della cialda.
     *
     * @return Nome della cialda
     */
    public String getNomeCialda() {
        return nomeCialda;
    }

    /**
     * Imposta il nome della cialda.
     *
     * @param nomeCialda Nuovo nome della cialda
     */
    public void setNomeCialda(String nomeCialda) {
        this.nomeCialda = nomeCialda;
    }

    /**
     * Restituisce il tipo della cialda.
     *
     * @return Tipo della cialda
     */
    public String getTipoCialda() {
        return tipoCialda;
    }

    /**
     * Imposta il tipo della cialda.
     *
     * @param tipoCialda Nuovo tipo della cialda
     */
    public void setTipoCialda(String tipoCialda) {
        this.tipoCialda = tipoCialda;
    }

    /**
     * Restituisce la quantità attuale di cialde.
     *
     * @return Quantità attuale
     */
    public int getQuantita() {
        return quantita;
    }

    /**
     * Imposta la quantità di cialde.
     *
     * @param quantita Nuova quantità da impostare
     */
    public void setQuantita(int quantita) {
        this.quantita = quantita;
    }

    /**
     * Restituisce la quantità massima di cialde.
     *
     * @return Quantità massima
     */
    public int getQuantitaMassima() {
        return quantitaMassima;
    }

    /**
     * Imposta la quantità massima di cialde e ricalcola la soglia minima.
     *
     * @param quantitaMassima Nuova quantità massima
     */
    public void setQuantitaMassima(int quantitaMassima) {
        this.quantitaMassima = quantitaMassima;
        this.sogliaMinima = calcolaSogliaMinima();
    }

    /**
     * Restituisce la soglia minima di cialde.
     *
     * @return Soglia minima
     */
    public int getSogliaMinima() {
        return sogliaMinima;
    }

    /**
     * Calcola la soglia minima come 20% della quantità massima.
     *
     * @return Soglia minima calcolata
     */
    private int calcolaSogliaMinima() {
        return (int) (quantitaMassima * 0.2);
    }

    /**
     * Verifica se è necessario il rifornimento delle cialde.
     *
     * @return true se la quantità è sotto la soglia minima
     */
    public boolean necessitaRifornimento() {
        return quantita <= sogliaMinima;
    }

    /**
     * Verifica se c'è una quantità sufficiente di cialde.
     *
     * @param quantitaRichiesta Quantità necessaria
     * @return true se la quantità disponibile è sufficiente
     */
    public boolean haQuantitaSufficiente(int quantitaRichiesta) {
        return quantita >= quantitaRichiesta;
    }

    /**
     * Decrementa la quantità di cialde di una unità.
     */
    public void decrementaQuantita() {
        if (quantita > 0) {
            quantita--;
        }
    }

    /**
     * Riempie il contenitore di cialde alla quantità massima.
     */
    public void rifornisci() {
        this.quantita = this.quantitaMassima;
    }

    /**
     * Calcola la quantità di cialde da rifornire.
     *
     * @return Quantità necessaria per il rifornimento completo
     */
    public int getQuantitaDaRifornire() {
        return quantitaMassima - quantita;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        QuantitaCialde that = (QuantitaCialde) o;
        return id == that.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }

    @Override
    public String toString() {
        return "QuantitaCialde{" +
               "id=" + id +
               ", macchinaId=" + macchinaId +
               ", nomeCialda='" + nomeCialda + '\'' +
               ", quantita=" + quantita +
               ", quantitaMassima=" + quantitaMassima +
               ", necessitaRifornimento=" + necessitaRifornimento() +
               '}';
    }
}

================
File: src/main/java/com/vending/core/models/Ricavo.java
================
package com.vending.core.models;

import java.time.LocalDateTime;

/**
 * Modello che rappresenta un ricavo da una macchina distributrice.
 * Questa classe riflette la struttura della tabella 'ricavo' nel database
 * e include informazioni aggiuntive dall'istituto associato.
 */
public class Ricavo {
    private int id;
    private int macchinaId;
    private String nomeIstituto;    // Dal JOIN con la tabella istituto
    private double importo;
    private LocalDateTime dataOra;
    private String indirizzoIstituto; // Dal JOIN con la tabella istituto
    private double ricavoGiornaliero; // Dalla vista ricavigiornalieri

    /**
     * Costruttore predefinito.
     * Inizializza la data e ora al momento corrente.
     */
    public Ricavo() {
        this.dataOra = LocalDateTime.now();
    }

    /**
     * Costruttore con parametri principali.
     *
     * @param macchinaId ID della macchina che ha generato il ricavo
     * @param importo Importo del ricavo
     */
    public Ricavo(int macchinaId, double importo) {
        this();
        this.macchinaId = macchinaId;
        this.importo = importo;
    }

    /**
     * Restituisce l'ID univoco del ricavo.
     *
     * @return ID del ricavo
     */
    public int getId() {
        return id;
    }

    /**
     * Imposta l'ID del ricavo.
     *
     * @param id Nuovo ID da impostare
     */
    public void setId(int id) {
        this.id = id;
    }

    /**
     * Restituisce l'ID della macchina che ha generato il ricavo.
     *
     * @return ID della macchina
     */
    public int getMacchinaId() {
        return macchinaId;
    }

    /**
     * Imposta l'ID della macchina.
     *
     * @param macchinaId Nuovo ID della macchina
     */
    public void setMacchinaId(int macchinaId) {
        this.macchinaId = macchinaId;
    }

    /**
     * Restituisce il nome dell'istituto dove si trova la macchina.
     *
     * @return Nome dell'istituto
     */
    public String getNomeIstituto() {
        return nomeIstituto;
    }

    /**
     * Imposta il nome dell'istituto.
     *
     * @param nomeIstituto Nuovo nome dell'istituto
     */
    public void setNomeIstituto(String nomeIstituto) {
        this.nomeIstituto = nomeIstituto;
    }

    /**
     * Restituisce l'importo del ricavo.
     *
     * @return Importo del ricavo
     */
    public double getImporto() {
        return importo;
    }

    /**
     * Imposta l'importo del ricavo.
     *
     * @param importo Nuovo importo da impostare
     */
    public void setImporto(double importo) {
        this.importo = importo;
    }

    /**
     * Restituisce la data e ora del ricavo.
     *
     * @return Data e ora del ricavo
     */
    public LocalDateTime getDataOra() {
        return dataOra;
    }

    /**
     * Imposta la data e ora del ricavo.
     *
     * @param dataOra Nuova data e ora da impostare
     */
    public void setDataOra(LocalDateTime dataOra) {
        this.dataOra = dataOra;
    }

    /**
     * Restituisce l'indirizzo dell'istituto.
     *
     * @return Indirizzo dell'istituto
     */
    public String getIndirizzoIstituto() {
        return indirizzoIstituto;
    }

    /**
     * Imposta l'indirizzo dell'istituto.
     *
     * @param indirizzoIstituto Nuovo indirizzo dell'istituto
     */
    public void setIndirizzoIstituto(String indirizzoIstituto) {
        this.indirizzoIstituto = indirizzoIstituto;
    }

    /**
     * Restituisce il ricavo giornaliero totale.
     *
     * @return Ricavo giornaliero
     */
    public double getRicavoGiornaliero() {
        return ricavoGiornaliero;
    }

    /**
     * Imposta il ricavo giornaliero totale.
     *
     * @param ricavoGiornaliero Nuovo ricavo giornaliero
     */
    public void setRicavoGiornaliero(double ricavoGiornaliero) {
        this.ricavoGiornaliero = ricavoGiornaliero;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Ricavo ricavo = (Ricavo) o;
        return id == ricavo.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }

    @Override
    public String toString() {
        return "Ricavo{" +
               "id=" + id +
               ", macchinaId=" + macchinaId +
               ", nomeIstituto='" + nomeIstituto + '\'' +
               ", importo=" + importo +
               ", dataOra=" + dataOra +
               '}';
    }
}

================
File: src/main/java/com/vending/core/models/StatoMacchina.java
================
package com.vending.core.models;

/**
 * Modello che rappresenta lo stato possibile di una macchina distributrice.
 * Questa classe riflette la struttura della tabella 'statomacchina' nel database,
 * che definisce gli stati possibili per le macchine distributrici.
 */
public class StatoMacchina {
    private int id;
    private String descrizione;
    
    /**
     * Costanti che rappresentano gli stati predefiniti dal database.
     */
    public static final int STATO_ATTIVA = 1;
    public static final int STATO_IN_MANUTENZIONE = 2;
    public static final int STATO_FUORI_SERVIZIO = 3;

    /**
     * Costruttore predefinito.
     */
    public StatoMacchina() {}

    /**
     * Costruttore con parametri principali.
     *
     * @param id ID dello stato
     * @param descrizione Descrizione dello stato
     */
    public StatoMacchina(int id, String descrizione) {
        this.id = id;
        this.descrizione = descrizione;
    }

    /**
     * Restituisce l'ID univoco dello stato.
     *
     * @return ID dello stato
     */
    public int getId() {
        return id;
    }

    /**
     * Imposta l'ID dello stato.
     *
     * @param id Nuovo ID da impostare
     */
    public void setId(int id) {
        this.id = id;
    }

    /**
     * Restituisce la descrizione dello stato.
     *
     * @return Descrizione dello stato
     */
    public String getDescrizione() {
        return descrizione;
    }

    /**
     * Imposta la descrizione dello stato.
     *
     * @param descrizione Nuova descrizione da impostare
     */
    public void setDescrizione(String descrizione) {
        this.descrizione = descrizione;
    }

    /**
     * Verifica se lo stato corrisponde a "Attiva".
     *
     * @return true se la macchina è attiva
     */
    public boolean isAttiva() {
        return id == STATO_ATTIVA;
    }

    /**
     * Verifica se lo stato corrisponde a "In manutenzione".
     *
     * @return true se la macchina è in manutenzione
     */
    public boolean isInManutenzione() {
        return id == STATO_IN_MANUTENZIONE;
    }

    /**
     * Verifica se lo stato corrisponde a "Fuori servizio".
     *
     * @return true se la macchina è fuori servizio
     */
    public boolean isFuoriServizio() {
        return id == STATO_FUORI_SERVIZIO;
    }

    /**
     * Verifica se la macchina può erogare bevande in questo stato.
     *
     * @return true se la macchina può erogare bevande
     */
    public boolean puoErogareBevande() {
        return isAttiva();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        StatoMacchina that = (StatoMacchina) o;
        return id == that.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }

    @Override
    public String toString() {
        return "StatoMacchina{" +
               "id=" + id +
               ", descrizione='" + descrizione + '\'' +
               '}';
    }
}

================
File: src/main/java/com/vending/core/models/Transazione.java
================
package com.vending.core.models;

import java.time.LocalDateTime;

/**
 * Modello che rappresenta una transazione di vendita di una bevanda.
 * Questa classe riflette la struttura della tabella 'transazione' nel database
 * e include informazioni aggiuntive dalle tabelle correlate e dalla vista 'transazionirecenti'.
 */
public class Transazione {
    private int id;
    private int macchinaId;
    private String nomeIstituto;    // Dal JOIN con la tabella istituto
    private int bevandaId;
    private String nomeBevanda;     // Dal JOIN con la tabella bevanda
    private Double importo;
    private LocalDateTime dataOra;

    /**
     * Costruttore predefinito.
     * Inizializza la data e ora al momento corrente.
     */
    public Transazione() {
        this.dataOra = LocalDateTime.now();
    }

    /**
     * Costruttore con parametri principali.
     *
     * @param macchinaId ID della macchina che ha eseguito la transazione
     * @param bevandaId ID della bevanda erogata
     * @param importo Importo della transazione
     */
    public Transazione(int macchinaId, int bevandaId, Double importo) {
        this();
        this.macchinaId = macchinaId;
        this.bevandaId = bevandaId;
        this.importo = importo;
    }

    /**
     * Restituisce l'ID univoco della transazione.
     *
     * @return ID della transazione
     */
    public int getId() {
        return id;
    }

    /**
     * Imposta l'ID della transazione.
     *
     * @param id Nuovo ID da impostare
     */
    public void setId(int id) {
        this.id = id;
    }

    /**
     * Restituisce l'ID della macchina che ha eseguito la transazione.
     *
     * @return ID della macchina
     */
    public int getMacchinaId() {
        return macchinaId;
    }

    /**
     * Imposta l'ID della macchina.
     *
     * @param macchinaId Nuovo ID della macchina
     */
    public void setMacchinaId(int macchinaId) {
        this.macchinaId = macchinaId;
    }

    /**
     * Restituisce il nome dell'istituto dove si trova la macchina.
     *
     * @return Nome dell'istituto
     */
    public String getNomeIstituto() {
        return nomeIstituto;
    }

    /**
     * Imposta il nome dell'istituto.
     *
     * @param nomeIstituto Nuovo nome dell'istituto
     */
    public void setNomeIstituto(String nomeIstituto) {
        this.nomeIstituto = nomeIstituto;
    }

    /**
     * Restituisce l'ID della bevanda erogata.
     *
     * @return ID della bevanda
     */
    public int getBevandaId() {
        return bevandaId;
    }

    /**
     * Imposta l'ID della bevanda.
     *
     * @param bevandaId Nuovo ID della bevanda
     */
    public void setBevandaId(int bevandaId) {
        this.bevandaId = bevandaId;
    }

    /**
     * Restituisce il nome della bevanda erogata.
     *
     * @return Nome della bevanda
     */
    public String getNomeBevanda() {
        return nomeBevanda;
    }

    /**
     * Imposta il nome della bevanda.
     *
     * @param nomeBevanda Nuovo nome della bevanda
     */
    public void setNomeBevanda(String nomeBevanda) {
        this.nomeBevanda = nomeBevanda;
    }

    /**
     * Restituisce l'importo della transazione.
     *
     * @return Importo della transazione
     */
    public Double getImporto() {
        return importo;
    }

    /**
     * Imposta l'importo della transazione.
     *
     * @param importo Nuovo importo da impostare
     */
    public void setImporto(Double importo) {
        this.importo = importo;
    }

    /**
     * Restituisce la data e ora della transazione.
     *
     * @return Data e ora della transazione
     */
    public LocalDateTime getDataOra() {
        return dataOra;
    }

    /**
     * Imposta la data e ora della transazione.
     *
     * @param dataOra Nuova data e ora da impostare
     */
    public void setDataOra(LocalDateTime dataOra) {
        this.dataOra = dataOra;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Transazione that = (Transazione) o;
        return id == that.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }

    @Override
    public String toString() {
        return "Transazione{" +
               "id=" + id +
               ", macchinaId=" + macchinaId +
               ", nomeIstituto='" + nomeIstituto + '\'' +
               ", nomeBevanda='" + nomeBevanda + '\'' +
               ", importo=" + importo +
               ", dataOra=" + dataOra +
               '}';
    }
}

================
File: src/main/java/com/vending/core/models/Utente.java
================
package com.vending.core.models;

import org.mindrot.jbcrypt.BCrypt;
import java.time.LocalDateTime;

/**
 * Classe che rappresenta un utente del sistema di distribuzione automatica.
 * Questa classe riflette la struttura delle tabelle 'utente' e 'adminlogin' nel database,
 * gestendo le informazioni dell'utente e la sicurezza delle credenziali attraverso BCrypt.
 */
public class Utente {
    private int id;
    private String nome;
    private String ruolo;
    private int ruoloId;
    private String username;        // Da adminlogin
    private String passwordHash;    // Da adminlogin
    private LocalDateTime ultimoAccesso; // Da adminlogin
    

    /**
     * Costruttore predefinito.
     */
    public Utente() {}

    /**
     * Costruttore con parametri principali.
     *
     * @param nome Nome completo dell'utente
     * @param ruolo Ruolo dell'utente (Amministratore, Tecnico, Operatore)
     * @param username Nome utente per l'accesso
     * @param password Password in chiaro che verrà crittografata
     */
    public Utente(String nome, String ruolo, String username, String password) {
        this.nome = nome;
        this.ruolo = ruolo;
        this.ruoloId = ruoloId;
        this.username = username;
        setPassword(password);
    }

    /**
     * Restituisce l'ID univoco dell'utente.
     *
     * @return ID dell'utente
     */
    public int getId() {
        return id;
    }

    /**
     * Imposta l'ID dell'utente.
     *
     * @param id Nuovo ID da impostare
     */
    public void setId(int id) {
        this.id = id;
    }

    /**
     * Restituisce il nome dell'utente.
     *
     * @return Nome completo dell'utente
     */
    public String getNome() {
        return nome;
    }

    /**
     * Imposta il nome dell'utente.
     *
     * @param nome Nuovo nome da impostare
     */
    public void setNome(String nome) {
        this.nome = nome;
    }

    /**
     * Restituisce il ruolo dell'utente.
     *
     * @return Ruolo dell'utente nel sistema
     */
    public String getRuolo() {
        return ruolo;
    }

    /**
     * Imposta il ruolo dell'utente.
     *
     * @param ruolo Nuovo ruolo da impostare
     */
    public void setRuolo(String ruolo) {
        this.ruolo = ruolo;
    }
    
    /**
     * Restituisce l'ID del ruolo dell'utente.
     *
     * @return ID del ruolo dell'utente
     */
    public int getRuoloId() {
        return ruoloId;
    }

    /**
     * Imposta l'ID del ruolo dell'utente.
     *
     * @param ruoloId Nuovo ID del ruolo da impostare
     */
    public void setRuoloId(int ruoloId) {
        this.ruoloId = ruoloId;
    }

    /**
     * Restituisce il nome utente per l'accesso.
     *
     * @return Nome utente
     */
    public String getUsername() {
        return username;
    }

    /**
     * Imposta il nome utente per l'accesso.
     *
     * @param username Nuovo nome utente da impostare
     */
    public void setUsername(String username) {
        this.username = username;
    }

    /**
     * Restituisce l'hash della password.
     *
     * @return Hash della password
     */
    public String getPasswordHash() {
        return passwordHash;
    }

    /**
     * Imposta e cripta la password dell'utente.
     * La password viene sottoposta a hashing prima del salvataggio.
     *
     * @param password Password in chiaro da crittografare
     */
    public void setPassword(String password) {
        if (password != null && !password.isEmpty()) {
            this.passwordHash = getPasswordHash(password);
        }
    }

    public void setPasswordHash(String passwordHash) {
		this.passwordHash = passwordHash;
	}

	/**
     * Restituisce la data e ora dell'ultimo accesso.
     *
     * @return Data e ora dell'ultimo accesso
     */
    public LocalDateTime getUltimoAccesso() {
        return ultimoAccesso;
    }

    /**
     * Imposta la data e ora dell'ultimo accesso.
     *
     * @param ultimoAccesso Nuova data e ora dell'ultimo accesso
     */
    public void setUltimoAccesso(LocalDateTime ultimoAccesso) {
        this.ultimoAccesso = ultimoAccesso;
    }

    /**
     * Verifica se l'utente è un amministratore.
     *
     * @return true se l'utente è un amministratore
     */
    public boolean isAmministratore() {
        return "Amministratore".equals(ruolo);
    }

    /**
     * Verifica se l'utente è un tecnico.
     *
     * @return true se l'utente è un tecnico
     */
    public boolean isTecnico() {
        return "Tecnico".equals(ruolo);
    }

    /**
     * Verifica se l'utente è un operatore.
     *
     * @return true se l'utente è un operatore
     */
    public boolean isOperatore() {
        return "Operatore".equals(ruolo);
    }
    

    /**
     * Genera un hash sicuro della password usando BCrypt.
     *
     * @param password Password in chiaro da crittografare
     * @return Hash della password
     * @throws IllegalArgumentException se la password è null o vuota
     */
    public static String getPasswordHash(String password) {
        if (password == null || password.isEmpty()) {
            throw new IllegalArgumentException("La password non può essere null o vuota");
        }
        return BCrypt.hashpw(password, BCrypt.gensalt(12));
    }

    /**
     * Verifica se la password fornita corrisponde all'hash memorizzato.
     *
     * @param plainTextPassword Password in chiaro da verificare
     * @return true se la password è corretta
     */
    public boolean verifyPassword(String plainTextPassword) {
        if (plainTextPassword == null || plainTextPassword.isEmpty() || passwordHash == null) {
            return false;
        }
        return BCrypt.checkpw(plainTextPassword, passwordHash);
    }

    /**
     * Aggiorna l'ultimo accesso dell'utente al momento corrente.
     */
    public void aggiornaUltimoAccesso() {
        this.ultimoAccesso = LocalDateTime.now();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Utente utente = (Utente) o;
        return id == utente.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }

    @Override
    public String toString() {
        return "Utente{" +
               "id=" + id +
               ", nome='" + nome + '\'' +
               ", ruolo='" + ruolo + '\'' +
               ", username='" + username + '\'' +
               ", ultimoAccesso=" + ultimoAccesso +
               '}';
    }
}

================
File: src/main/java/com/vending/core/repositories/AdminLoginRepository.java
================
package com.vending.core.repositories;

import com.vending.core.models.AdminLogin;
import com.vending.core.models.Utente;
import java.sql.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Repository per la gestione dei dati di accesso amministrativo nel database.
 * Gestisce le operazioni CRUD per la tabella 'adminlogin'.
 */
public class AdminLoginRepository {
    private final DatabaseConnection dbConnection;
    private final UtenteRepository utenteRepository;

    /**
     * Costruttore del repository.
     *
     * @param utenteRepository repository per l'accesso ai dati degli utenti
     */
    public AdminLoginRepository(UtenteRepository utenteRepository) {
        this.dbConnection = DatabaseConnection.getInstance();
        this.utenteRepository = utenteRepository;
    }

    /**
     * Trova tutti gli accessi amministrativi.
     *
     * @return lista di tutti gli accessi
     */
    public List<AdminLogin> findAll() {
        List<AdminLogin> adminLogins = new ArrayList<>();
        String sql = "SELECT * FROM adminlogin";
        
        try (Connection conn = dbConnection.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            
            while (rs.next()) {
                AdminLogin adminLogin = mapResultSetToAdminLogin(rs);
                caricaUtente(adminLogin);
                adminLogins.add(adminLogin);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero degli accessi amministrativi", e);
        }
        return adminLogins;
    }

    /**
     * Trova un accesso amministrativo tramite ID.
     *
     * @param id ID dell'accesso amministrativo
     * @return Optional contenente l'accesso se trovato
     */
    public Optional<AdminLogin> findById(int id) {
        String sql = "SELECT * FROM adminlogin WHERE ID_AdminLogin = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                AdminLogin adminLogin = mapResultSetToAdminLogin(rs);
                caricaUtente(adminLogin);
                return Optional.of(adminLogin);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero dell'accesso amministrativo", e);
        }
        return Optional.empty();
    }

    /**
     * Trova un accesso amministrativo tramite username.
     *
     * @param username username da cercare
     * @return Optional contenente l'accesso se trovato
     */
    public Optional<AdminLogin> findByUsername(String username) {
        String sql = "SELECT * FROM adminlogin WHERE Username = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, username);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                AdminLogin adminLogin = mapResultSetToAdminLogin(rs);
                caricaUtente(adminLogin);
                return Optional.of(adminLogin);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero dell'accesso amministrativo", e);
        }
        return Optional.empty();
    }

    /**
     * Trova un accesso amministrativo tramite ID utente.
     *
     * @param utenteId ID dell'utente
     * @return Optional contenente l'accesso se trovato
     */
    public Optional<AdminLogin> findByUtenteId(int utenteId) {
        String sql = "SELECT * FROM adminlogin WHERE ID_Utente = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, utenteId);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                AdminLogin adminLogin = mapResultSetToAdminLogin(rs);
                caricaUtente(adminLogin);
                return Optional.of(adminLogin);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero dell'accesso amministrativo", e);
        }
        return Optional.empty();
    }

    /**
     * Salva un nuovo accesso amministrativo.
     *
     * @param adminLogin accesso amministrativo da salvare
     * @return accesso amministrativo salvato con ID generato
     */
    public AdminLogin save(AdminLogin adminLogin) {
        String sql = "INSERT INTO adminlogin (ID_Utente, Username, PasswordHash, UltimoAccesso) " +
                    "VALUES (?, ?, ?, ?)";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            
            stmt.setInt(1, adminLogin.getUtenteId());
            stmt.setString(2, adminLogin.getUsername());
            stmt.setString(3, adminLogin.getPasswordHash());
            stmt.setTimestamp(4, Timestamp.valueOf(adminLogin.getUltimoAccesso()));
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("La creazione dell'accesso amministrativo è fallita");
            }
            
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    adminLogin.setId(generatedKeys.getInt(1));
                    return adminLogin;
                } else {
                    throw new SQLException("La creazione dell'accesso amministrativo è fallita, nessun ID ottenuto");
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il salvataggio dell'accesso amministrativo", e);
        }
    }

    /**
     * Aggiorna un accesso amministrativo esistente.
     *
     * @param adminLogin accesso amministrativo da aggiornare
     * @return accesso amministrativo aggiornato
     */
    public AdminLogin update(AdminLogin adminLogin) {
        String sql = "UPDATE adminlogin SET Username = ?, PasswordHash = ?, UltimoAccesso = ? " +
                    "WHERE ID_AdminLogin = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, adminLogin.getUsername());
            stmt.setString(2, adminLogin.getPasswordHash());
            stmt.setTimestamp(3, Timestamp.valueOf(adminLogin.getUltimoAccesso()));
            stmt.setInt(4, adminLogin.getId());
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("L'aggiornamento dell'accesso amministrativo è fallito");
            }
            
            return adminLogin;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'aggiornamento dell'accesso amministrativo", e);
        }
    }

    /**
     * Elimina un accesso amministrativo.
     *
     * @param id ID dell'accesso amministrativo da eliminare
     * @return true se l'eliminazione ha successo
     */
    public boolean delete(int id) {
        String sql = "DELETE FROM adminlogin WHERE ID_AdminLogin = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            int affectedRows = stmt.executeUpdate();
            
            return affectedRows > 0;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'eliminazione dell'accesso amministrativo", e);
        }
    }

    /**
     * Converte un ResultSet in un oggetto AdminLogin.
     */
    private AdminLogin mapResultSetToAdminLogin(ResultSet rs) throws SQLException {
        AdminLogin adminLogin = new AdminLogin();
        adminLogin.setId(rs.getInt("ID_AdminLogin"));
        adminLogin.setUtenteId(rs.getInt("ID_Utente"));
        adminLogin.setUsername(rs.getString("Username"));
        adminLogin.setPasswordHash(rs.getString("PasswordHash"));
        Timestamp timestamp = rs.getTimestamp("UltimoAccesso");
        if (timestamp != null) {
            adminLogin.setUltimoAccesso(timestamp.toLocalDateTime());
        }
        return adminLogin;
    }

    /**
     * Carica l'utente associato all'accesso amministrativo.
     */
    private void caricaUtente(AdminLogin adminLogin) {
        utenteRepository.findById(adminLogin.getUtenteId())
                .ifPresent(adminLogin::setUtente);
    }
}

================
File: src/main/java/com/vending/core/repositories/BevandaRepository.java
================
package com.vending.core.repositories;

import com.vending.core.models.Bevanda;
import com.vending.core.models.Cialda;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Repository per la gestione delle bevande nel database.
 * Gestisce le operazioni CRUD per la tabella 'bevanda' e le relazioni
 * con la tabella 'bevandahacialda'.
 */
public class BevandaRepository {
    private final DatabaseConnection dbConnection;
    private final CialdaRepository cialdaRepository;

    /**
     * Costruttore del repository.
     *
     * @param cialdaRepository repository per l'accesso ai dati delle cialde
     */
    public BevandaRepository(CialdaRepository cialdaRepository) {
        this.dbConnection = DatabaseConnection.getInstance();
        this.cialdaRepository = cialdaRepository;
    }

    /**
     * Trova tutte le bevande disponibili.
     *
     * @return lista di tutte le bevande con le relative cialde
     */
    public List<Bevanda> findAll() {
        List<Bevanda> bevande = new ArrayList<>();
        String sql = "SELECT * FROM bevanda";
        
        try (Connection conn = dbConnection.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            
            while (rs.next()) {
                Bevanda bevanda = mapResultSetToBevanda(rs);
                caricaCialde(bevanda);
                bevande.add(bevanda);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero delle bevande", e);
        }
        return bevande;
    }

    /**
     * Trova una bevanda tramite ID.
     *
     * @param id ID della bevanda
     * @return Optional contenente la bevanda se trovata
     */
    public Optional<Bevanda> findById(int id) {
        String sql = "SELECT * FROM bevanda WHERE ID_Bevanda = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                Bevanda bevanda = mapResultSetToBevanda(rs);
                caricaCialde(bevanda);
                return Optional.of(bevanda);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero della bevanda", e);
        }
        return Optional.empty();
    }

    /**
     * Trova le bevande disponibili per una specifica macchina.
     *
     * @param macchinaId ID della macchina
     * @return lista delle bevande disponibili per la macchina
     */
    public List<Bevanda> findByMacchinaId(int macchinaId) {
        List<Bevanda> bevande = new ArrayList<>();
        String sql = "SELECT b.* FROM bevanda b " +
                    "JOIN macchinahabevanda mhb ON b.ID_Bevanda = mhb.ID_Bevanda " +
                    "WHERE mhb.ID_Macchina = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, macchinaId);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                Bevanda bevanda = mapResultSetToBevanda(rs);
                caricaCialde(bevanda);
                bevande.add(bevanda);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero delle bevande della macchina", e);
        }
        return bevande;
    }

    /**
     * Salva una nuova bevanda.
     *
     * @param bevanda bevanda da salvare
     * @return bevanda salvata con ID generato
     */
    public Bevanda save(Bevanda bevanda) {
        String sql = "INSERT INTO bevanda (Nome, Prezzo) VALUES (?, ?)";
        
        try (Connection conn = dbConnection.getConnection()) {
            conn.setAutoCommit(false);
            try (PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
                stmt.setString(1, bevanda.getNome());
                stmt.setDouble(2, bevanda.getPrezzo());
                
                int affectedRows = stmt.executeUpdate();
                if (affectedRows == 0) {
                    throw new SQLException("La creazione della bevanda è fallita");
                }
                
                try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        bevanda.setId(generatedKeys.getInt(1));
                        salvaCialde(conn, bevanda);
                        conn.commit();
                        return bevanda;
                    } else {
                        throw new SQLException("La creazione della bevanda è fallita, nessun ID ottenuto");
                    }
                }
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il salvataggio della bevanda", e);
        }
    }

    /**
     * Aggiorna una bevanda esistente.
     *
     * @param bevanda bevanda da aggiornare
     * @return bevanda aggiornata
     */
    public Bevanda update(Bevanda bevanda) {
        String sql = "UPDATE bevanda SET Nome = ?, Prezzo = ? WHERE ID_Bevanda = ?";
        
        try (Connection conn = dbConnection.getConnection()) {
            conn.setAutoCommit(false);
            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setString(1, bevanda.getNome());
                stmt.setDouble(2, bevanda.getPrezzo());
                stmt.setInt(3, bevanda.getId());
                
                int affectedRows = stmt.executeUpdate();
                if (affectedRows == 0) {
                    throw new SQLException("L'aggiornamento della bevanda è fallito");
                }
                
                aggiornaCialde(conn, bevanda);
                conn.commit();
                return bevanda;
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'aggiornamento della bevanda", e);
        }
    }

    /**
     * Elimina una bevanda.
     *
     * @param id ID della bevanda da eliminare
     * @return true se l'eliminazione ha successo
     */
    public boolean delete(int id) {
        String sql = "DELETE FROM bevanda WHERE ID_Bevanda = ?";
        
        try (Connection conn = dbConnection.getConnection()) {
            conn.setAutoCommit(false);
            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                eliminaCialde(conn, id);
                
                stmt.setInt(1, id);
                int affectedRows = stmt.executeUpdate();
                
                conn.commit();
                return affectedRows > 0;
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'eliminazione della bevanda", e);
        }
    }

    /**
     * Converte un ResultSet in un oggetto Bevanda.
     */
    private Bevanda mapResultSetToBevanda(ResultSet rs) throws SQLException {
        Bevanda bevanda = new Bevanda();
        bevanda.setId(rs.getInt("ID_Bevanda"));
        bevanda.setNome(rs.getString("Nome"));
        bevanda.setPrezzo(rs.getDouble("Prezzo"));
        return bevanda;
    }

    /**
     * Carica le cialde associate alla bevanda.
     */
    private void caricaCialde(Bevanda bevanda) throws SQLException {
        String sql = "SELECT c.* FROM cialda c " +
                    "JOIN bevandahacialda bhc ON c.ID_Cialda = bhc.ID_Cialda " +
                    "WHERE bhc.ID_Bevanda = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, bevanda.getId());
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                Cialda cialda = new Cialda();
                cialda.setId(rs.getInt("ID_Cialda"));
                cialda.setNome(rs.getString("Nome"));
                cialda.setTipoCialda(rs.getString("TipoCialda"));
                bevanda.getCialde().add(cialda);
            }
        }
    }

    /**
     * Salva le associazioni tra bevanda e cialde.
     */
    private void salvaCialde(Connection conn, Bevanda bevanda) throws SQLException {
        String sql = "INSERT INTO bevandahacialda (ID_Bevanda, ID_Cialda) VALUES (?, ?)";
        
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            for (Cialda cialda : bevanda.getCialde()) {
                stmt.setInt(1, bevanda.getId());
                stmt.setInt(2, cialda.getId());
                stmt.addBatch();
            }
            stmt.executeBatch();
        }
    }

    /**
     * Aggiorna le associazioni tra bevanda e cialde.
     */
    private void aggiornaCialde(Connection conn, Bevanda bevanda) throws SQLException {
        String deleteSQL = "DELETE FROM bevandahacialda WHERE ID_Bevanda = ?";
        try (PreparedStatement stmt = conn.prepareStatement(deleteSQL)) {
            stmt.setInt(1, bevanda.getId());
            stmt.executeUpdate();
        }
        salvaCialde(conn, bevanda);
    }

    /**
     * Elimina tutte le associazioni tra bevanda e cialde.
     */
    private void eliminaCialde(Connection conn, int bevandaId) throws SQLException {
        String sql = "DELETE FROM bevandahacialda WHERE ID_Bevanda = ?";
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, bevandaId);
            stmt.executeUpdate();
        }
    }
}

================
File: src/main/java/com/vending/core/repositories/CialdaRepository.java
================
package com.vending.core.repositories;

import com.vending.core.models.Cialda;
import com.vending.core.models.QuantitaCialde;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Repository per la gestione delle cialde nel database.
 * Gestisce le operazioni CRUD per la tabella 'cialda' e le relazioni
 * con la tabella 'quantitacialde'.
 */
public class CialdaRepository {
    private final DatabaseConnection dbConnection;

    /**
     * Costruttore del repository.
     */
    public CialdaRepository() {
        this.dbConnection = DatabaseConnection.getInstance();
    }

    /**
     * Trova tutte le cialde disponibili.
     *
     * @return lista di tutte le cialde
     */
    public List<Cialda> findAll() {
        List<Cialda> cialde = new ArrayList<>();
        String sql = "SELECT * FROM cialda";
        
        try (Connection conn = dbConnection.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            
            while (rs.next()) {
                cialde.add(mapResultSetToCialda(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero delle cialde", e);
        }
        return cialde;
    }

    /**
     * Trova una cialda tramite ID.
     *
     * @param id ID della cialda
     * @return Optional contenente la cialda se trovata
     */
    public Optional<Cialda> findById(int id) {
        String sql = "SELECT * FROM cialda WHERE ID_Cialda = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return Optional.of(mapResultSetToCialda(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero della cialda", e);
        }
        return Optional.empty();
    }

    /**
     * Trova le cialde di un determinato tipo.
     *
     * @param tipoCialda tipo di cialda da cercare
     * @return lista delle cialde del tipo specificato
     */
    public List<Cialda> findByTipo(String tipoCialda) {
        List<Cialda> cialde = new ArrayList<>();
        String sql = "SELECT * FROM cialda WHERE TipoCialda = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, tipoCialda);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                cialde.add(mapResultSetToCialda(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero delle cialde per tipo", e);
        }
        return cialde;
    }

    /**
     * Trova la quantità disponibile di una cialda in una macchina.
     *
     * @param idCialda ID della cialda
     * @param idMacchina ID della macchina
     * @return Optional contenente la quantità di cialde se trovata
     */
    public Optional<QuantitaCialde> getQuantitaDisponibileByMacchina(int idCialda, int idMacchina) {
        String sql = "SELECT qc.*, c.Nome as NomeCialda, c.TipoCialda " +
                    "FROM quantitacialde qc " +
                    "JOIN cialda c ON qc.ID_Cialda = c.ID_Cialda " +
                    "WHERE qc.ID_Cialda = ? AND qc.ID_Macchina = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, idCialda);
            stmt.setInt(2, idMacchina);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return Optional.of(mapResultSetToQuantitaCialde(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero della quantità cialde", e);
        }
        return Optional.empty();
    }

    /**
     * Salva una nuova cialda.
     *
     * @param cialda cialda da salvare
     * @return cialda salvata con ID generato
     */
    public Cialda save(Cialda cialda) {
        String sql = "INSERT INTO cialda (Nome, TipoCialda) VALUES (?, ?)";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            
            stmt.setString(1, cialda.getNome());
            stmt.setString(2, cialda.getTipoCialda());
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("La creazione della cialda è fallita");
            }
            
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    cialda.setId(generatedKeys.getInt(1));
                    return cialda;
                } else {
                    throw new SQLException("La creazione della cialda è fallita, nessun ID ottenuto");
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il salvataggio della cialda", e);
        }
    }

    /**
     * Aggiorna una cialda esistente.
     *
     * @param cialda cialda da aggiornare
     * @return cialda aggiornata
     */
    public Cialda update(Cialda cialda) {
        String sql = "UPDATE cialda SET Nome = ?, TipoCialda = ? WHERE ID_Cialda = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, cialda.getNome());
            stmt.setString(2, cialda.getTipoCialda());
            stmt.setInt(3, cialda.getId());
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("L'aggiornamento della cialda è fallito");
            }
            return cialda;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'aggiornamento della cialda", e);
        }
    }

    /**
     * Elimina una cialda.
     *
     * @param id ID della cialda da eliminare
     * @return true se l'eliminazione ha successo
     */
    public boolean delete(int id) {
        String sql = "DELETE FROM cialda WHERE ID_Cialda = ?";
        
        try (Connection conn = dbConnection.getConnection()) {
            conn.setAutoCommit(false);
            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                // Prima elimina tutte le relazioni
                eliminaQuantitaCialde(conn, id);
                
                stmt.setInt(1, id);
                int affectedRows = stmt.executeUpdate();
                
                conn.commit();
                return affectedRows > 0;
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'eliminazione della cialda", e);
        }
    }

    /**
     * Converte un ResultSet in un oggetto Cialda.
     */
    private Cialda mapResultSetToCialda(ResultSet rs) throws SQLException {
        Cialda cialda = new Cialda();
        cialda.setId(rs.getInt("ID_Cialda"));
        cialda.setNome(rs.getString("Nome"));
        cialda.setTipoCialda(rs.getString("TipoCialda"));
        return cialda;
    }

    /**
     * Converte un ResultSet in un oggetto QuantitaCialde.
     */
    private QuantitaCialde mapResultSetToQuantitaCialde(ResultSet rs) throws SQLException {
        QuantitaCialde qc = new QuantitaCialde();
        qc.setId(rs.getInt("ID_QuantitaCialde"));
        qc.setMacchinaId(rs.getInt("ID_Macchina"));
        qc.setCialdaId(rs.getInt("ID_Cialda"));
        qc.setQuantita(rs.getInt("Quantita"));
        qc.setQuantitaMassima(rs.getInt("QuantitaMassima"));
        qc.setNomeCialda(rs.getString("NomeCialda"));
        qc.setTipoCialda(rs.getString("TipoCialda"));
        return qc;
    }

    /**
     * Elimina tutte le quantità cialde associate a una cialda.
     */
    private void eliminaQuantitaCialde(Connection conn, int cialdaId) throws SQLException {
        String sql = "DELETE FROM quantitacialde WHERE ID_Cialda = ?";
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, cialdaId);
            stmt.executeUpdate();
        }
    }
}

================
File: src/main/java/com/vending/core/repositories/DatabaseConnection.java
================
package com.vending.core.repositories;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
* Singleton class per gestire la connessione al database MySQL.
* Implementa il pattern Singleton thread-safe per garantire una singola istanza di connessione.
*/
public class DatabaseConnection {
   private static final Logger logger = LoggerFactory.getLogger(DatabaseConnection.class);
   private static volatile DatabaseConnection instance;
   private static final String URL = "jdbc:mysql://localhost:3306/pissir";
   private static final String USER = "root";
   private static final String PASSWORD = "Pissir2024!";
   
   private volatile Connection connection;
   
   /**
    * Costruttore privato che inizializza il driver MySQL.
    * @throws RuntimeException se il driver non viene trovato
    */
   private DatabaseConnection() {
       try {
           Class.forName("com.mysql.cj.jdbc.Driver");
           logger.info("MySQL Driver caricato con successo");
       } catch (ClassNotFoundException e) {
           logger.error("Errore nel caricamento del MySQL Driver", e);
           throw new RuntimeException("MySQL Driver non trovato: " + e.getMessage(), e);
       }
   }
   
   /**
    * Restituisce l'istanza singleton della connessione al database.
    * Implementa il double-checked locking per thread safety.
    * 
    * @return l'istanza di DatabaseConnection
    */
   public static DatabaseConnection getInstance() {
       if (instance == null) {
           synchronized (DatabaseConnection.class) {
               if (instance == null) {
                   instance = new DatabaseConnection();
               }
           }
       }
       return instance;
   }
   
   /**
    * Restituisce una connessione attiva al database.
    * Se la connessione non esiste o è chiusa, ne crea una nuova.
    * 
    * @return Connection oggetto connessione al database
    * @throws SQLException se la connessione fallisce
    */
   public Connection getConnection() throws SQLException {
       if (connection == null || connection.isClosed()) {
           synchronized (this) {
               if (connection == null || connection.isClosed()) {
                   try {
                       connection = DriverManager.getConnection(URL, USER, PASSWORD);
                   } catch (SQLException e) {
                       logger.error("Errore durante la connessione al database", e);
                       throw new SQLException("Impossibile connettersi al database: " + e.getMessage(), e);
                   }
               }
           }
       }
       return connection;
   }
   
   /**
    * Chiude la connessione al database se attiva.
    */
   public void closeConnection() {
       if (connection != null) {
           try {
               connection.close();
               connection = null;
               logger.info("Connessione al database chiusa con successo");
           } catch (SQLException e) {
               logger.error("Errore durante la chiusura della connessione", e);
           }
       }
   }
   
   /**
    * Verifica lo stato della connessione.
    * 
    * @return true se la connessione è attiva, false altrimenti
    */
   public boolean isConnected() {
       try {
           return connection != null && !connection.isClosed() && connection.isValid(1);
       } catch (SQLException e) {
           logger.error("Errore durante la verifica della connessione", e);
           return false;
       }
   }
}

================
File: src/main/java/com/vending/core/repositories/IstitutoRepository.java
================
package com.vending.core.repositories;

import com.vending.core.models.Istituto;
import com.vending.core.models.Macchina;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Repository per la gestione degli istituti nel database.
 * Gestisce le operazioni CRUD per la tabella 'istituto' e le relazioni
 * con la tabella 'macchina'.
 */
public class IstitutoRepository {
    private final DatabaseConnection dbConnection;
    private final MacchinaRepository macchinaRepository;

    /**
     * Costruttore del repository.
     *
     * @param macchinaRepository repository per l'accesso ai dati delle macchine
     */
    public IstitutoRepository(MacchinaRepository macchinaRepository) {
        this.dbConnection = DatabaseConnection.getInstance();
        this.macchinaRepository = macchinaRepository;
    }

    /**
     * Trova tutti gli istituti.
     *
     * @return lista di tutti gli istituti con le relative macchine
     */
    public List<Istituto> findAll() throws SQLException {
        List<Istituto> istituti = new ArrayList<>();
        String sql = "SELECT * FROM istituto";
        
        try (Connection conn = dbConnection.getConnection()) {
            // Lista temporanea per gli istituti base
            List<Istituto> istitutiTemp = new ArrayList<>();
            
            // Prima recupera tutti gli istituti base
            try (Statement stmt = conn.createStatement();
                 ResultSet rs = stmt.executeQuery(sql)) {
                
                while (rs.next()) {
                    Istituto istituto = mapResultSetToIstituto(rs);
                    istitutiTemp.add(istituto);
                }
            }
            
            // Poi carica le macchine per ogni istituto
            for (Istituto istituto : istitutiTemp) {
                caricaMacchine(istituto);
				istituti.add(istituto);
            }
            
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero degli istituti", e);
        }
        
        return istituti;
    }

    /**
     * Trova un istituto tramite ID.
     *
     * @param id ID dell'istituto
     * @return Optional contenente l'istituto se trovato
     */
    public Optional<Istituto> findById(int id) {
        String sql = "SELECT * FROM istituto WHERE ID_Istituto = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                Istituto istituto = mapResultSetToIstituto(rs);
                caricaMacchine(istituto);
                return Optional.of(istituto);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero dell'istituto", e);
        }
        return Optional.empty();
    }

    /**
     * Salva un nuovo istituto.
     * Recupera l'ultimo ID presente e imposta l'ID del nuovo istituto come last ID + 1.
     *
     * @param istituto istituto da salvare
     * @return istituto salvato con ID generato
     * @throws IllegalArgumentException se l'istituto è null o contiene dati non validi
     * @throws RuntimeException se si verifica un errore durante il salvataggio
     */
    public Istituto save(Istituto istituto) {
        if (istituto == null) {
            throw new IllegalArgumentException("L'istituto non può essere null");
        }

        // Verifica che i campi obbligatori non siano vuoti o nulli
        if (istituto.getNome() == null || istituto.getNome().trim().isEmpty()) {
            throw new IllegalArgumentException("Il nome dell'istituto non può essere vuoto");
        }
        if (istituto.getIndirizzo() == null || istituto.getIndirizzo().trim().isEmpty()) {
            throw new IllegalArgumentException("L'indirizzo dell'istituto non può essere vuoto");
        }

        // Query per ottenere l'ultimo ID
        String lastIdQuery = "SELECT MAX(ID_Istituto) AS lastId FROM istituto";
        String insertSql = "INSERT INTO istituto (ID_Istituto, Nome, Indirizzo) VALUES (?, ?, ?)";

        try (Connection conn = dbConnection.getConnection();
             Statement stmt = conn.createStatement();
             PreparedStatement insertStmt = conn.prepareStatement(insertSql)) {

            // Recupera l'ultimo ID
            ResultSet rs = stmt.executeQuery(lastIdQuery);
            int lastId = 0;
            if (rs.next()) {
                lastId = rs.getInt("lastId");
            }

            // Imposta l'ID del nuovo istituto come lastId + 1
            int newId = lastId + 1;
            istituto.setId(newId);

            // Esegui l'inserimento
            insertStmt.setInt(1, newId);
            insertStmt.setString(2, istituto.getNome());
            insertStmt.setString(3, istituto.getIndirizzo());

            int affectedRows = insertStmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("Creazione dell'istituto fallita, nessuna riga modificata");
            }

            return istituto;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il salvataggio dell'istituto", e);
        }
    }

    /**
     * Aggiorna un istituto esistente.
     *
     * @param istituto istituto da aggiornare
     * @return istituto aggiornato
     * @throws IllegalArgumentException se l'istituto è null o contiene dati non validi
     * @throws RuntimeException se si verifica un errore durante l'aggiornamento
     */
    public Istituto update(Istituto istituto) {
        if (istituto == null) {
            throw new IllegalArgumentException("L'istituto non può essere null");
        }

        // Verifica che i campi obbligatori non siano vuoti o nulli
        if (istituto.getNome() == null || istituto.getNome().trim().isEmpty()) {
            throw new IllegalArgumentException("Il nome dell'istituto non può essere vuoto");
        }
        if (istituto.getIndirizzo() == null || istituto.getIndirizzo().trim().isEmpty()) {
            throw new IllegalArgumentException("L'indirizzo dell'istituto non può essere vuoto");
        }
        if (istituto.getId() <= 0) {
            throw new IllegalArgumentException("L'ID dell'istituto non è valido");
        }

        String sql = "UPDATE istituto SET Nome = ?, Indirizzo = ? WHERE ID_Istituto = ?";

        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setString(1, istituto.getNome());
            stmt.setString(2, istituto.getIndirizzo());
            stmt.setInt(3, istituto.getId());

            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("L'aggiornamento dell'istituto è fallito, nessuna riga modificata");
            }
            return istituto;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'aggiornamento dell'istituto", e);
        }
    }

    /**
     * Elimina un istituto.
     *
     * @param id ID dell'istituto da eliminare
     * @return true se l'eliminazione ha successo
     * @throws SQLException 
     */
    public boolean delete(int id) throws SQLException {
        // Verifica che non ci siano macchine associate
        List<Macchina> macchine = macchinaRepository.findByIstitutoId(id);
        if (!macchine.isEmpty()) {
            throw new IllegalStateException("Non e' possibile eliminare un istituto con macchine associate");
        }

        String sql = "DELETE FROM istituto WHERE ID_Istituto = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            int affectedRows = stmt.executeUpdate();
            return affectedRows > 0;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'eliminazione dell'istituto", e);
        }
    }

    /**
     * Converte un ResultSet in un oggetto Istituto.
     */
    private Istituto mapResultSetToIstituto(ResultSet rs) throws SQLException {
        Istituto istituto = new Istituto();
        istituto.setId(rs.getInt("ID_Istituto"));
        istituto.setNome(rs.getString("Nome"));
        istituto.setIndirizzo(rs.getString("Indirizzo"));
        istituto.setMacchine(new ArrayList<>()); // Inizializza la lista delle macchine
        return istituto;
    }

    /**
     * Carica le macchine associate all'istituto.
     * @throws SQLException 
     */
    private void caricaMacchine(Istituto istituto) throws SQLException {
        List<Macchina> macchine = macchinaRepository.findByIstitutoId(istituto.getId());
        istituto.setMacchine(macchine);
    }

    /**
     * Verifica se esiste un istituto con il nome specificato.
     *
     * @param nome nome da verificare
     * @return true se esiste gi� un istituto con quel nome
     */
    public boolean existsByNome(String nome) {
        String sql = "SELECT COUNT(*) FROM istituto WHERE Nome = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, nome);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return rs.getInt(1) > 0;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante la verifica del nome istituto", e);
        }
        return false;
    }

    /**
     * Conta il numero di macchine attive in un istituto.
     *
     * @param id ID dell'istituto
     * @return numero di macchine attive
     */
    public int contaMacchineAttive(int id) {
        String sql = "SELECT COUNT(*) FROM macchina WHERE ID_Istituto = ? AND Stato = 1";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return rs.getInt(1);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il conteggio delle macchine attive", e);
        }
        return 0;
    }
}

================
File: src/main/java/com/vending/core/repositories/MacchinaRepository.java
================
package com.vending.core.repositories;

import com.vending.core.models.*;
import java.sql.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Repository per la gestione delle macchine distributrici nel database.
 * Gestisce tutte le operazioni CRUD e le relazioni con le altre entità
 * come bevande, cialde e stato della macchina.
 */
public class MacchinaRepository {
    private final DatabaseConnection dbConnection;

    /**
     * Costruttore del repository.
     * Inizializza la connessione al database.
     */
    public MacchinaRepository() {
        this.dbConnection = DatabaseConnection.getInstance();
    }

    /**
     * Recupera tutte le macchine distributrici dal database.
     * Include le informazioni sull'istituto e lo stato della macchina.
     *
     * @return Lista di tutte le macchine con i relativi dettagli
     * @throws RuntimeException se si verifica un errore durante l'accesso al database
     */
    public List<Macchina> findAll() {
        List<Macchina> macchine = new ArrayList<>();
        String sql = "SELECT macchina.*, istituto.Nome as NomeIstituto, statomacchina.Descrizione as StatoDescrizione " +
                    "FROM macchina " +
                    "JOIN istituto ON macchina.ID_Istituto = istituto.ID_Istituto " +
                    "JOIN statomacchina ON macchina.Stato = statomacchina.ID_StatoMacchina";
        
        try (Connection conn = dbConnection.getConnection()){
        	List<Macchina> macchineTemp = new ArrayList<>();
        	// Prima recupera tutte le macchine base
            try (Statement stmt = conn.createStatement();
                 ResultSet rs = stmt.executeQuery(sql)) {
                
                while (rs.next()) {
                    Macchina macchina = mapResultSetToMacchina(rs);
                    macchineTemp.add(macchina);
                }
            }
            
            // Poi carica i dettagli per ogni macchina
            for (Macchina macchina : macchineTemp) {
                try {
                    caricaDettagliMacchina(macchina);
                    macchine.add(macchina);
                } catch (SQLException e) {
                    // Log dell'errore ma continua con le altre macchine
                    System.err.println("Errore nel caricamento dei dettagli per la macchina " + macchina.getId() + ": " + e.getMessage());
                }
            }
            
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero delle macchine", e);
        }
        
        return macchine;
    }

    /**
     * Trova tutte le macchine installate in un determinato istituto.
     *
     * @param istitutoId ID dell'istituto
     * @return Lista delle macchine presenti nell'istituto
     * @throws SQLException 
     * @throws RuntimeException se si verifica un errore durante l'accesso al database
     */
    public List<Macchina> findByIstitutoId(int istitutoId) throws SQLException {
        List<Macchina> macchine = new ArrayList<>();
        String sql = "SELECT macchina.*, istituto.Nome as NomeIstituto, statomacchina.Descrizione as StatoDescrizione " +
                    "FROM macchina " +
                    "JOIN istituto ON macchina.ID_Istituto = istituto.ID_Istituto " +
                    "JOIN statomacchina ON macchina.Stato = statomacchina.ID_StatoMacchina " +
                    "WHERE macchina.ID_Istituto = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
        	List<Macchina> macchineTemp = new ArrayList<>();
            stmt.setInt(1, istitutoId);
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                	Macchina macchina = mapResultSetToMacchina(rs);
                    macchineTemp.add(macchina);
                }
            }
         // Poi carica i dettagli per ogni macchina
            for (Macchina macchina : macchineTemp) {
                try {
                    caricaDettagliMacchina(macchina);
                    macchine.add(macchina);
                } catch (SQLException e) {
                    // Log dell'errore ma continua con le altre macchine
                    System.err.println("Errore nel caricamento dei dettagli per la macchina " + macchina.getId() + ": " + e.getMessage());
                }
            }
        } catch (SQLException e) {
            throw new SQLException("Errore durante il recupero delle macchine dell'istituto", e);
        }
        return macchine;
    }
           /* ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                Macchina macchina = mapResultSetToMacchina(rs);
                caricaDettagliMacchina(macchina);
                macchine.add(macchina);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero delle macchine dell'istituto", e);
        }
        return macchine;
    }*/

    /**
     * Recupera una specifica macchina dal database tramite il suo ID.
     *
     * @param id ID della macchina da recuperare
     * @return La macchina trovata o null se non esiste
     * @throws RuntimeException se si verifica un errore durante l'accesso al database
     */
    public Macchina findById(int id) {
        String sql = "SELECT m.*, i.Nome as NomeIstituto, sm.Descrizione as StatoDescrizione " +
                    "FROM macchina m " +
                    "JOIN istituto i ON m.ID_Istituto = i.ID_Istituto " +
                    "JOIN statomacchina sm ON m.Stato = sm.ID_StatoMacchina " +
                    "WHERE m.ID_Macchina = ?";

        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                Macchina macchina = mapResultSetToMacchina(rs);
                caricaDettagliMacchina(macchina);
                return macchina;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero della macchina", e);
        }
        return null;
    }

    /**
     * Salva una nuova macchina nel database.
     * Gestisce anche il salvataggio delle relazioni con bevande e cialde.
     *
     * @param macchina La macchina da salvare
     * @return La macchina salvata con l'ID generato
     * @throws RuntimeException se si verifica un errore durante il salvataggio
     */
    public Macchina save(Macchina macchina) {
        String sql = "INSERT INTO macchina (ID_Istituto, Stato, CassaAttuale, CassaMassima) " +
                    "VALUES (?, ?, ?, ?)";
        
        try (Connection conn = dbConnection.getConnection()) {
            conn.setAutoCommit(false);
            try (PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
                stmt.setInt(1, macchina.getIstitutoId());
                stmt.setInt(2, macchina.getStatoId());
                stmt.setDouble(3, macchina.getCassaAttuale());
                stmt.setDouble(4, macchina.getCassaMassima());
                
                int affectedRows = stmt.executeUpdate();
                if (affectedRows == 0) {
                    throw new SQLException("La creazione della macchina è fallita");
                }
                
                try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        macchina.setId(generatedKeys.getInt(1));
                        salvaCialde(conn, macchina);
                        salvaBevande(conn, macchina);
                        conn.commit();
                        return macchina;
                    } else {
                        throw new SQLException("La creazione della macchina è fallita, nessun ID ottenuto");
                    }
                }
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il salvataggio della macchina", e);
        }
    }
    /**
     * Aggiorna le bevande associate a una macchina.
     *
     * @param macchina La macchina di cui aggiornare le bevande
     * @param bevandeIds Lista degli ID delle bevande da associare alla macchina
     * @throws SQLException se si verifica un errore durante l'aggiornamento
     */
    public void aggiornaBevande(Macchina macchina, List<Integer> bevandeIds) throws SQLException {
        try (Connection conn = dbConnection.getConnection()) {
            conn.setAutoCommit(false);
            try {
                // Elimina le associazioni esistenti
                eliminaBevande(conn, macchina.getId());
                
                // Aggiunge le nuove associazioni
                salvaBevande(conn, macchina, bevandeIds);
                
                conn.commit();
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            }
        }
    }

    /**
     * Salva le bevande associate a una macchina.
     *
     * @param conn Connessione al database
     * @param macchina La macchina di cui salvare le bevande
     * @param bevandeIds Lista degli ID delle bevande da associare alla macchina
     * @throws SQLException se si verifica un errore durante il salvataggio
     */
    private void salvaBevande(Connection conn, Macchina macchina, List<Integer> bevandeIds) throws SQLException {
        String sql = "INSERT INTO macchinahabevanda (ID_Macchina, ID_Bevanda) VALUES (?, ?)";
        
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            for (Integer bevandaId : bevandeIds) {
                stmt.setInt(1, macchina.getId());
                stmt.setInt(2, bevandaId);
                stmt.addBatch();
            }
            stmt.executeBatch();
        }
    }
    /**
     * Aggiorna una macchina esistente nel database.
     * Aggiorna anche le relazioni con bevande e cialde.
     *
     * @param macchina La macchina da aggiornare
     * @return La macchina aggiornata
     * @throws RuntimeException se si verifica un errore durante l'aggiornamento
     */
    public Macchina update(Macchina macchina) {
        String sql = "UPDATE macchina SET Stato = ?, CassaAttuale = ?, CassaMassima = ? " +
                    "WHERE ID_Macchina = ?";
        
        try (Connection conn = dbConnection.getConnection()) {
            conn.setAutoCommit(false);
            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setInt(1, macchina.getStatoId());
                stmt.setDouble(2, macchina.getCassaAttuale());
                stmt.setDouble(3, macchina.getCassaMassima());
                stmt.setInt(4, macchina.getId());
                
                int affectedRows = stmt.executeUpdate();
                if (affectedRows == 0) {
                    throw new SQLException("L'aggiornamento della macchina è fallito");
                }
                
                aggiornaCialde(conn, macchina);
                aggiornaBevande(conn, macchina);
                conn.commit();
                return macchina;
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'aggiornamento della macchina", e);
        }
    }

    /**
     * Elimina una macchina dal database.
     * Elimina anche tutte le relazioni associate (cialde e bevande).
     *
     * @param id ID della macchina da eliminare
     * @return true se l'eliminazione ha avuto successo, false altrimenti
     * @throws RuntimeException se si verifica un errore durante l'eliminazione
     */
    public boolean delete(int id) {
        String sql = "DELETE FROM macchina WHERE ID_Macchina = ?";
        
        try (Connection conn = dbConnection.getConnection()) {
            conn.setAutoCommit(false);
            try {
                // Prima elimina tutte le relazioni
                eliminaCialde(conn, id);
                eliminaBevande(conn, id);
                
                // Poi elimina la macchina
                try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                    stmt.setInt(1, id);
                    int affectedRows = stmt.executeUpdate();
                    conn.commit();
                    return affectedRows > 0;
                }
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'eliminazione della macchina", e);
        }
    }

    /**
     * Converte un ResultSet in un oggetto Macchina.
     */
    private Macchina mapResultSetToMacchina(ResultSet rs) throws SQLException {
        Macchina macchina = new Macchina();
        macchina.setId(rs.getInt("ID_Macchina"));
        macchina.setIstitutoId(rs.getInt("ID_Istituto"));
        macchina.setNomeIstituto(rs.getString("NomeIstituto"));
        macchina.setStatoId(rs.getInt("Stato"));
        macchina.setStatoDescrizione(rs.getString("StatoDescrizione"));
        macchina.setCassaAttuale(rs.getDouble("CassaAttuale"));
        macchina.setCassaMassima(rs.getDouble("CassaMassima"));
        return macchina;
    }

    /**
     * Carica le cialde associate alla macchina.
     */
    private void caricaCialde(Macchina macchina) throws SQLException {
        String sql = "SELECT qc.*, c.Nome as NomeCialda, c.TipoCialda " +
                    "FROM quantitacialde qc " +
                    "JOIN cialda c ON qc.ID_Cialda = c.ID_Cialda " +
                    "WHERE qc.ID_Macchina = ?";

        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, macchina.getId());
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                QuantitaCialde qc = new QuantitaCialde();
                qc.setId(rs.getInt("ID_QuantitaCialde"));
                qc.setMacchinaId(rs.getInt("ID_QuantitaCialde"));
                qc.setCialdaId(rs.getInt("ID_Cialda"));
                qc.setNomeCialda(rs.getString("NomeCialda"));
                qc.setTipoCialda(rs.getString("TipoCialda"));
                qc.setQuantita(rs.getInt("Quantita"));
                qc.setQuantitaMassima(rs.getInt("QuantitaMassima"));
                macchina.getCialde().add(qc);
            }
        }
    }

    /**
     * Carica le bevande associate alla macchina.
     */
    private void caricaBevande(Macchina macchina) throws SQLException {
        String sql = "SELECT b.* FROM bevanda b " +
                    "JOIN macchinahabevanda mhb ON b.ID_Bevanda = mhb.ID_Bevanda " +
                    "WHERE mhb.ID_Macchina = ?";

        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, macchina.getId());
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                Bevanda bevanda = new Bevanda();
                bevanda.setId(rs.getInt("ID_Bevanda"));
                bevanda.setNome(rs.getString("Nome"));
                bevanda.setPrezzo(rs.getDouble("Prezzo"));
                
                macchina.getBevande().add(bevanda);
            }
        }
    }
    
    		/**
    		 * Carica le cialde che compongono ogni bevanda della macchina.
    		 * 
    		 * @param macchina la macchina di cui caricare le composizioni delle bevande
    		 * @throws SQLException se si verifica un errore nell'accesso al database
    		 */
    		private void caricaComposizioneBevande(Macchina macchina) throws SQLException {
    		    String sql = "SELECT b.ID_Bevanda, c.ID_Cialda, c.Nome, c.TipoCialda FROM bevanda b JOIN bevandahacialda bc ON b.ID_Bevanda = bc.ID_Bevanda JOIN cialda c ON bc.ID_Cialda = c.ID_Cialda WHERE b.ID_Bevanda IN (SELECT mhb.ID_Bevanda FROM macchinahabevanda mhb WHERE mhb.ID_Macchina = ?) ORDER BY b.ID_Bevanda, c.ID_Cialda";

    		    try (Connection conn = dbConnection.getConnection();
    		            PreparedStatement stmt = conn.prepareStatement(sql, 
    		                ResultSet.TYPE_SCROLL_SENSITIVE, 
    		                ResultSet.CONCUR_READ_ONLY)) {
    		           
    		           stmt.setInt(1, macchina.getId());
    		           ResultSet rs = stmt.executeQuery();

    		           // Mappa temporanea per raggruppare le cialde per ID_Bevanda
    		           Map<Integer, List<Cialda>> cialdeBevande = new HashMap<>();

    		           // Popola la mappa con tutte le cialde
    		           while (rs.next()) {
    		               int idBevanda = rs.getInt("ID_Bevanda");
    		               
    		               Cialda cialda = new Cialda();
    		               cialda.setId(rs.getInt("ID_Cialda"));
    		               cialda.setNome(rs.getString("Nome"));
    		               cialda.setTipoCialda(rs.getString("TipoCialda"));

    		               cialdeBevande.computeIfAbsent(idBevanda, k -> new ArrayList<>())
    		                           .add(cialda);
    		           }

    		           // Assegna le cialde alle bevande
    		           for (Bevanda bevanda : macchina.getBevande()) {
    		               if (bevanda.getCialde() == null) {
    		                   bevanda.setCialde(new ArrayList<>());
    		               }
    		               List<Cialda> cialdeBevanda = cialdeBevande.get(bevanda.getId());
    		               if (cialdeBevanda != null) {
    		                   bevanda.getCialde().addAll(cialdeBevanda);
    		               }
    		           }
    		       }
    		   }
    /**
     * Carica tutti i dettagli associati alla macchina.
     */
    private void caricaDettagliMacchina(Macchina macchina) throws SQLException {
        caricaCialde(macchina);
        caricaBevande(macchina);
        caricaComposizioneBevande(macchina);
    }

    /**
     * Salva le cialde associate alla macchina.
     */
    private void salvaCialde(Connection conn, Macchina macchina) throws SQLException {
        String sql = "INSERT INTO quantitacialde (ID_Macchina, ID_Cialda, Quantita, QuantitaMassima) " +
                    "VALUES (?, ?, ?, ?)";
        
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            for (QuantitaCialde qc : macchina.getCialde()) {
                stmt.setInt(1, macchina.getId());
                stmt.setInt(2, qc.getCialdaId());
                stmt.setInt(3, qc.getQuantita());
                stmt.setInt(4, qc.getQuantitaMassima());
                stmt.addBatch();
            }
            stmt.executeBatch();
        }
    }

    /**
     * Salva le bevande associate alla macchina.
     */
    private void salvaBevande(Connection conn, Macchina macchina) throws SQLException {
        String sql = "INSERT INTO macchinahabevanda (ID_Macchina, ID_Bevanda) VALUES (?, ?)";
        
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            for (Bevanda bevanda : macchina.getBevande()) {
                stmt.setInt(1, macchina.getId());
                stmt.setInt(2, bevanda.getId());
                stmt.addBatch();
            }
            stmt.executeBatch();
        }
    }

    /**
     * Aggiorna le cialde associate alla macchina.
     * Elimina le associazioni esistenti e ne crea di nuove.
     *
     * @param conn Connessione al database
     * @param macchina Macchina di cui aggiornare le cialde
     * @throws SQLException se si verifica un errore durante l'aggiornamento
     */
    private void aggiornaCialde(Connection conn, Macchina macchina) throws SQLException {
        String deleteSQL = "DELETE FROM quantitacialde WHERE ID_Macchina = ?";
        try (PreparedStatement stmt = conn.prepareStatement(deleteSQL)) {
            stmt.setInt(1, macchina.getId());
            stmt.executeUpdate();
        }
        salvaCialde(conn, macchina);
    }

    /**
     * Aggiorna le bevande associate alla macchina.
     * Elimina le associazioni esistenti e ne crea di nuove.
     *
     * @param conn Connessione al database
     * @param macchina Macchina di cui aggiornare le bevande
     * @throws SQLException se si verifica un errore durante l'aggiornamento
     */
    private void aggiornaBevande(Connection conn, Macchina macchina) throws SQLException {
        String deleteSQL = "DELETE FROM macchinahabevanda WHERE ID_Macchina = ?";
        try (PreparedStatement stmt = conn.prepareStatement(deleteSQL)) {
            stmt.setInt(1, macchina.getId());
            stmt.executeUpdate();
        }
        salvaBevande(conn, macchina);
    }

    /**
     * Elimina tutte le cialde associate alla macchina.
     *
     * @param conn Connessione al database
     * @param macchinaId ID della macchina di cui eliminare le cialde
     * @throws SQLException se si verifica un errore durante l'eliminazione
     */
    private void eliminaCialde(Connection conn, int macchinaId) throws SQLException {
        String sql = "DELETE FROM quantitacialde WHERE ID_Macchina = ?";
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, macchinaId);
            stmt.executeUpdate();
        }
    }

    /**
     * Elimina tutte le bevande associate alla macchina.
     *
     * @param conn Connessione al database
     * @param macchinaId ID della macchina di cui eliminare le bevande
     * @throws SQLException se si verifica un errore durante l'eliminazione
     */
    private void eliminaBevande(Connection conn, int macchinaId) throws SQLException {
        String sql = "DELETE FROM macchinahabevanda WHERE ID_Macchina = ?";
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, macchinaId);
            stmt.executeUpdate();
        }
    }

    /**
     * Trova le macchine in base al loro stato.
     *
     * @param statoId ID dello stato da cercare (dalla tabella statomacchina)
     * @return Lista delle macchine nello stato specificato
     * @throws RuntimeException se si verifica un errore durante la ricerca
     */
    public List<Macchina> findByStato(int statoId) {
        List<Macchina> macchine = new ArrayList<>();
        String sql = "SELECT m.*, i.Nome as NomeIstituto, sm.Descrizione as StatoDescrizione " +
                    "FROM macchina m " +
                    "JOIN istituto i ON m.ID_Istituto = i.ID_Istituto " +
                    "JOIN statomacchina sm ON m.Stato = sm.ID_StatoMacchina " +
                    "WHERE m.Stato = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, statoId);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                Macchina macchina = mapResultSetToMacchina(rs);
                caricaDettagliMacchina(macchina);
                macchine.add(macchina);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero delle macchine per stato", e);
        }
        return macchine;
    }

    /**
     * Aggiorna lo stato di una macchina.
     *
     * @param macchinaId ID della macchina
     * @param nuovoStatoId Nuovo ID dello stato
     * @return true se l'aggiornamento ha avuto successo
     * @throws RuntimeException se si verifica un errore durante l'aggiornamento
     */
    public boolean aggiornaStato(int macchinaId, int nuovoStatoId) {
        String sql = "UPDATE macchina SET Stato = ? WHERE ID_Macchina = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, nuovoStatoId);
            stmt.setInt(2, macchinaId);
            
            int affectedRows = stmt.executeUpdate();
            return affectedRows > 0;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'aggiornamento dello stato della macchina", e);
        }
    }
}

================
File: src/main/java/com/vending/core/repositories/ManutenzioneRepository.java
================
package com.vending.core.repositories;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import com.vending.core.models.Manutenzione;

/**
 * Repository per la gestione delle manutenzioni delle macchine distributrici.
 * Gestisce le interazioni con la tabella 'manutenzione' per tenere traccia degli interventi di manutenzione.
 */
public class ManutenzioneRepository {
    private final DatabaseConnection dbConnection;

    /**
     * Costruttore del repository.
     */
    public ManutenzioneRepository() {
        this.dbConnection = DatabaseConnection.getInstance();
    }

    /**
     * Trova tutte le manutenzioni.
     *
     * @return lista delle manutenzioni
     */
    public List<Manutenzione> findAll() {
        List<Manutenzione> manutenzioni = new ArrayList<>();
        String sql = "SELECT * FROM manutenzione";

        try (Connection conn = dbConnection.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {

            while (rs.next()) {
                manutenzioni.add(mapResultSetToManutenzione(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore nel recupero delle manutenzioni", e);
        }
        return manutenzioni;
    }

    /**
     * Trova una specifica manutenzione.
     *
     * @param id ID della manutenzione
     * @return Optional contenente la manutenzione se trovata
     */
    public Optional<Manutenzione> findById(int id) {
        String sql = "SELECT * FROM manutenzione WHERE ID_Manutenzione = ?";

        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();

            if (rs.next()) {
                return Optional.of(mapResultSetToManutenzione(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore nel recupero della manutenzione", e);
        }
        return Optional.empty();
    }

    /**
     * Recupera tutte le manutenzioni di una specifica macchina.
     *
     * @param macchinaId ID della macchina
     * @return lista delle manutenzioni della macchina
     */
    public List<Manutenzione> findByMacchinaId(int macchinaId) {
        List<Manutenzione> manutenzioni = new ArrayList<>();
        String sql = "SELECT * FROM manutenzione WHERE ID_Macchina = ? ORDER BY DataRichiesta DESC";

        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setInt(1, macchinaId);
            ResultSet rs = stmt.executeQuery();

            while (rs.next()) {
                manutenzioni.add(mapResultSetToManutenzione(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore nel recupero delle manutenzioni per macchina", e);
        }
        return manutenzioni;
    }

    /**
     * Trova tutte le manutenzioni per un istituto.
     *
     * @param istitutoId ID dell'istituto
     * @return lista delle manutenzioni nell'istituto
     */
    public List<Manutenzione> findByIstitutoId(int istitutoId) {
        List<Manutenzione> manutenzioni = new ArrayList<>();
        String sql = "SELECT m.* FROM manutenzione m " +
                     "JOIN macchina ma ON m.ID_Macchina = ma.ID_Macchina " +
                     "WHERE ma.ID_Istituto = ?";

        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setInt(1, istitutoId);
            ResultSet rs = stmt.executeQuery();

            while (rs.next()) {
                manutenzioni.add(mapResultSetToManutenzione(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore nel recupero delle manutenzioni per istituto", e);
        }
        return manutenzioni;
    }

    /**
     * Trova tutte le manutenzioni assegnate a un tecnico.
     *
     * @param tecnicoId ID del tecnico
     * @return lista delle manutenzioni assegnate al tecnico
     */
    public List<Manutenzione> findByTecnicoId(int tecnicoId) {
        List<Manutenzione> manutenzioni = new ArrayList<>();
        String sql = "SELECT * FROM manutenzione WHERE ID_Tecnico = ?";

        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setInt(1, tecnicoId);
            ResultSet rs = stmt.executeQuery();

            while (rs.next()) {
                manutenzioni.add(mapResultSetToManutenzione(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore nel recupero delle manutenzioni per tecnico", e);
        }
        return manutenzioni;
    }

    /**
     * Salva una nuova manutenzione.
     *
     * @param manutenzione dati della manutenzione
     * @return manutenzione salvata
     */
    public Manutenzione save(Manutenzione manutenzione) {
        String sql = "INSERT INTO manutenzione (ID_Macchina, TipoIntervento, Descrizione, DataRichiesta, Stato, Urgenza, ID_Tecnico, Note) " +
                     "VALUES (?, ?, ?, ?, ?, ?, ?, ?)";

        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            stmt.setInt(1, manutenzione.getMacchinaId());
            stmt.setString(2, manutenzione.getTipoIntervento());
            stmt.setString(3, manutenzione.getDescrizione());
            stmt.setTimestamp(4, Timestamp.valueOf(manutenzione.getDataRichiesta()));
            stmt.setString(5, manutenzione.getStato());
            stmt.setString(6, manutenzione.getUrgenza());
            stmt.setInt(7, manutenzione.getTecnicoId());
            stmt.setString(8, manutenzione.getNote());

            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("Creazione manutenzione fallita, nessuna riga inserita.");
            }

            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    manutenzione.setId(generatedKeys.getInt(1));
                } else {
                    throw new SQLException("Creazione manutenzione fallita, nessun ID ottenuto.");
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore nel salvataggio della manutenzione", e);
        }
        return manutenzione;
    }

    /**
     * Aggiorna una manutenzione esistente.
     *
     * @param manutenzione dati della manutenzione da aggiornare
     * @return manutenzione aggiornata
     */
    public Manutenzione update(Manutenzione manutenzione) {
        String sql = "UPDATE manutenzione SET ID_Macchina = ?, TipoIntervento = ?, Descrizione = ?, " +
                     "DataRichiesta = ?, DataCompletamento = ?, Stato = ?, Urgenza = ?, ID_Tecnico = ?, Note = ? " +
                     "WHERE ID_Manutenzione = ?";

        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setInt(1, manutenzione.getMacchinaId());
            stmt.setString(2, manutenzione.getTipoIntervento());
            stmt.setString(3, manutenzione.getDescrizione());
            stmt.setTimestamp(4, Timestamp.valueOf(manutenzione.getDataRichiesta()));
            stmt.setTimestamp(5, manutenzione.getDataCompletamento() != null ? 
                Timestamp.valueOf(manutenzione.getDataCompletamento()) : null);
            stmt.setString(6, manutenzione.getStato());
            stmt.setString(7, manutenzione.getUrgenza());
            stmt.setInt(8, manutenzione.getTecnicoId());
            stmt.setString(9, manutenzione.getNote());
            stmt.setInt(10, manutenzione.getId());

            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("Aggiornamento manutenzione fallito, nessuna riga aggiornata.");
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore nell'aggiornamento della manutenzione", e);
        }
        return manutenzione;
    }

    /**
     * Completa una manutenzione.
     *
     * @param manutenzione dati della manutenzione completata
     * @return manutenzione completata
     */
    public Manutenzione completaManutenzione(Manutenzione manutenzione) {
        String sql = "UPDATE manutenzione SET Stato = 'COMPLETATA', DataCompletamento = ?, Note = ?, ID_Tecnico = ? " +
                     "WHERE ID_Manutenzione = ?";

        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setTimestamp(1, Timestamp.valueOf(LocalDateTime.now()));
            stmt.setString(2, manutenzione.getNote());
            stmt.setInt(3, manutenzione.getTecnicoId());
            stmt.setInt(4, manutenzione.getId());

            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("Completamento manutenzione fallito, nessuna riga aggiornata.");
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore nel completamento della manutenzione", e);
        }
        return manutenzione;
    }

    /**
     * Imposta una manutenzione come fuori servizio.
     *
     * @param manutenzioneId ID della manutenzione
     * @return true se l'operazione ha successo
     */
    public boolean setFuoriServizio(int manutenzioneId) {
        String sql = "UPDATE manutenzione SET Stato = 'FUORI_SERVIZIO' WHERE ID_Manutenzione = ?";

        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setInt(1, manutenzioneId);
            int affectedRows = stmt.executeUpdate();
            return affectedRows > 0;
        } catch (SQLException e) {
            throw new RuntimeException("Errore nell'impostazione fuori servizio", e);
        }
    }

    /**
     * Converte un ResultSet in un oggetto Manutenzione.
     */
    private Manutenzione mapResultSetToManutenzione(ResultSet rs) throws SQLException {
        Manutenzione manutenzione = new Manutenzione();
        manutenzione.setId(rs.getInt("ID_Manutenzione"));
        manutenzione.setMacchinaId(rs.getInt("ID_Macchina"));
        manutenzione.setTipoIntervento(rs.getString("TipoIntervento"));
        manutenzione.setDescrizione(rs.getString("Descrizione"));
        manutenzione.setDataRichiesta(rs.getTimestamp("DataRichiesta").toLocalDateTime());
        manutenzione.setDataCompletamento(rs.getTimestamp("DataCompletamento") != null ?
                rs.getTimestamp("DataCompletamento").toLocalDateTime() : null);
        manutenzione.setStato(rs.getString("Stato"));
        manutenzione.setUrgenza(rs.getString("Urgenza"));
        manutenzione.setTecnicoId(rs.getInt("ID_Tecnico"));
        manutenzione.setNote(rs.getString("Note"));
        return manutenzione;
    }
}

================
File: src/main/java/com/vending/core/repositories/RicavoRepository.java
================
package com.vending.core.repositories;

import com.vending.core.models.Ricavo;
import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Repository per la gestione dei ricavi delle macchine distributrici.
 * Gestisce le operazioni CRUD per la tabella 'ricavo' e utilizza la vista
 * 'ricavigiornalieri' per le statistiche aggregate.
 */
public class RicavoRepository {
    private final DatabaseConnection dbConnection;

    /**
     * Costruttore del repository.
     */
    public RicavoRepository() {
        this.dbConnection = DatabaseConnection.getInstance();
    }

    /**
     * Trova tutti i ricavi ordinati per data.
     *
     * @return lista di tutti i ricavi
     */
    public List<Ricavo> findAll() {
        List<Ricavo> ricavi = new ArrayList<>();
        String sql = "SELECT r.*, i.Nome as NomeIstituto " +
                    "FROM ricavo r " +
                    "JOIN macchina m ON r.ID_Macchina = m.ID_Macchina " +
                    "JOIN istituto i ON m.ID_Istituto = i.ID_Istituto " +
                    "ORDER BY r.DataOra DESC";
        
        try (Connection conn = dbConnection.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            
            while (rs.next()) {
                ricavi.add(mapResultSetToRicavo(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero dei ricavi", e);
        }
        return ricavi;
    }

    /**
     * Trova i ricavi di una specifica macchina.
     *
     * @param macchinaId ID della macchina
     * @return lista dei ricavi della macchina
     */
    public List<Ricavo> findByMacchinaId(int macchinaId) {
        List<Ricavo> ricavi = new ArrayList<>();
        String sql = "SELECT r.*, i.Nome as NomeIstituto " +
                    "FROM ricavo r " +
                    "JOIN macchina m ON r.ID_Macchina = m.ID_Macchina " +
                    "JOIN istituto i ON m.ID_Istituto = i.ID_Istituto " +
                    "WHERE r.ID_Macchina = ? " +
                    "ORDER BY r.DataOra DESC";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, macchinaId);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                ricavi.add(mapResultSetToRicavo(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero dei ricavi della macchina", e);
        }
        return ricavi;
    }

    /**
     * Trova i ricavi giornalieri di un istituto.
     *
     * @param istitutoId ID dell'istituto
     * @param data data di riferimento
     * @return ricavo giornaliero
     */
    public Optional<Double> findRicavoGiornaliero(int istitutoId, LocalDate data) {
        String sql = "SELECT SUM(RicavoGiornaliero) as Totale FROM ricavigiornalieri " +
                    "WHERE ID_Istituto = ? AND Data = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, istitutoId);
            stmt.setDate(2, java.sql.Date.valueOf(data));
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return Optional.ofNullable(rs.getDouble("Totale"));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il calcolo del ricavo giornaliero", e);
        }
        return Optional.empty();
    }

    /**
     * Salva un nuovo ricavo.
     *
     * @param ricavo ricavo da salvare
     * @return ricavo salvato con ID generato
     */
    public Ricavo save(Ricavo ricavo) {
        String sql = "INSERT INTO ricavo (ID_Macchina, Importo, DataOra) VALUES (?, ?, ?)";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            
            stmt.setInt(1, ricavo.getMacchinaId());
            stmt.setDouble(2, ricavo.getImporto());
            stmt.setTimestamp(3, Timestamp.valueOf(ricavo.getDataOra()));
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("La creazione del ricavo è fallita");
            }
            
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    ricavo.setId(generatedKeys.getInt(1));
                    return ricavo;
                } else {
                    throw new SQLException("La creazione del ricavo è fallita, nessun ID ottenuto");
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il salvataggio del ricavo", e);
        }
    }

    /**
     * Calcola il totale dei ricavi di una macchina.
     *
     * @param macchinaId ID della macchina
     * @return totale dei ricavi
     */
    public Double getTotaleRicaviByMacchina(int macchinaId) {
        String sql = "SELECT SUM(Importo) as totale FROM ricavo WHERE ID_Macchina = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, macchinaId);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return rs.getDouble("totale");
            }
            return 0.0;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il calcolo del totale ricavi", e);
        }
    }

    /**
     * Calcola il totale dei ricavi in un periodo.
     *
     * @param dataInizio data iniziale del periodo
     * @param dataFine data finale del periodo
     * @return totale dei ricavi nel periodo
     */
    public Double getTotaleRicaviPeriodo(LocalDateTime dataInizio, LocalDateTime dataFine) {
        String sql = "SELECT SUM(Importo) as totale FROM ricavo WHERE DataOra BETWEEN ? AND ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setTimestamp(1, Timestamp.valueOf(dataInizio));
            stmt.setTimestamp(2, Timestamp.valueOf(dataFine));
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return rs.getDouble("totale");
            }
            return 0.0;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il calcolo del totale ricavi del periodo", e);
        }
    }

    /**
     * Converte un ResultSet in un oggetto Ricavo.
     */
    private Ricavo mapResultSetToRicavo(ResultSet rs) throws SQLException {
        Ricavo ricavo = new Ricavo();
        ricavo.setId(rs.getInt("ID_Ricavo"));
        ricavo.setMacchinaId(rs.getInt("ID_Macchina"));
        ricavo.setNomeIstituto(rs.getString("NomeIstituto"));
        ricavo.setImporto(rs.getDouble("Importo"));
        ricavo.setDataOra(rs.getTimestamp("DataOra").toLocalDateTime());
        return ricavo;
    }
}

================
File: src/main/java/com/vending/core/repositories/TransazioneRepository.java
================
package com.vending.core.repositories;

import com.vending.Main;
import com.vending.core.models.Transazione;
import java.sql.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
/**
 * Repository per la gestione delle transazioni delle macchine distributrici.
 * Gestisce le operazioni CRUD per la tabella 'transazione' e utilizza la vista
 * 'transazionirecenti' per le consultazioni recenti.
 */
public class TransazioneRepository {
    private final DatabaseConnection dbConnection;
    private static final Logger logger = LoggerFactory.getLogger(Main.class);

    /**
     * Costruttore del repository.
     */
    public TransazioneRepository() {
        this.dbConnection = DatabaseConnection.getInstance();
    }

    public int getLastTransactionId() {
        String sql = "SELECT MAX(ID_Transazione) as last_id FROM transazione";
        
        try (Connection conn = dbConnection.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            
            if (rs.next()) {
                int lastId = rs.getInt("last_id");
                // Se la tabella è vuota, restituisci 0
                return lastId > 0 ? lastId : 0;
            }
            return 0;
            
        } catch (SQLException e) {
            throw new RuntimeException("Errore nel recupero dell'ultimo ID transazione", e);
        }
    }

    /**
     * Trova tutte le transazioni ordinate per data.
     *
     * @return lista di tutte le transazioni
     */
    public List<Transazione> findAll() {
        List<Transazione> transazioni = new ArrayList<>();
        String sql = "SELECT t.*, i.Nome as NomeIstituto, b.Nome as NomeBevanda " +
                    "FROM transazione t " +
                    "JOIN macchina m ON t.ID_Macchina = m.ID_Macchina " +
                    "JOIN istituto i ON m.ID_Istituto = i.ID_Istituto " +
                    "JOIN bevanda b ON t.ID_Bevanda = b.ID_Bevanda " +
                    "ORDER BY t.DataOra DESC";
        
        try (Connection conn = dbConnection.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            
            while (rs.next()) {
                transazioni.add(mapResultSetToTransazione(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero delle transazioni", e);
        }
        return transazioni;
    }

    /**
     * Trova una transazione tramite ID.
     *
     * @param id ID della transazione
     * @return Optional contenente la transazione se trovata
     */
    public Optional<Transazione> findById(int id) {
        String sql = "SELECT t.*, i.Nome as NomeIstituto, b.Nome as NomeBevanda " +
                    "FROM transazione t " +
                    "JOIN macchina m ON t.ID_Macchina = m.ID_Macchina " +
                    "JOIN istituto i ON m.ID_Istituto = i.ID_Istituto " +
                    "JOIN bevanda b ON t.ID_Bevanda = b.ID_Bevanda " +
                    "WHERE t.ID_Transazione = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return Optional.of(mapResultSetToTransazione(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore nel recupero della transazione", e);
        }
        return Optional.empty();
    }

    /**
     * Trova le transazioni di una macchina.
     *
     * @param macchinaId ID della macchina
     * @return lista delle transazioni della macchina
     */
    public List<Transazione> findByMacchinaId(int macchinaId) {
        List<Transazione> transazioni = new ArrayList<>();
        String sql = "SELECT t.*, i.Nome as NomeIstituto, b.Nome as NomeBevanda " +
                    "FROM transazione t " +
                    "JOIN macchina m ON t.ID_Macchina = m.ID_Macchina " +
                    "JOIN istituto i ON m.ID_Istituto = i.ID_Istituto " +
                    "JOIN bevanda b ON t.ID_Bevanda = b.ID_Bevanda " +
                    "WHERE t.ID_Macchina = ? " +
                    "ORDER BY t.DataOra DESC";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, macchinaId);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                transazioni.add(mapResultSetToTransazione(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero delle transazioni della macchina", e);
        }
        return transazioni;
    }

    /**
     * Trova le transazioni recenti.
     * Utilizza la vista 'transazionirecenti' che mostra le ultime 100 transazioni.
     *
     * @return lista delle transazioni recenti
     */
    public List<Transazione> findTransazioniRecenti() {
        List<Transazione> transazioni = new ArrayList<>();
        String sql = "SELECT * FROM transazionirecenti";
        
        try (Connection conn = dbConnection.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            
            while (rs.next()) {
                transazioni.add(mapResultSetToTransazione(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero delle transazioni recenti", e);
        }
        return transazioni;
    }

    /**
     * Salva una nuova transazione.
     *
     * @param transazione transazione da salvare
     * @return transazione salvata con ID generato
     */
    public Transazione save(Transazione transazione) {
        String sql = "INSERT INTO transazione (ID_Macchina, ID_Bevanda, Importo, DataOra) " +
                    "VALUES (?, ?, ?, ?)";
                    
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            
            stmt.setInt(1, transazione.getMacchinaId());
            stmt.setInt(2, transazione.getBevandaId());
            stmt.setDouble(3, transazione.getImporto());
            stmt.setTimestamp(4, Timestamp.valueOf(transazione.getDataOra()));
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("La creazione della transazione è fallita");
            }
            
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    transazione.setId(generatedKeys.getInt(1));
                    return transazione;
                } else {
                    throw new SQLException("La creazione della transazione è fallita, nessun ID ottenuto");
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il salvataggio della transazione", e);
        }
    }

    public Transazione update(Transazione transazione) {
        String sql = "UPDATE transazione SET " +
                     "ID_Macchina = ?, " +
                     "ID_Bevanda = ?, " +
                     "Importo = ?, " +
                     "DataOra = ? " +
                     "WHERE ID_Transazione = ?";
    
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, transazione.getMacchinaId());
            stmt.setInt(2, transazione.getBevandaId());
            stmt.setDouble(3, transazione.getImporto());
            stmt.setTimestamp(4, Timestamp.valueOf(transazione.getDataOra()));
            stmt.setInt(5, transazione.getId());
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("L'aggiornamento della transazione " + transazione.getId() + " è fallito");
            }
            
            logger.info("Transazione {} aggiornata con successo", transazione.getId());
            return transazione;
            
        } catch (SQLException e) {
            logger.error("Errore durante l'aggiornamento della transazione {}: {}", 
                        transazione.getId(), e.getMessage());
            throw new RuntimeException("Errore durante l'aggiornamento della transazione", e);
        }
    }

    /**
     * Calcola il totale delle transazioni di una macchina in un periodo.
     *
     * @param macchinaId ID della macchina
     * @param dataInizio data iniziale del periodo
     * @param dataFine data finale del periodo
     * @return totale delle transazioni
     */
    public Double calcolaTotaleMacchina(int macchinaId, LocalDateTime dataInizio, LocalDateTime dataFine) {
        String sql = "SELECT SUM(Importo) as totale FROM transazione " +
                    "WHERE ID_Macchina = ? AND DataOra BETWEEN ? AND ?";
                    
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, macchinaId);
            stmt.setTimestamp(2, Timestamp.valueOf(dataInizio));
            stmt.setTimestamp(3, Timestamp.valueOf(dataFine));
            
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return Optional.ofNullable(rs.getDouble("totale"))
                    .orElse(0.0);
            }
            return 0.0;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il calcolo del totale", e);
        }
    }

    /**
     * Converte un ResultSet in un oggetto Transazione.
     */
    private Transazione mapResultSetToTransazione(ResultSet rs) throws SQLException {
        Transazione transazione = new Transazione();
        transazione.setId(rs.getInt("ID_Transazione"));
        transazione.setMacchinaId(rs.getInt("ID_Macchina"));
        transazione.setBevandaId(rs.getInt("ID_Bevanda"));
        transazione.setNomeIstituto(rs.getString("NomeIstituto"));
        transazione.setNomeBevanda(rs.getString("NomeBevanda"));
        transazione.setImporto(rs.getDouble("Importo"));
        transazione.setDataOra(rs.getTimestamp("DataOra").toLocalDateTime());
        return transazione;
    }
}

================
File: src/main/java/com/vending/core/repositories/UtenteRepository.java
================
package com.vending.core.repositories;

import com.vending.core.models.Utente;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Repository per la gestione degli utenti del sistema.
 * Gestisce le operazioni CRUD per la tabella 'utente' e le sue relazioni
 * con la tabella 'adminlogin'.
 */
public class UtenteRepository {
    private final DatabaseConnection dbConnection;

    /**
     * Costruttore del repository.
     */
    public UtenteRepository() {
        this.dbConnection = DatabaseConnection.getInstance();
    }

    /**
     * Trova tutti gli utenti.
     *
     * @return lista di tutti gli utenti
     */
    public List<Utente> findAll() {
        List<Utente> utenti = new ArrayList<>();
        String sql = "SELECT u.*, al.Username, al.UltimoAccesso " +
                    "FROM utente u " +
                    "LEFT JOIN adminlogin al ON u.ID_Utente = al.ID_Utente";
        
        try (Connection conn = dbConnection.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            
            while (rs.next()) {
                utenti.add(mapResultSetToUtente(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero degli utenti", e);
        }
        return utenti;
    }

    /**
     * Trova un utente tramite ID.
     *
     * @param id ID dell'utente
     * @return Optional contenente l'utente se trovato
     */
    public Optional<Utente> findById(int id) {
        String sql = "SELECT u.*, al.Username, al.UltimoAccesso " +
                    "FROM utente u " +
                    "LEFT JOIN adminlogin al ON u.ID_Utente = al.ID_Utente " +
                    "WHERE u.ID_Utente = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return Optional.of(mapResultSetToUtente(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore nel recupero dell'utente", e);
        }
        return Optional.empty();
    }

    /**
     * Trova un utente tramite username.
     *
     * @param username username da cercare
     * @return Optional contenente l'utente se trovato
     */
    public Utente findByUsername(String username) {
        String sql = "SELECT u.*, al.Username, al.UltimoAccesso " +
                    "FROM utente u " +
                    "JOIN adminlogin al ON u.ID_Utente = al.ID_Utente " +
                    "WHERE al.Username = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, username);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return mapResultSetToUtente(rs);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante la ricerca dell'utente", e);
        }
        return null;
    }

    /**
     * Trova gli utenti per ruolo.
     *
     * @param ruolo ruolo da cercare
     * @return lista degli utenti con il ruolo specificato
     */
    public List<Utente> findByRuolo(String ruolo) {
        List<Utente> utenti = new ArrayList<>();
        String sql = "SELECT u.*, al.Username, al.UltimoAccesso " +
                    "FROM utente u " +
                    "LEFT JOIN adminlogin al ON u.ID_Utente = al.ID_Utente " +
                    "WHERE u.Ruolo = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, ruolo);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                utenti.add(mapResultSetToUtente(rs));
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante il recupero degli utenti per ruolo", e);
        }
        return utenti;
    }

    /**
     * Salva un nuovo utente.
     *
     * @param utente utente da salvare
     * @return utente salvato con ID generato
     */
    public Utente save(Utente utente) {
        String sqlUtente = "INSERT INTO utente (Nome, Ruolo) VALUES (?, ?)";
        String sqlAdmin = "INSERT INTO adminlogin (ID_AdminLogin, ID_Utente, Username, PasswordHash, UltimoAccesso) VALUES (?, ?, ?, ?, ?)";
        
        try (Connection conn = dbConnection.getConnection()) {
            conn.setAutoCommit(false);
            
            // Inserimento nella tabella utente
            try (PreparedStatement stmtUtente = conn.prepareStatement(sqlUtente, Statement.RETURN_GENERATED_KEYS)) {
                stmtUtente.setString(1, utente.getNome());
                stmtUtente.setString(2, utente.getRuolo());
                
                int affectedRows = stmtUtente.executeUpdate();
                if (affectedRows == 0) {
                    throw new SQLException("Creazione utente fallita");
                }

                // Ottieni l'ID generato
                try (ResultSet generatedKeys = stmtUtente.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        int userId = generatedKeys.getInt(1);
                        utente.setId(userId);
                        
                        // Inserimento nella tabella adminlogin
                        try (PreparedStatement stmtAdmin = conn.prepareStatement(sqlAdmin)) {
                            int adminLoginId = generateNewAdminLoginId(conn); // Passa la connessione esistente
                            
                            stmtAdmin.setInt(1, adminLoginId);
                            stmtAdmin.setInt(2, userId);
                            stmtAdmin.setString(3, utente.getUsername());
                            stmtAdmin.setString(4, utente.getPasswordHash());
                            stmtAdmin.setTimestamp(5, new Timestamp(System.currentTimeMillis()));
                            
                            stmtAdmin.executeUpdate();
                        }
                        
                        conn.commit();
                        return utente;
                    } else {
                        conn.rollback();
                        throw new SQLException("Creazione utente fallita, nessun ID ottenuto");
                    }
                }
            } catch (SQLException e) {
                conn.rollback();
                throw new RuntimeException("Errore durante il salvataggio dell'utente", e);
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore di connessione al database", e);
        }
    }

    // Metodo helper modificato per usare la stessa connessione
    private int generateNewAdminLoginId(Connection conn) throws SQLException {
        String sql = "SELECT COALESCE(MAX(ID_AdminLogin), 0) + 1 FROM adminlogin";
        try (Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            if (rs.next()) {
                return rs.getInt(1);
            }
            return 1;
        }
    }

    /**
     * Aggiorna un utente esistente.
     *
     * @param utente utente da aggiornare
     * @return utente aggiornato
     */
    public Utente update(Utente utente) {
        String sql = "UPDATE utente SET Nome = ?, Ruolo = ? WHERE ID_Utente = ?";
        
        try (Connection conn = dbConnection.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, utente.getNome());
            stmt.setString(2, utente.getRuolo());
            stmt.setInt(3, utente.getId());
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("L'aggiornamento dell'utente è fallito");
            }
            return utente;
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'aggiornamento dell'utente", e);
        }
    }

    /**
     * Elimina un utente.
     *
     * @param id ID dell'utente da eliminare
     * @return true se l'eliminazione ha successo
     */
    public boolean delete(int id) {
        String sql = "DELETE FROM utente WHERE ID_Utente = ?";
        
        try (Connection conn = dbConnection.getConnection()) {
            conn.setAutoCommit(false);
            try {
                // Prima elimina eventuali login associati
                deleteAdminLogin(conn, id);
                
                // Poi elimina l'utente
                try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                    stmt.setInt(1, id);
                    int affectedRows = stmt.executeUpdate();
                    conn.commit();
                    return affectedRows > 0;
                }
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            }
        } catch (SQLException e) {
            throw new RuntimeException("Errore durante l'eliminazione dell'utente", e);
        }
    }

    /**
     * Elimina i dati di login di un utente.
     */
    private void deleteAdminLogin(Connection conn, int utenteId) throws SQLException {
        String sql = "DELETE FROM adminlogin WHERE ID_Utente = ?";
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, utenteId);
            stmt.executeUpdate();
        }
    }

    /**
     * Converte un ResultSet in un oggetto Utente.
     */
    private Utente mapResultSetToUtente(ResultSet rs) throws SQLException {
        Utente utente = new Utente();
        utente.setId(rs.getInt("ID_Utente"));
        utente.setNome(rs.getString("Nome"));
        utente.setRuolo(rs.getString("Ruolo"));
        
        // Gestione dei campi opzionali da adminlogin
        String username = rs.getString("Username");
        if (username != null) {
            utente.setUsername(username);
            utente.setUltimoAccesso(rs.getTimestamp("UltimoAccesso").toLocalDateTime());
        }
        
        return utente;
    }
}

================
File: src/main/java/com/vending/core/services/AdminLoginService.java
================
package com.vending.core.services;

import com.vending.core.models.AdminLogin;
import com.vending.core.models.Utente;
import com.vending.core.repositories.AdminLoginRepository;
import com.vending.core.repositories.UtenteRepository;
import java.time.LocalDateTime;
import java.util.Optional;

/**
 * Servizio che gestisce la logica di business per l'autenticazione e la gestione
 * degli accessi amministrativi al sistema.
 */
public class AdminLoginService {
    private final AdminLoginRepository adminLoginRepository;
    private final UtenteRepository utenteRepository;

    /**
     * Costruttore del servizio.
     *
     * @param adminLoginRepository repository per l'accesso ai dati di AdminLogin
     * @param utenteRepository repository per l'accesso ai dati degli Utenti
     */
    public AdminLoginService(AdminLoginRepository adminLoginRepository, UtenteRepository utenteRepository) {
        this.adminLoginRepository = adminLoginRepository;
        this.utenteRepository = utenteRepository;
    }

    /**
     * Autentica un utente utilizzando username e password.
     *
     * @param username nome utente
     * @param password password in chiaro
     * @return Optional contenente l'AdminLogin se l'autenticazione ha successo
     */
    public Optional<AdminLogin> autenticaUtente(String username, String password) {
        Optional<AdminLogin> loginOpt = adminLoginRepository.findByUsername(username);
        
        if (loginOpt.isPresent()) {
            AdminLogin login = loginOpt.get();
            if (login.verificaPassword(password)) {
                login.aggiornaUltimoAccesso();
                adminLoginRepository.update(login);
                return Optional.of(login);
            }
        }
        return Optional.empty();
    }

    /**
     * Crea un nuovo accesso amministrativo per un utente.
     *
     * @param utenteId ID dell'utente
     * @param username nome utente desiderato
     * @param password password in chiaro
     * @return AdminLogin creato
     * @throws IllegalArgumentException se l'utente non esiste o lo username è già in uso
     */
    public AdminLogin creaAccessoAmministrativo(int utenteId, String username, String password) {
        // Verifica esistenza utente
        Utente utente = utenteRepository.findById(utenteId)
            .orElseThrow(() -> new IllegalArgumentException("Utente non trovato"));

        // Verifica unicità username
        if (adminLoginRepository.findByUsername(username).isPresent()) {
            throw new IllegalArgumentException("Username già in uso");
        }

        // Crea nuovo accesso
        AdminLogin adminLogin = new AdminLogin(utenteId, username, password);
        adminLogin.setUtente(utente);
        
        return adminLoginRepository.save(adminLogin);
    }

    /**
     * Modifica la password di un accesso amministrativo.
     *
     * @param adminLoginId ID dell'accesso amministrativo
     * @param vecchiaPassword password attuale
     * @param nuovaPassword nuova password
     * @return true se la modifica ha successo
     * @throws IllegalArgumentException se l'accesso non esiste o la vecchia password è errata
     */
    public boolean modificaPassword(int adminLoginId, String vecchiaPassword, String nuovaPassword) {
        AdminLogin login = adminLoginRepository.findById(adminLoginId)
            .orElseThrow(() -> new IllegalArgumentException("Accesso amministrativo non trovato"));

        if (!login.verificaPassword(vecchiaPassword)) {
            throw new IllegalArgumentException("Password attuale non corretta");
        }

        login.setPassword(nuovaPassword);
        adminLoginRepository.update(login);
        return true;
    }

    /**
     * Disattiva un accesso amministrativo.
     *
     * @param adminLoginId ID dell'accesso amministrativo
     * @return true se la disattivazione ha successo
     */
    public boolean disattivaAccesso(int adminLoginId) {
        return adminLoginRepository.delete(adminLoginId);
    }

    /**
     * Verifica se un username è disponibile.
     *
     * @param username username da verificare
     * @return true se lo username è disponibile
     */
    public boolean isUsernameDisponibile(String username) {
        return adminLoginRepository.findByUsername(username).isEmpty();
    }

    /**
     * Recupera l'accesso amministrativo di un utente.
     *
     * @param utenteId ID dell'utente
     * @return Optional contenente l'AdminLogin se esistente
     */
    public Optional<AdminLogin> getAccessoPerUtente(int utenteId) {
        return adminLoginRepository.findByUtenteId(utenteId);
    }

    /**
     * Verifica se un utente ha accesso amministrativo.
     *
     * @param utenteId ID dell'utente
     * @return true se l'utente ha un accesso amministrativo
     */
    public boolean haAccessoAmministrativo(int utenteId) {
        return adminLoginRepository.findByUtenteId(utenteId).isPresent();
    }

    /**
     * Recupera l'ultima data di accesso di un utente.
     *
     * @param username username dell'utente
     * @return Optional contenente la data dell'ultimo accesso
     */
    public Optional<LocalDateTime> getUltimoAccesso(String username) {
        return adminLoginRepository.findByUsername(username)
            .map(AdminLogin::getUltimoAccesso);
    }
}

================
File: src/main/java/com/vending/core/services/BevandaService.java
================
package com.vending.core.services;

import com.vending.core.models.Bevanda;
import com.vending.core.models.Cialda;
import com.vending.core.repositories.BevandaRepository;
import com.vending.core.repositories.CialdaRepository;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Servizio che gestisce la logica di per le bevande disponibili
 * nelle macchine distributrici.
 */
public class BevandaService {
    private final BevandaRepository bevandaRepository;
    private final CialdaRepository cialdaRepository;

    /**
     * Costruttore del servizio.
     *
     * @param bevandaRepository repository per l'accesso ai dati delle bevande
     * @param cialdaRepository repository per l'accesso ai dati delle cialde
     */
    public BevandaService(BevandaRepository bevandaRepository, CialdaRepository cialdaRepository) {
        this.bevandaRepository = bevandaRepository;
        this.cialdaRepository = cialdaRepository;
    }

    /**
     * Recupera tutte le bevande disponibili.
     *
     * @return lista di tutte le bevande
     */
    public List<Bevanda> getTutteBevande() {
        return bevandaRepository.findAll();
    }

    /**
     * Recupera una bevanda specifica.
     *
     * @param id ID della bevanda
     * @return Optional contenente la bevanda se trovata
     */
    public Optional<Bevanda> getBevandaById(int id) {
        return bevandaRepository.findById(id);
    }

    /**
     * Crea una nuova bevanda.
     *
     * @param nome nome della bevanda
     * @param prezzo prezzo della bevanda
     * @param cialdeIds lista degli ID delle cialde necessarie
     * @return bevanda creata
     */
    public Bevanda creaBevanda(String nome, Double prezzo, List<Integer> cialdeIds) {
        // Valida i parametri base
        validaParametriBevanda(nome, prezzo);

        // Verifica e recupera le cialde
        List<Cialda> cialde = recuperaCialde(cialdeIds);

        // Crea e salva la bevanda
        Bevanda bevanda = new Bevanda(nome, prezzo);
        bevanda.setCialde(cialde);
        return bevandaRepository.save(bevanda);
    }

    /**
     * Aggiorna una bevanda esistente.
     *
     * @param id ID della bevanda da aggiornare
     * @param nome nuovo nome
     * @param prezzo nuovo prezzo 
     * @param cialdeIds nuova lista di ID delle cialde
     * @return bevanda aggiornata
     */
    public Bevanda aggiornaBevanda(int id, String nome, Double prezzo, List<Integer> cialdeIds) {
        // Recupera la bevanda esistente
        Bevanda bevanda = bevandaRepository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("Bevanda non trovata"));

        // Aggiorna solo i campi forniti
        if (nome != null && !nome.trim().isEmpty()) {
            bevanda.setNome(nome);
        }
        if (prezzo != null && prezzo > 0) {
            bevanda.setPrezzo(prezzo);
        }
        if (cialdeIds != null && !cialdeIds.isEmpty()) {
            bevanda.setCialde(recuperaCialde(cialdeIds));
        }

        return bevandaRepository.update(bevanda);
    }

    /**
     * Elimina una bevanda.
     *
     * @param id ID della bevanda da eliminare
     * @return true se l'eliminazione ha successo
     */
    public boolean eliminaBevanda(int id) {
        return bevandaRepository.delete(id);
    }

    /**
     * Aggiunge una cialda a una bevanda.
     *
     * @param bevandaId ID della bevanda
     * @param cialdaId ID della cialda da aggiungere
     */
    public void aggiungiCialda(int bevandaId, int cialdaId) {
        // Recupera bevanda e cialda
        Bevanda bevanda = bevandaRepository.findById(bevandaId)
            .orElseThrow(() -> new IllegalArgumentException("Bevanda non trovata"));
        
        Cialda cialda = cialdaRepository.findById(cialdaId)
            .orElseThrow(() -> new IllegalArgumentException("Cialda non trovata"));

        // Aggiunge la cialda e aggiorna
        bevanda.aggiungiCialda(cialda);
        bevandaRepository.update(bevanda);
    }

    /**
     * Rimuove una cialda da una bevanda.
     *
     * @param bevandaId ID della bevanda
     * @param cialdaId ID della cialda da rimuovere
     */
    public void rimuoviCialda(int bevandaId, int cialdaId) {
        // Recupera la bevanda
        Bevanda bevanda = bevandaRepository.findById(bevandaId)
            .orElseThrow(() -> new IllegalArgumentException("Bevanda non trovata"));

        // Verifica che rimanga almeno una cialda
        if (bevanda.getCialde().size() <= 1) {
            throw new IllegalStateException("La bevanda deve mantenere almeno una cialda");
        }

        // Rimuove la cialda e aggiorna
        bevanda.getCialde().removeIf(c -> c.getId() == cialdaId);
        bevandaRepository.update(bevanda);
    }

    /**
     * Recupera le cialde per una lista di ID.
     */
    private List<Cialda> recuperaCialde(List<Integer> cialdeIds) {
        return cialdeIds.stream()
            .map(id -> cialdaRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Cialda non trovata: " + id)))
            .collect(Collectors.toList());
    }

    /**
     * Valida i parametri base di una bevanda.
     */
    private void validaParametriBevanda(String nome, Double prezzo) {
        if (nome == null || nome.trim().isEmpty()) {
            throw new IllegalArgumentException("Nome bevanda obbligatorio");
        }
        if (prezzo == null || prezzo <= 0) {
            throw new IllegalArgumentException("Prezzo non valido");
        }
    }
}

================
File: src/main/java/com/vending/core/services/IstitutoService.java
================
package com.vending.core.services;

import com.vending.core.models.Istituto;
import com.vending.core.models.Macchina;
import com.vending.core.repositories.IstitutoRepository;
import com.vending.core.repositories.MacchinaRepository;

import java.sql.SQLException;
import java.util.List;

/**
 * Servizio per la gestione degli istituti nel sistema di distribuzione automatica.
 * 
 * Questa classe fornisce operazioni di business logic per la gestione degli istituti,
 * inclusi metodi per la creazione, lettura, aggiornamento ed eliminazione degli istituti,
 * nonché la gestione delle macchine associate.
 */
public class IstitutoService {
    private final IstitutoRepository istitutoRepository;
    private final MacchinaRepository macchinaRepository;

    /**
     * Costruttore per il servizio degli istituti.
     * 
     * @param istitutoRepository Repository per le operazioni sui dati degli istituti
     * @param macchinaRepository Repository per le operazioni sui dati delle macchine
     */
    public IstitutoService(IstitutoRepository istitutoRepository, MacchinaRepository macchinaRepository) {
        this.istitutoRepository = istitutoRepository;
        this.macchinaRepository = macchinaRepository;
    }

    /**
     * Recupera tutti gli istituti presenti nel sistema.
     * 
     * @return Lista di tutti gli istituti
     * @throws SQLException 
     */
    public List<Istituto> getTuttiIstituti() throws SQLException {
        return istitutoRepository.findAll();
    }

    /**
     * Recupera un istituto specifico tramite il suo ID.
     * 
     * @param id Identificativo dell'istituto
     * @return L'istituto corrispondente all'ID
     */
    public Istituto getIstitutoById(int id) {
        return istitutoRepository.findById(id).orElse(null);
    }

    /**
     * Crea un nuovo istituto nel sistema.
     * 
     * Esegue la validazione dell'istituto prima del salvataggio.
     * 
     * @param istituto Istituto da creare
     * @return L'istituto salvato con il suo nuovo ID
     * @throws IllegalArgumentException Se la validazione fallisce
     */
    public Istituto creaIstituto(Istituto istituto) {
        validaIstituto(istituto);
        return istitutoRepository.save(istituto);
    }

    /**
     * Aggiorna un istituto esistente nel sistema.
     * 
     * Esegue la validazione dell'istituto prima dell'aggiornamento.
     * 
     * @param istituto Istituto da aggiornare
     * @return L'istituto aggiornato
     * @throws IllegalArgumentException Se la validazione fallisce
     */
    public Istituto aggiornaIstituto(Istituto istituto) {
        validaIstituto(istituto);
        return istitutoRepository.update(istituto);
    }

    /**
     * Elimina un istituto dal sistema.
     * 
     * L'eliminazione è consentita solo se non ci sono macchine associate all'istituto.
     * 
     * @param id Identificativo dell'istituto da eliminare
     * @return true se l'eliminazione ha avuto successo, false altrimenti
     * @throws SQLException 
     * @throws IllegalStateException Se l'istituto ha macchine associate
     */
    public boolean eliminaIstituto(int id) throws SQLException {
        List<Macchina> macchine = macchinaRepository.findByIstitutoId(id);
        if (!macchine.isEmpty()) {
            throw new IllegalStateException("Non è possibile eliminare un istituto con macchine associate");
        }
        return istitutoRepository.delete(id);
    }

    /**
     * Assegna una macchina a un istituto.
     * 
     * @param istitutoId Identificativo dell'istituto a cui assegnare la macchina
     * @param macchina Macchina da assegnare
     * @throws IllegalArgumentException Se l'istituto non esiste
     */
    public void assegnaMacchina(int istitutoId, Macchina macchina) {
        Istituto istituto = getIstitutoById(istitutoId);
        if (istituto == null) {
            throw new IllegalArgumentException("Istituto non trovato");
        }
        macchina.setIstitutoId(istitutoId);
        macchinaRepository.save(macchina);
    }

    /**
     * Rimuove una macchina da un istituto.
     * 
     * @param istitutoId Identificativo dell'istituto da cui rimuovere la macchina
     * @param macchinaId Identificativo della macchina da rimuovere
     * @throws IllegalArgumentException Se la macchina non esiste o non è associata all'istituto
     */
    public void rimuoviMacchina(int istitutoId, int macchinaId) {
        Macchina macchina = macchinaRepository.findById(macchinaId);
        if (macchina == null || macchina.getIstitutoId() != istitutoId) {
            throw new IllegalArgumentException("Macchina non trovata o non associata all'istituto");
        }
        macchinaRepository.delete(macchinaId);
    }

    /**
     * Convalida un istituto prima del salvataggio o dell'aggiornamento.
     * 
     * Verifica che il nome e l'indirizzo dell'istituto non siano nulli o vuoti.
     * 
     * @param istituto Istituto da validare
     * @throws IllegalArgumentException Se la validazione fallisce
     */
    private void validaIstituto(Istituto istituto) {
        if (istituto.getNome() == null || istituto.getNome().trim().isEmpty()) {
            throw new IllegalArgumentException("Nome istituto obbligatorio");
        }
        if (istituto.getIndirizzo() == null || istituto.getIndirizzo().trim().isEmpty()) {
            throw new IllegalArgumentException("Indirizzo istituto obbligatorio");
        }
    }
}

================
File: src/main/java/com/vending/core/services/MacchinaService.java
================
package com.vending.core.services;

import com.vending.core.models.*;
import com.vending.core.repositories.*;

import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Servizio per la gestione delle macchine distributrici.
 * Gestisce le operazioni di business logic per il ciclo di vita delle macchine,
 * incluse erogazione di bevande, gestione stati e transazioni finanziarie.
 */
public class MacchinaService {
    private final MacchinaRepository macchinaRepository;
    private final RicavoRepository ricavoRepository;
    private final TransazioneRepository transazioneRepository;

    /**
     * Costruttore del servizio.
     *
     * @param macchinaRepository repository per le macchine
     * @param ricavoRepository repository per i ricavi
     * @param transazioneRepository repository per le transazioni
     */
    public MacchinaService(MacchinaRepository macchinaRepository, 
                          RicavoRepository ricavoRepository,
                          TransazioneRepository transazioneRepository) {
        this.macchinaRepository = macchinaRepository;
        this.ricavoRepository = ricavoRepository;
        this.transazioneRepository = transazioneRepository;
    }

    /**
     * Recupera tutte le macchine nel sistema.
     *
     * @return Lista delle macchine
     */
    public List<Macchina> getTutteMacchine() {
        return macchinaRepository.findAll();
    }

    /**
     * Aggiorna lo stato di una macchina.
     *
     * @param id ID della macchina
     * @param nuovoStatoId nuovo stato da impostare
     * @return macchina aggiornata
     */
    public Macchina aggiornaMacchina(int id, int nuovoStatoId) {
        Macchina macchina = macchinaRepository.findById(id);
        if (macchina == null) {
            throw new IllegalArgumentException("Macchina non trovata: " + id);
        }

        if (!isStatoValido(nuovoStatoId)) {
            throw new IllegalArgumentException("Stato non valido: " + nuovoStatoId);
        }

        // Gestione cambio stato da manutenzione ad attiva
        if (macchina.getStatoId() == 2 && nuovoStatoId == 1) {
            //macchina.setDataUltimaManutenzione(LocalDateTime.now());
        }

        // Svuotamento cassa pre-manutenzione
        if (nuovoStatoId == 2 && macchina.getStatoId() != 2 && 
            macchina.getCassaAttuale() > 0) {
            
            svuotaCassa(macchina.getId());
        }

        macchina.setStatoId(nuovoStatoId);
        return macchinaRepository.update(macchina);
    }

    /**
     * Verifica se uno stato è valido.
     *
     * @param statoId stato da verificare
     * @return true se lo stato è valido
     */
    private boolean isStatoValido(int statoId) {
        return statoId >= 1 && statoId <= 3; // 1=Attiva, 2=In manutenzione, 3=Fuori servizio
    }

    /**
     * Recupera una macchina tramite ID.
     *
     * @param id ID della macchina
     * @return la macchina se trovata, null altrimenti
     */
    public Macchina getMacchinaById(int id) {
        if (id <= 0) {
            throw new IllegalArgumentException("ID non valido");
        }
        return macchinaRepository.findById(id);
    }

    /**
     * Recupera le macchine di un istituto.
     *
     * @param istitutoId ID dell'istituto
     * @return lista delle macchine dell'istituto
     * @throws SQLException 
     */
    public List<Macchina> getMacchineByIstituto(int istitutoId) throws SQLException {
        if (istitutoId <= 0) {
            throw new IllegalArgumentException("ID istituto non valido");
        }
        return macchinaRepository.findByIstitutoId(istitutoId);
    }

    /**
     * Crea una nuova macchina.
     *
     * @param macchina macchina da creare
     * @return macchina creata
     */
    public Macchina creaMacchina(Macchina macchina) {
        validaMacchina(macchina);
        macchina.setStatoId(1); // Attiva
        macchina.setCreditoAttuale(0.0);
        return macchinaRepository.save(macchina);
    }

    /**
     * Aggiorna una macchina esistente.
     *
     * @param macchina macchina da aggiornare
     * @return macchina aggiornata
     */
    public Macchina aggiornaMacchina(Macchina macchina) {
        validaMacchina(macchina);
        return macchinaRepository.update(macchina);
    }

    /**
     * Elimina una macchina.
     *
     * @param id ID della macchina
     * @return true se l'eliminazione ha successo
     */
    public boolean eliminaMacchina(int id) {
        return macchinaRepository.delete(id);
    }

    /**
     * Inserisce denaro nella macchina.
     *
     * @param macchinaId ID della macchina
     * @param importo importo da inserire
     * @return true se l'inserimento ha successo
     */
    public boolean inserisciDenaro(int macchinaId, Double importo) {
        Macchina macchina = getMacchinaById(macchinaId);
        if (macchina == null) {
            throw new IllegalArgumentException("Macchina non trovata");
        }

        if (macchina.getStatoId() != 1) {
            throw new IllegalStateException("Macchina non attiva");
        }

        if (!macchina.puoAccettareDenaro(importo)) {
            return false;
        }

        macchina.setCreditoAttuale(macchina.getCreditoAttuale() + importo);
        macchinaRepository.update(macchina);
        return true;
    }

    /**
     * Eroga una bevanda.
     *
     * @param macchinaId ID della macchina
     * @param bevandaId ID della bevanda
     * @return transazione completata
     */
    public Transazione erogaBevanda(int macchinaId, int bevandaId) {
        Macchina macchina = getMacchinaById(macchinaId);
        if (macchina == null) {
            throw new IllegalArgumentException("Macchina non trovata");
        }

        if (macchina.getStatoId() != 1) {
            throw new IllegalStateException("Macchina non attiva");
        }

        Bevanda bevanda = macchina.getBevande().stream()
                .filter(b -> b.getId() == bevandaId)
                .findFirst()
                .orElse(null);

        if (bevanda == null) {
            throw new IllegalArgumentException("Bevanda non disponibile");
        }

        if (!macchina.hasCreditorSufficiente(bevanda.getPrezzo())) {
            throw new IllegalStateException("Credito insufficiente");
        }

        verificaDisponibilitaCialde(macchina, bevanda);

        // Crea transazione
        Transazione transazione = new Transazione();
        transazione.setMacchinaId(macchinaId);
        transazione.setBevandaId(bevandaId);
        transazione.setImporto(bevanda.getPrezzo());
        transazione.setDataOra(LocalDateTime.now());

        // Aggiorna stato macchina
        macchina.setCreditoAttuale(macchina.getCreditoAttuale() - bevanda.getPrezzo());
        macchina.setCassaAttuale(macchina.getCassaAttuale() + bevanda.getPrezzo());
        decrementaCialde(macchina, bevanda);

        macchinaRepository.update(macchina);
        return transazioneRepository.save(transazione);
    }

    /**
     * Restituisce il credito residuo.
     *
     * @param macchinaId ID della macchina
     * @return importo restituito
     */
    public Double restituisciCredito(int macchinaId) {
        Macchina macchina = getMacchinaById(macchinaId);
        if (macchina == null) {
            throw new IllegalArgumentException("Macchina non trovata");
        }

        Double credito = macchina.getCreditoAttuale();
        macchina.setCreditoAttuale(0.0);
        macchinaRepository.update(macchina);
        return credito;
    }

    /**
     * Svuota la cassa di una macchina.
     *
     * @param macchinaId ID della macchina
     */
    public void svuotaCassa(int macchinaId) {
        Macchina macchina = getMacchinaById(macchinaId);
        if (macchina == null) {
            throw new IllegalArgumentException("Macchina non trovata");
        }

        if (macchina.getCassaAttuale() > 0) {
            Ricavo ricavo = new Ricavo();
            ricavo.setMacchinaId(macchinaId);
            ricavo.setImporto(macchina.getCassaAttuale());
            ricavo.setDataOra(LocalDateTime.now());
            ricavoRepository.save(ricavo);

            macchina.setCassaAttuale(0.0);
            macchinaRepository.update(macchina);
        }
    }

    /**
     * Valida i dati di una macchina.
     */
    private void validaMacchina(Macchina macchina) {
        if (macchina.getIstitutoId() <= 0) {
            throw new IllegalArgumentException("Istituto non valido");
        }
        if (macchina.getCassaMassima() <= 0) {
            throw new IllegalArgumentException("Capacità cassa non valida");
        }
    }

    /**
     * Verifica la disponibilità delle cialde.
     */
    private void verificaDisponibilitaCialde(Macchina macchina, Bevanda bevanda) {
        for (Cialda cialda : bevanda.getCialde()) {
            QuantitaCialde qc = macchina.getCialde().stream()
                    .filter(q -> q.getCialdaId() == cialda.getId())
                    .findFirst()
                    .orElse(null);

            if (qc == null) {
                throw new IllegalStateException("Cialda non disponibile: " + cialda.getNome());
            }

            if (qc.getQuantita() <= 0) {
                throw new IllegalStateException("Cialda esaurita: " + cialda.getNome());
            }
        }
    }

    /**
     * Decrementa le cialde utilizzate.
     */
    private void decrementaCialde(Macchina macchina, Bevanda bevanda) {
        for (Cialda cialda : bevanda.getCialde()) {
            macchina.getCialde().stream()
                    .filter(q -> q.getCialdaId() == cialda.getId())
                    .forEach(QuantitaCialde::decrementaQuantita);
        }
    }
}

================
File: src/main/java/com/vending/core/services/ManutenzioneService.java
================
package com.vending.core.services;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.JsonSyntaxException;
import com.vending.core.models.Macchina;
import com.vending.core.models.Manutenzione;
import com.vending.core.repositories.ManutenzioneRepository;
import com.vending.core.repositories.MacchinaRepository;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Servizio che gestisce la logica di business relativa alle manutenzioni delle macchine distributrici.
 * Gestisce il ciclo di vita delle manutenzioni, dalla segnalazione al completamento,
 * integrando i dati delle macchine e dei tecnici assegnati.
 */
public class ManutenzioneService {
    private final ManutenzioneRepository manutenzioneRepository;
    private final MacchinaRepository macchinaRepository;

    /**
     * Costruisce un nuovo servizio manutenzioni.
     *
     * @param manutenzioneRepository repository per l'accesso ai dati delle manutenzioni
     * @param macchinaRepository repository per l'accesso ai dati delle macchine
     */
    public ManutenzioneService(ManutenzioneRepository manutenzioneRepository, 
                              MacchinaRepository macchinaRepository) {
        this.manutenzioneRepository = manutenzioneRepository;
        this.macchinaRepository = macchinaRepository;
    }

    /**
     * Recupera tutte le manutenzioni attive nel sistema.
     * Una manutenzione è considerata attiva se non ha una data di completamento.
     *
     * @return lista delle manutenzioni attive
     * @throws RuntimeException se si verifica un errore durante il recupero
     */
    public List<Manutenzione> getManutenzioniAttive() {
        try {
            return manutenzioneRepository.findAll().stream()
                    .filter(m -> !m.isCompletata())
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new RuntimeException("Errore nel recupero delle manutenzioni attive", e);
        }
    }

    /**
     * Recupera tutte le manutenzioni di una specifica macchina.
     *
     * @param macchinaId ID della macchina
     * @return lista delle manutenzioni della macchina
     * @throws IllegalArgumentException se la macchina non esiste
     * @throws RuntimeException se si verifica un errore durante il recupero
     */
    public List<Manutenzione> getManutenzioniMacchina(int macchinaId) {
        Macchina macchina = validaMacchina(macchinaId);
        if (macchina == null) {
            throw new IllegalArgumentException("Macchina con id: " + macchinaId + " non trovata");
        }
        return manutenzioneRepository.findByMacchinaId(macchinaId);
    }

    /**
     * Recupera lo stato dettagliato di manutenzione di una macchina.
     *
     * @param macchinaId ID della macchina
     * @return mappa contenente lo stato e le statistiche di manutenzione
     * @throws IllegalArgumentException se la macchina non esiste
     * @throws RuntimeException se si verifica un errore durante il recupero
     */
    public Map<String, Object> getStatoManutenzione(int macchinaId) {
        try {
            Macchina macchina = validaMacchina(macchinaId);
            List<Manutenzione> manutenzioni = manutenzioneRepository.findByMacchinaId(macchinaId);
            
            List<Manutenzione> attive = manutenzioni.stream()
                    .filter(m -> !m.isCompletata())
                    .collect(Collectors.toList());
            
            List<Manutenzione> completate = manutenzioni.stream()
                    .filter(Manutenzione::isCompletata)
                    .collect(Collectors.toList());

            Map<String, Object> stato = new HashMap<>();
            stato.put("statoId", macchina.getStatoId());
            stato.put("statoDescrizione", macchina.getStatoDescrizione());
            stato.put("manutenzioniAttive", attive);
            stato.put("numeroManutenzioniAttive", attive.size());
            
            completate.stream()
                    .max((a, b) -> a.getDataCompletamento().compareTo(b.getDataCompletamento()))
                    .ifPresent(m -> stato.put("ultimaManutenzione", m));

            return stato;
        } catch (IllegalArgumentException e) {
            throw e;
        } catch (Exception e) {
            throw new RuntimeException("Errore nel recupero dello stato manutenzione", e);
        }
    }

    /**
     * Avvia una nuova manutenzione per una macchina.
     *
     * @param macchinaId ID della macchina
     * @param tecnicoId ID del tecnico assegnato
     * @param tipoIntervento Tipo di intervento
     * @param descrizione Descrizione della manutenzione
     * @param urgenza Urgenza della manutenzione (BASSA, MEDIA, ALTA)
     * @return la manutenzione creata
     * @throws IllegalArgumentException se i parametri non sono validi
     * @throws RuntimeException se si verifica un errore durante la creazione
     */
    public Manutenzione avviaManutenzione(int macchinaId, String tipoIntervento, int tecnicoId, String descrizione, String urgenza) {
        try {
            Macchina macchina = validaMacchina(macchinaId);
            
            Manutenzione manutenzione = new Manutenzione(macchinaId, tipoIntervento, descrizione, urgenza);
            manutenzione.setTecnicoId(tecnicoId);
            manutenzione.setDataRichiesta(LocalDateTime.now());
            
            macchina.setStatoId(2); // In manutenzione
            macchinaRepository.update(macchina);
            
            return manutenzioneRepository.save(manutenzione);
        } catch (IllegalArgumentException e) {
            throw e;
        } catch (Exception e) {
            throw new RuntimeException("Errore nell'avvio della manutenzione", e);
        }
    }

    /**
     * Completa una manutenzione esistente.
     *
     * @param manutenzioneId ID della manutenzione
     * @param note note di completamento
     * @return la manutenzione completata
     * @throws IllegalArgumentException se la manutenzione non esiste
     * @throws IllegalStateException se la manutenzione è già completata
     * @throws RuntimeException se si verifica un errore durante il completamento
     */
    public Manutenzione completaManutenzione(int manutenzioneId, String note) {
        try {
            Optional<Manutenzione> optManutenzione = manutenzioneRepository.findById(manutenzioneId);
            if (!optManutenzione.isPresent()) {
                throw new IllegalArgumentException("Manutenzione non trovata: " + manutenzioneId);
            }

            Manutenzione manutenzione = optManutenzione.get();
            if (manutenzione.isCompletata()) {
                throw new IllegalStateException("Manutenzione già completata");
            }

            Manutenzione manutenzioneCompletata = manutenzioneRepository.completaManutenzione(manutenzione);

            // Verifica altre manutenzioni attive
            List<Manutenzione> altreAttive = getManutenzioniMacchina(manutenzione.getMacchinaId())
                    .stream()
                    .filter(m -> !m.isCompletata())
                    .collect(Collectors.toList());

            if (altreAttive.isEmpty()) {
                Macchina macchina = validaMacchina(manutenzione.getMacchinaId());
                macchina.setStatoId(1); // Attiva
                macchinaRepository.update(macchina);
            }

            return manutenzioneCompletata;
        } catch (IllegalArgumentException | IllegalStateException e) {
            throw e;
        } catch (Exception e) {
            throw new RuntimeException("Errore nel completamento della manutenzione", e);
        }
    }

    /**
     * Imposta una macchina come fuori servizio.
     *
     * @param macchinaId ID della macchina
     * @return true se l'operazione ha successo
     * @throws IllegalArgumentException se la macchina non esiste
     * @throws RuntimeException se si verifica un errore durante l'operazione
     */
    public boolean setFuoriServizio(int macchinaId) {
        Macchina macchina = validaMacchina(macchinaId);
        if (macchina == null) {
            throw new IllegalArgumentException("Macchina con id: " + macchinaId + " non trovata");
        }
        return manutenzioneRepository.setFuoriServizio(macchinaId);
    }

    /**
     * Valida l'esistenza di una macchina.
     *
     * @param macchinaId ID della macchina da validare
     * @return la macchina se esiste
     * @throws IllegalArgumentException se la macchina non esiste
     */
    private Macchina validaMacchina(int macchinaId) {
        Macchina macchina = macchinaRepository.findById(macchinaId);
        if (macchina == null) {
            throw new IllegalArgumentException("Macchina non trovata: " + macchinaId);
        }
        return macchina;
    }

    /**
     * Processa i messaggi relativi allo stato di una macchina e avvia le manutenzioni necessarie.
     * Gestisce gli stati: guasto, rifornimento cialde necessario, svuotamento cassa necessario.
     *
     * @param topic topic MQTT del messaggio
     * @param message contenuto del messaggio in formato JSON
     * @throws IllegalArgumentException se il messaggio non è valido
     * @throws RuntimeException se si verifica un errore durante l'elaborazione
     */
    public void processaMacchinaStato(String topic, String message) {
        try {
            // Estrai l'ID della macchina dal topic (formato: macchine/{id}/stato)
            int macchinaId = estraiMacchinaIdDaTopic(topic);
            JsonObject statoMacchina = JsonParser.parseString(message).getAsJsonObject();
            
            // Valida la macchina
            Macchina macchina = validaMacchina(macchinaId);
            
            // Processa i diversi tipi di stato
            if (statoMacchina.has("guasto") && statoMacchina.get("guasto").getAsBoolean()) {
                // Avvia manutenzione per guasto
                gestisciGuasto(macchina, statoMacchina);
            }
            
            if (statoMacchina.has("cialde")) {
                // Verifica necessità rifornimento cialde
                gestisciStatoCialde(macchina, statoMacchina.getAsJsonObject("cialde"));
            }
            
            if (statoMacchina.has("cassa")) {
                // Verifica necessità svuotamento cassa
                gestisciStatoCassa(macchina, statoMacchina.getAsJsonObject("cassa"));
            }
            
        } catch (JsonSyntaxException e) {
            throw new IllegalArgumentException("Formato messaggio non valido: " + e.getMessage());
        } catch (Exception e) {
            throw new RuntimeException("Errore nell'elaborazione dello stato macchina: " + e.getMessage());
        }
    }

    private void gestisciGuasto(Macchina macchina, JsonObject statoMacchina) {
        // Se non ci sono già manutenzioni attive per guasto
        List<Manutenzione> manutenzioniAttive = getManutenzioniMacchina(macchina.getId())
                .stream()
                .filter(m -> !m.isCompletata())
                .collect(Collectors.toList());
                
        if (manutenzioniAttive.isEmpty()) {
            String descrizioneGuasto = statoMacchina.has("descrizioneGuasto") ? 
                    statoMacchina.get("descrizioneGuasto").getAsString() : 
                    "Guasto generico";
                    
            avviaManutenzione(
                macchina.getId(),
                "GUASTO", // Tipo di intervento
                0, // Tecnico da assegnare
                "Guasto rilevato: " + descrizioneGuasto,
                "ALTA" // Urgenza alta per guasti
            );
        }
    }

    private void gestisciStatoCialde(Macchina macchina, JsonObject statoCialde) {
        boolean rifornimentoNecessario = false;
        StringBuilder noteCialde = new StringBuilder("Rifornimento cialde necessario: ");
        
        // Verifica soglie cialde per ogni tipo
        for (Map.Entry<String, JsonElement> entry : statoCialde.entrySet()) {
            JsonObject cialda = entry.getValue().getAsJsonObject();
            int quantita = cialda.get("quantita").getAsInt();
            int soglia = cialda.get("soglia").getAsInt();
            
            if (quantita <= soglia) {
                rifornimentoNecessario = true;
                noteCialde.append(entry.getKey())
                        .append(" (")
                        .append(quantita)
                        .append("/")
                        .append(cialda.get("massimo").getAsInt())
                        .append("), ");
            }
        }
        
        if (rifornimentoNecessario) {
            // Se non ci sono già manutenzioni attive per rifornimento
            List<Manutenzione> manutenzioniAttive = getManutenzioniMacchina(macchina.getId())
                    .stream()
                    .filter(m -> !m.isCompletata())
                    .collect(Collectors.toList());
                    
            if (manutenzioniAttive.isEmpty()) {
                avviaManutenzione(
                    macchina.getId(),
                    "RIFORNIMENTO_CIALDE", // Tipo di intervento
                    0, // Tecnico da assegnare
                    noteCialde.toString().replaceAll(", $", ""),
                    "MEDIA" // Urgenza media per rifornimento cialde
                );
            }
        }
    }

    private void gestisciStatoCassa(Macchina macchina, JsonObject statoCassa) {
        double importoAttuale = statoCassa.get("importo").getAsDouble();
        double importoMassimo = statoCassa.get("massimo").getAsDouble();
        
        // Se la cassa ha raggiunto l'80% della capacità
        if (importoAttuale >= (importoMassimo * 0.8)) {
            // Se non ci sono già manutenzioni attive per svuotamento cassa
            List<Manutenzione> manutenzioniAttive = getManutenzioniMacchina(macchina.getId())
                    .stream()
                    .filter(m -> !m.isCompletata())
                    .collect(Collectors.toList());
                    
            if (manutenzioniAttive.isEmpty()) {
                avviaManutenzione(
                    macchina.getId(),
                    "SVUOTAMENTO_CASSA", // Tipo di intervento
                    0, // Tecnico da assegnare
                    String.format("Svuotamento cassa necessario: %.2f/%.2f euro", importoAttuale, importoMassimo),
                    "ALTA" // Urgenza alta per svuotamento cassa
                );
            }
        }
    }

    private int estraiMacchinaIdDaTopic(String topic) {
        try {
            String[] parts = topic.split("/");
            return Integer.parseInt(parts[1]);
        } catch (Exception e) {
            throw new IllegalArgumentException("Topic non valido: " + topic);
        }
    }
}

================
File: src/main/java/com/vending/core/services/RicavoService.java
================
package com.vending.core.services;

import com.vending.core.models.Ricavo;
import com.vending.core.repositories.RicavoRepository;
import java.time.LocalDateTime;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

/**
 * Servizio che gestisce la logica di business relativa ai ricavi delle macchine distributrici.
 * Si occupa della registrazione, del recupero e dell'analisi dei ricavi generati 
 * dalle macchine installate negli istituti.
 */
public class RicavoService {
    private final RicavoRepository ricavoRepository;

    /**
     * Costruisce un nuovo servizio ricavi.
     *
     * @param ricavoRepository repository per l'accesso ai dati dei ricavi
     */
    public RicavoService(RicavoRepository ricavoRepository) {
        this.ricavoRepository = ricavoRepository;
    }

    /**
     * Recupera tutti i ricavi registrati nel sistema, ordinati per data decrescente.
     *
     * @return lista di tutti i ricavi registrati
     * @throws RuntimeException se si verifica un errore durante il recupero dei dati
     */
    public List<Ricavo> getTuttiRicavi() {
        return ricavoRepository.findAll();
    }

    /**
     * Recupera tutti i ricavi di una specifica macchina.
     *
     * @param macchinaId ID della macchina di cui recuperare i ricavi
     * @return lista dei ricavi della macchina specificata
     * @throws RuntimeException se si verifica un errore durante il recupero dei dati
     */
    public List<Ricavo> getRicaviMacchina(int macchinaId) {
        validaMacchinaId(macchinaId);
        return ricavoRepository.findByMacchinaId(macchinaId);
    }

    /**
     * Calcola il totale dei ricavi di una specifica macchina.
     *
     * @param macchinaId ID della macchina di cui calcolare il totale dei ricavi
     * @return totale dei ricavi della macchina
     * @throws IllegalArgumentException se l'ID della macchina non è valido
     * @throws RuntimeException se si verifica un errore durante il calcolo
     */
    public double getTotaleRicaviMacchina(int macchinaId) {
        validaMacchinaId(macchinaId);
        return ricavoRepository.getTotaleRicaviByMacchina(macchinaId);
    }

    /**
     * Calcola il totale dei ricavi in un determinato periodo di tempo.
     *
     * @param dataInizio data e ora di inizio del periodo
     * @param dataFine data e ora di fine del periodo
     * @return totale dei ricavi nel periodo specificato
     * @throws IllegalArgumentException se le date non sono valide
     * @throws RuntimeException se si verifica un errore durante il calcolo
     */
    public double getTotaleRicaviPeriodo(LocalDateTime dataInizio, LocalDateTime dataFine) {
        validaPeriodo(dataInizio, dataFine);
        return ricavoRepository.getTotaleRicaviPeriodo(dataInizio, dataFine);
    }

    /**
     * Recupera il ricavo giornaliero di un istituto per una data specifica.
     *
     * @param istitutoId ID dell'istituto
     * @param data data per cui recuperare il ricavo
     * @return Optional contenente il ricavo giornaliero se presente
     * @throws IllegalArgumentException se l'ID dell'istituto non è valido
     * @throws RuntimeException se si verifica un errore durante il recupero
     */
    public Optional<Double> getRicavoGiornaliero(int istitutoId, LocalDate data) {
        validaIstitutoId(istitutoId);
        if (data == null) {
            throw new IllegalArgumentException("La data non può essere null");
        }
        return ricavoRepository.findRicavoGiornaliero(istitutoId, data);
    }

    /**
     * Registra un nuovo ricavo per una macchina.
     *
     * @param macchinaId ID della macchina che ha generato il ricavo
     * @param importo importo del ricavo
     * @param notaOperatore nota opzionale dell'operatore
     * @return il ricavo registrato
     * @throws IllegalArgumentException se i parametri non sono validi
     * @throws RuntimeException se si verifica un errore durante il salvataggio
     */
    public Ricavo registraRicavo(int macchinaId, double importo, String notaOperatore) {
        validaRicavo(macchinaId, importo);
        
        Ricavo ricavo = new Ricavo();
        ricavo.setMacchinaId(macchinaId);
        ricavo.setImporto(importo);
        ricavo.setDataOra(LocalDateTime.now());
        
        return ricavoRepository.save(ricavo);
    }

    /**
     * Valida i parametri di un ricavo.
     *
     * @param macchinaId ID della macchina da validare
     * @param importo importo da validare
     * @throws IllegalArgumentException se i parametri non sono validi
     */
    private void validaRicavo(int macchinaId, double importo) {
        validaMacchinaId(macchinaId);
        if (importo <= 0) {
            throw new IllegalArgumentException("L'importo deve essere maggiore di zero");
        }
    }

    /**
     * Valida l'ID di una macchina.
     *
     * @param macchinaId ID della macchina da validare
     * @throws IllegalArgumentException se l'ID non è valido
     */
    private void validaMacchinaId(int macchinaId) {
        if (macchinaId <= 0) {
            throw new IllegalArgumentException("L'ID della macchina deve essere maggiore di zero");
        }
    }

    /**
     * Valida l'ID di un istituto.
     *
     * @param istitutoId ID dell'istituto da validare
     * @throws IllegalArgumentException se l'ID non è valido
     */
    private void validaIstitutoId(int istitutoId) {
        if (istitutoId <= 0) {
            throw new IllegalArgumentException("L'ID dell'istituto deve essere maggiore di zero");
        }
    }

    /**
     * Valida un periodo temporale.
     *
     * @param dataInizio data di inizio del periodo
     * @param dataFine data di fine del periodo
     * @throws IllegalArgumentException se le date non sono valide
     */
    private void validaPeriodo(LocalDateTime dataInizio, LocalDateTime dataFine) {
        if (dataInizio == null || dataFine == null) {
            throw new IllegalArgumentException("Le date non possono essere null");
        }
        if (dataInizio.isAfter(dataFine)) {
            throw new IllegalArgumentException("La data di inizio deve essere precedente alla data di fine");
        }
    }
}

================
File: src/main/java/com/vending/core/services/TransazioneService.java
================
package com.vending.core.services;

import com.vending.core.models.Transazione;
import com.vending.core.repositories.TransazioneRepository;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Servizio che gestisce la logica di business relativa alle transazioni delle macchine distributrici.
 * Si occupa della registrazione e dell'analisi delle vendite di bevande effettuate dalle
 * macchine installate negli istituti.
 */
public class TransazioneService {
    private final TransazioneRepository transazioneRepository;

    /**
     * Costruisce un nuovo servizio transazioni.
     *
     * @param transazioneRepository repository per l'accesso ai dati delle transazioni
     */
    public TransazioneService(TransazioneRepository transazioneRepository) {
        this.transazioneRepository = transazioneRepository;
    }

    /**
     * Recupera tutte le transazioni registrate nel sistema, ordinate per data decrescente.
     *
     * @return lista di tutte le transazioni registrate
     * @throws RuntimeException se si verifica un errore durante il recupero dei dati
     */
    public List<Transazione> getTutteTransazioni() {
        return transazioneRepository.findAll();
    }

    /**
     * Recupera le transazioni recenti (ultime 100) dal sistema.
     * Utilizza la vista 'transazionirecenti' del database.
     *
     * @return lista delle transazioni recenti
     * @throws RuntimeException se si verifica un errore durante il recupero dei dati
     */
    public List<Transazione> getTransazioniRecenti() {
        return transazioneRepository.findTransazioniRecenti();
    }

    /**
     * Recupera una transazione specifica tramite il suo ID.
     *
     * @param id ID della transazione da recuperare
     * @return Optional contenente la transazione se trovata
     * @throws RuntimeException se si verifica un errore durante il recupero
     */
    public Optional<Transazione> getTransazione(int id) {
        return transazioneRepository.findById(id);
    }

    /**
     * Recupera tutte le transazioni di una specifica macchina.
     *
     * @param macchinaId ID della macchina di cui recuperare le transazioni
     * @return lista delle transazioni della macchina specificata
     * @throws IllegalArgumentException se l'ID della macchina non è valido
     * @throws RuntimeException se si verifica un errore durante il recupero
     */
    public List<Transazione> getTransazioniMacchina(int macchinaId) {
        validaMacchinaId(macchinaId);
        return transazioneRepository.findByMacchinaId(macchinaId);
    }

    /**
     * Calcola il totale delle transazioni di una macchina in un determinato periodo.
     *
     * @param macchinaId ID della macchina
     * @param dataInizio data e ora di inizio del periodo
     * @param dataFine data e ora di fine del periodo
     * @return totale delle transazioni nel periodo specificato
     * @throws IllegalArgumentException se i parametri non sono validi
     * @throws RuntimeException se si verifica un errore durante il calcolo
     */
    public double calcolaTotaleMacchina(int macchinaId, LocalDateTime dataInizio, LocalDateTime dataFine) {
        validaMacchinaId(macchinaId);
        validaPeriodo(dataInizio, dataFine);
        return transazioneRepository.calcolaTotaleMacchina(macchinaId, dataInizio, dataFine);
    }

    /**
     * Registra una nuova transazione nel sistema.
     *
     * @param transazione transazione da registrare
     * @return la transazione registrata con ID generato
     * @throws IllegalArgumentException se i dati della transazione non sono validi
     * @throws RuntimeException se si verifica un errore durante il salvataggio
     */
    public Transazione registraTransazione(Transazione transazione) {
        validaTransazione(transazione);
        transazione.setDataOra(LocalDateTime.now());
        return transazioneRepository.save(transazione);
    }

    /**
     * Valida i dati di una transazione.
     *
     * @param transazione transazione da validare
     * @throws IllegalArgumentException se i dati della transazione non sono validi
     */
    private void validaTransazione(Transazione transazione) {
        if (transazione == null) {
            throw new IllegalArgumentException("La transazione non può essere null");
        }
        if (transazione.getMacchinaId() <= 0) {
            throw new IllegalArgumentException("L'ID della macchina deve essere maggiore di zero");
        }
        if (transazione.getBevandaId() <= 0) {
            throw new IllegalArgumentException("L'ID della bevanda deve essere maggiore di zero");
        }
        if (transazione.getImporto() <= 0) {
            throw new IllegalArgumentException("L'importo deve essere maggiore di zero");
        }
    }

    /**
     * Valida l'ID di una macchina.
     *
     * @param macchinaId ID della macchina da validare
     * @throws IllegalArgumentException se l'ID non è valido
     */
    private void validaMacchinaId(int macchinaId) {
        if (macchinaId <= 0) {
            throw new IllegalArgumentException("L'ID della macchina deve essere maggiore di zero");
        }
    }

    /**
     * Valida un periodo temporale.
     *
     * @param dataInizio data di inizio del periodo
     * @param dataFine data di fine del periodo
     * @throws IllegalArgumentException se le date non sono valide
     */
    private void validaPeriodo(LocalDateTime dataInizio, LocalDateTime dataFine) {
        if (dataInizio == null || dataFine == null) {
            throw new IllegalArgumentException("Le date non possono essere null");
        }
        if (dataInizio.isAfter(dataFine)) {
            throw new IllegalArgumentException("La data di inizio deve essere precedente alla data di fine");
        }
    }
}

================
File: src/main/java/com/vending/core/services/UtenteService.java
================
package com.vending.core.services;

import com.vending.core.models.Utente;
import com.vending.core.repositories.UtenteRepository;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Servizio che gestisce la logica di business relativa agli utenti del sistema.
 * Gestisce l'autenticazione, la creazione e la modifica degli account utente,
 * utilizzando la crittografia BCrypt integrata nel modello Utente.
 */
public class UtenteService {
    private final UtenteRepository utenteRepository;

    /**
     * Costruisce un nuovo servizio utenti.
     *
     * @param utenteRepository repository per l'accesso ai dati degli utenti
     */
    public UtenteService(UtenteRepository utenteRepository) {
        this.utenteRepository = utenteRepository;
    }

    /**
     * Autentica un utente tramite username e password.
     * In caso di successo, aggiorna anche la data dell'ultimo accesso.
     *
     * @param username nome utente
     * @param password password in chiaro
     * @return utente autenticato o null se l'autenticazione fallisce
     * @throws RuntimeException se si verifica un errore durante l'autenticazione
     */
    public Utente autenticaUtente(String username, String password) {
        Utente utente = utenteRepository.findByUsername(username);
        if (utente != null && utente.verifyPassword(password)) {
            utente.aggiornaUltimoAccesso();
            return utenteRepository.update(utente);
        }
        return null;
    }

    /**
     * Recupera tutti gli utenti registrati nel sistema.
     *
     * @return lista di tutti gli utenti
     * @throws RuntimeException se si verifica un errore durante il recupero
     */
    public List<Utente> getTuttiUtenti() {
        return utenteRepository.findAll();
    }

    /**
     * Recupera gli utenti con un determinato ruolo.
     *
     * @param ruolo ruolo degli utenti da cercare
     * @return lista degli utenti con il ruolo specificato
     * @throws IllegalArgumentException se il ruolo non è valido
     * @throws RuntimeException se si verifica un errore durante il recupero
     */
    public List<Utente> getUtentiPerRuolo(String ruolo) {
        validaRuolo(ruolo);
        return utenteRepository.findByRuolo(ruolo);
    }

    /**
     * Recupera un utente specifico tramite il suo ID.
     *
     * @param id ID dell'utente da recuperare
     * @return Optional contenente l'utente se trovato
     * @throws RuntimeException se si verifica un errore durante il recupero
     */
    public Optional<Utente> getUtenteById(int id) {
        return utenteRepository.findById(id);
    }

    /**
     * Crea un nuovo utente nel sistema.
     * La password viene automaticamente crittografata dal modello Utente.
     *
     * @param utente utente da creare
     * @return l'utente creato con ID generato
     * @throws IllegalArgumentException se i dati dell'utente non sono validi
     * @throws RuntimeException se si verifica un errore durante il salvataggio
     */
    public Utente creaUtente(Utente utente) {
        // Verifica che l'utente non esista già
        if (utenteRepository.findByUsername(utente.getUsername()) != null) {
            throw new IllegalArgumentException("Username già in uso");
        }

        // Valida l'utente prima di salvarlo
        validaUtente(utente);

        // Salva l'utente nel database
        return utenteRepository.save(utente);
    }

    /**
     * Aggiorna i dati di un utente esistente.
     * Se viene fornita una nuova password, questa viene crittografata.
     *
     * @param utente utente da aggiornare
     * @return l'utente aggiornato
     * @throws IllegalArgumentException se i dati dell'utente non sono validi
     * @throws RuntimeException se si verifica un errore durante l'aggiornamento
     */
    public Utente aggiornaUtente(Utente utente) {
        validaUtente(utente);
        return utenteRepository.update(utente);
    }

    /**
     * Elimina un utente dal sistema.
     *
     * @param id ID dell'utente da eliminare
     * @return true se l'eliminazione ha successo
     * @throws RuntimeException se si verifica un errore durante l'eliminazione
     */
    public boolean eliminaUtente(int id) {
        return utenteRepository.delete(id);
    }
    
    /**
     * Trova l'ID di un ruolo per nome.
     *
     * @param nomeRuolo Il nome del ruolo da cercare.
     * @return L'ID del ruolo, o -1 se non trovato.
     */
    public int trovaIdRuolo(String nomeRuolo) {
        switch (nomeRuolo) {
            case "amministratore":
                return 2;
            case "tecnico":
                return 1;
            case "operatore":
                return 3;
            default:
                return -1; // Ruolo non valido
        }
    }

    /**
     * Valida i dati di un utente.
     *
     * @param utente utente da validare
     * @throws IllegalArgumentException se i dati dell'utente non sono validi
     */
    private void validaUtente(Utente utente) {
        if (utente == null) {
            throw new IllegalArgumentException("L'utente non può essere null");
        }
        if (utente.getNome() == null || utente.getNome().trim().isEmpty()) {
            throw new IllegalArgumentException("Il nome è obbligatorio");
        }
        if (utente.getUsername() == null || utente.getUsername().trim().isEmpty()) {
            throw new IllegalArgumentException("Lo username è obbligatorio");
        }
        if (utente.getPasswordHash() == null && 
            (utente.getId() == 0)) { // Solo per nuovi utenti
            throw new IllegalArgumentException("La password è obbligatoria per i nuovi utenti");
        }
    }

    /**
     * Valida il ruolo di un utente.
     *
     * @param ruolo ruolo da validare
     * @throws IllegalArgumentException se il ruolo non è valido
     */
    private void validaRuolo(String ruolo) {
        if (ruolo == null || ruolo.trim().isEmpty()) {
            throw new IllegalArgumentException("Il ruolo è obbligatorio");
        }
        if (!ruolo.equals("Amministratore") && !ruolo.equals("Tecnico") && !ruolo.equals("Operatore")) {
            throw new IllegalArgumentException("Ruolo non valido. I ruoli ammessi sono: Amministratore, Tecnico, Operatore");
        }
    }
    
    
}

================
File: src/main/java/com/vending/iot/bridge/BridgeConfig.java
================
package com.vending.iot.bridge;

public class BridgeConfig {
    private final String brokerLocalUrl;
    private final String brokerCentraleUrl;
    private final String prefissoScuola;

    public BridgeConfig(String brokerLocalUrl, String brokerCentraleUrl, String prefissoScuola) {
        this.brokerLocalUrl = brokerLocalUrl;
        this.brokerCentraleUrl = brokerCentraleUrl;
        this.prefissoScuola = prefissoScuola;
    }

    public String getBrokerLocalUrl() {
        return brokerLocalUrl;
    }

    public String getBrokerCentraleUrl() {
        return brokerCentraleUrl;
    }

    public String getTopicCentrale(String scuolaId, String topicLocale) {
        return prefissoScuola + "/" + scuolaId + "/" + topicLocale;
    }

    public String getTopicLocale(String scuolaId, String topicCentrale) {
        String prefix = prefissoScuola + "/" + scuolaId + "/";
        return topicCentrale.startsWith(prefix) ? topicCentrale.substring(prefix.length()) : topicCentrale;
    }
}

================
File: src/main/java/com/vending/iot/bridge/MQTTBridge.java
================
package com.vending.iot.bridge;

import com.vending.iot.mqtt.MQTTClient;
import org.eclipse.paho.client.mqttv3.MqttException;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Bridge MQTT che gestisce la comunicazione tra broker MQTT locale e centrale.
 * Questa classe implementa un meccanismo di bridging bidirezionale che inoltra
 * i messaggi tra un broker MQTT locale (di una scuola) e un broker MQTT
 * centrale,
 * applicando regole di inoltro configurabili per topic specifici.
 *
 * @author [Esoardo Giovanni Fracchia]
 * @version 1.0
 * @see com.vending.iot.mqtt.MQTTClient
 * @see com.vending.iot.bridge.BridgeConfig
 */
public class MQTTBridge {
    private final String scuolaId;
    private final MQTTClient clientLocale;
    private final MQTTClient clientCentrale;
    private final Set<String> topicDaInoltrare;
    private final BridgeConfig config;

    /**
     * Costruisce un nuovo bridge MQTT per una specifica scuola.
     * Inizializza le connessioni ai broker locale e centrale e configura
     * il meccanismo di bridging.
     *
     * @param scuolaId identificativo univoco della scuola
     * @param config   configurazione del bridge contenente parametri di connessione
     *                 e mappatura topic
     * @throws MqttException se si verificano errori durante l'inizializzazione
     *                       delle connessioni MQTT
     */
    public MQTTBridge(String scuolaId, BridgeConfig config) throws MqttException {
        this.scuolaId = scuolaId;
        this.config = config;
        this.topicDaInoltrare = ConcurrentHashMap.newKeySet();
        this.clientLocale = new MQTTClient("bridge_locale_" + scuolaId);
        this.clientCentrale = new MQTTClient("bridge_centrale_" + scuolaId);

        inizializzaBridge();
    }

    /**
     * Inizializza le sottoscrizioni ai topic su entrambi i broker e
     * configura i callback per l'inoltro dei messaggi.
     *
     * @throws MqttException se si verificano errori durante la sottoscrizione ai
     *                       topic
     */
    private void inizializzaBridge() throws MqttException {
        // Sottoscrizione ai topic locali
        clientLocale.subscribe("#", (topic, messaggio) -> {
            if (deveEssereInoltrato(topic)) {
                inoltraAlCentrale(topic, messaggio);
            }
        });

        // Sottoscrizione ai topic centrali
        clientCentrale.subscribe("#", (topic, messaggio) -> {
            if (deveEssereInoltrato(topic)) {
                inoltraAlLocale(topic, messaggio);
            }
        });
    }

    /**
     * Aggiunge un pattern di topic alla lista dei topic da inoltrare.
     * Supporta wildcards MQTT (+ e #).
     *
     * @param topic pattern del topic da aggiungere alla lista di inoltro
     */
    public void aggiungiTopicDaInoltrare(String topic) {
        topicDaInoltrare.add(topic);
    }

    /**
     * Rimuove un pattern di topic dalla lista dei topic da inoltrare.
     *
     * @param topic pattern del topic da rimuovere dalla lista di inoltro
     */
    public void rimuoviTopicDaInoltrare(String topic) {
        topicDaInoltrare.remove(topic);
    }

    /**
     * Verifica se un topic deve essere inoltrato in base ai pattern configurati.
     * Converte i pattern MQTT in espressioni regolari per il matching.
     *
     * @param topic topic da verificare
     * @return true se il topic corrisponde a uno dei pattern da inoltrare
     */
    private boolean deveEssereInoltrato(String topic) {
        return topicDaInoltrare.stream()
                .anyMatch(pattern -> topic.matches(pattern.replace("+", "[^/]+").replace("#", ".*")));
    }

    /**
     * Inoltra un messaggio dal broker locale al broker centrale,
     * applicando le regole di mappatura dei topic configurate.
     *
     * @param topic     topic originale del messaggio
     * @param messaggio contenuto del messaggio da inoltrare
     */
    private void inoltraAlCentrale(String topic, String messaggio) {
        try {
            String topicCentrale = config.getTopicCentrale(scuolaId, topic);
            clientCentrale.publish(topicCentrale, messaggio);
        } catch (MqttException e) {
            System.err.println("Errore nell'inoltro al broker centrale: " + e.getMessage());
        }
    }

    /**
     * Inoltra un messaggio dal broker centrale al broker locale,
     * applicando le regole di mappatura dei topic configurate.
     *
     * @param topic     topic originale del messaggio
     * @param messaggio contenuto del messaggio da inoltrare
     */
    private void inoltraAlLocale(String topic, String messaggio) {
        try {
            String topicLocale = config.getTopicLocale(scuolaId, topic);
            clientLocale.publish(topicLocale, messaggio);
        } catch (MqttException e) {
            System.err.println("Errore nell'inoltro al broker locale: " + e.getMessage());
        }
    }

    /**
     * Chiude le connessioni MQTT e libera le risorse associate al bridge.
     * Deve essere chiamato quando il bridge non è più necessario.
     */
    public void spegni() {
        clientLocale.disconnect();
        clientCentrale.disconnect();
    }
}

================
File: src/main/java/com/vending/iot/bridge/TopicManager.java
================
package com.vending.iot.bridge;

import java.util.HashSet;
import java.util.Set;

public class TopicManager {
    private final Set<String> topicMacchine;
    private final Set<String> topicManutenzione;
    private final Set<String> topicMonitoraggio;

    public TopicManager() {
        this.topicMacchine = new HashSet<>();
        this.topicManutenzione = new HashSet<>();
        this.topicMonitoraggio = new HashSet<>();
        inizializzaTopicPredefiniti();
    }

    private void inizializzaTopicPredefiniti() {
        // Topic macchine
        topicMacchine.add("macchine/+/stato");
        topicMacchine.add("macchine/+/allarmi");
        topicMacchine.add("macchine/+/manutenzione");

        // Topic manutenzione
        topicManutenzione.add("manutenzione/+/richieste");
        topicManutenzione.add("manutenzione/+/interventi");

        // Topic monitoraggio
        topicMonitoraggio.add("monitoraggio/+/statistiche");
        topicMonitoraggio.add("monitoraggio/+/alert");
    }

    public Set<String> getTopicMacchine() {
        return new HashSet<>(topicMacchine);
    }

    public Set<String> getTopicManutenzione() {
        return new HashSet<>(topicManutenzione);
    }

    public Set<String> getTopicMonitoraggio() {
        return new HashSet<>(topicMonitoraggio);
    }

    public void aggiungiTopicMacchina(String topic) {
        topicMacchine.add(topic);
    }

    public void aggiungiTopicManutenzione(String topic) {
        topicManutenzione.add(topic);
    }

    public void aggiungiTopicMonitoraggio(String topic) {
        topicMonitoraggio.add(topic);
    }
}

================
File: src/main/java/com/vending/iot/machines/GestoreBevande.java
================
package com.vending.iot.machines;

import com.google.gson.Gson;
import com.vending.iot.mqtt.MQTTClient;
import com.vending.Main;
import com.vending.ServiceRegistry;
import com.vending.core.models.Bevanda;
import com.vending.core.models.Cialda;
import com.vending.core.models.QuantitaCialde;
import com.vending.core.models.Transazione;
import com.vending.core.repositories.CialdaRepository;
import com.vending.core.repositories.TransazioneRepository;

import org.eclipse.paho.client.mqttv3.MqttException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;

public class GestoreBevande {

    private final int idMacchina;
    private final Map<Integer, Bevanda> bevande;
    private final AtomicBoolean inErogazione;
    private final MQTTClient mqttClient;
    private final Gson gson;
    private final GestoreCassa gestoreCassa;
    private final GestoreCialde gestoreCialde;
    private static final Logger logger = LoggerFactory.getLogger(Main.class);

    public GestoreBevande(int idMacchina, GestoreCassa gestoreCassa, GestoreCialde gestoreCialde) throws MqttException {
        this.idMacchina = idMacchina;
        this.bevande = new ConcurrentHashMap<>();
        this.inErogazione = new AtomicBoolean(false);
        this.gson = new Gson();
        this.mqttClient = new MQTTClient("bevande_" + idMacchina);
        this.gestoreCassa = gestoreCassa;
        this.gestoreCialde = gestoreCialde;

        inizializzaSottoscrizioni();
    }

    private void inizializzaSottoscrizioni() throws MqttException {
        String baseTopic = "macchine/" + idMacchina + "/bevande/";
        mqttClient.subscribe(baseTopic + "#", (topic, messaggio) -> {
            String azione = topic.substring(baseTopic.length());
            switch (azione) {
                case "richiesta":
                    gestisciRichiestaBevanda(gson.fromJson(messaggio, RichiestaBevanda.class));
                    break;
                case "aggiorna":
                    gestisciAggiornamentoBevanda(gson.fromJson(messaggio, AggiornamentoBevanda.class));
                    break;
            }
        });
    }

    public void aggiungiBevanda(Bevanda bevanda) {
        bevande.put(bevanda.getId(), bevanda);
        publishAggiornamentoBevande();
    }

    private void publishAggiornamentoBevande() {
        try {
            String topic = "macchine/" + idMacchina + "/bevande/lista";

            // Crea una mappa dettagliata con tutte le informazioni delle bevande
            Map<String, Object> dettagliAggiornamento = new HashMap<>();
            List<Map<String, Object>> listaBevande = new ArrayList<>();

            for (Bevanda bevanda : bevande.values()) {
                Map<String, Object> infoBevanda = new HashMap<>();
                try {
                    infoBevanda.put("id", bevanda.getId());
                    infoBevanda.put("nome", bevanda.getNome());
                    infoBevanda.put("prezzo", bevanda.getPrezzo());
                    infoBevanda.put("disponibile", verificaDisponibilitaBevanda(bevanda));

                    // Aggiunge informazioni sulle cialde necessarie
                    List<Map<String, Object>> cialde = new ArrayList<>();
                    for (Cialda cialda : bevanda.getCialde()) {
                        Map<String, Object> infoCialda = new HashMap<>();
                        infoCialda.put("id", cialda.getId());
                        infoCialda.put("tipo", cialda.getTipoCialda());
                        infoCialda.put("quantitaDisponibile", getQuantitaCialdaDisponibile(cialda.getId()));
                        cialde.add(infoCialda);
                    }
                    infoBevanda.put("cialde", cialde);

                    listaBevande.add(infoBevanda);
                } catch (NullPointerException e) {
                    System.err.println("Errore nell'elaborazione della bevanda ID "
                            + bevanda.getId() + ": " + e.getMessage());
                    // Continua con la prossima bevanda
                    continue;
                }
            }

            dettagliAggiornamento.put("bevande", listaBevande);
            dettagliAggiornamento.put("timestamp", System.currentTimeMillis());
            dettagliAggiornamento.put("totaleDisponibili",
                    listaBevande.stream().filter(b -> (boolean) b.get("disponibile")).count());

            // Verifica se ci sono bevande disponibili
            boolean almeno1BevandaDisponibile = listaBevande.stream()
                    .anyMatch(b -> (boolean) b.get("disponibile"));

            if (!almeno1BevandaDisponibile) {
                // Pubblica un avviso se non ci sono bevande disponibili
                pubblicaAvvisoNessunaBevandaDisponibile();
            }

            // Pubblica l'aggiornamento
            mqttClient.publish(topic, gson.toJson(dettagliAggiornamento));

            // Log dell'aggiornamento
            System.out.println("Aggiornamento bevande pubblicato con successo: "
                    + gson.toJson(dettagliAggiornamento));

        } catch (MqttException e) {
            System.err.println("Errore durante la pubblicazione dell'aggiornamento bevande: "
                    + e.getMessage());
        } catch (Exception e) {
            System.err.println("Errore imprevisto durante l'aggiornamento bevande: "
                    + e.getMessage());
            e.printStackTrace();
        }
    }

    private boolean verificaDisponibilitaBevanda(Bevanda bevanda) {
        try {
            if (bevanda == null) {
                return false;
            }

            return bevanda.getCialde().stream()
                    .allMatch(cialda -> getQuantitaCialdaDisponibile(cialda.getId()) > 0);
        } catch (Exception e) {
            System.err.println("Errore verifica disponibilita'� bevanda ID "
                    + bevanda.getId() + ": " + e.getMessage());
            return false;
        }
    }

    private int getQuantitaCialdaDisponibile(int idCialda) {
        try {
            CialdaRepository cialdaRepository = new CialdaRepository();
            Optional<QuantitaCialde> cialda = cialdaRepository.getQuantitaDisponibileByMacchina(idCialda, idMacchina);
            return cialda != null ? cialda.get().getQuantita() : 0;
        } catch (Exception e) {
            return 0;
        }
    }

    private void pubblicaAvvisoNessunaBevandaDisponibile() {
        try {
            String topicAvviso = "macchine/" + idMacchina + "/bevande/avviso";
            Map<String, Object> avviso = Map.of(
                    "tipo", "NESSUNA_BEVANDA_DISPONIBILE",
                    "messaggio", "Tutte le bevande sono momentaneamente non disponibili",
                    "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topicAvviso, gson.toJson(avviso));
        } catch (MqttException e) {
            System.err.println("Errore pubblicazione avviso bevande non disponibili: "
                    + e.getMessage());
        }
    }

    private void gestisciRichiestaBevanda(RichiestaBevanda richiesta) {
        if (!inErogazione.compareAndSet(false, true)) {
            pubblicaErrore("Macchina occupata");
            return;
        }

        try {
            Bevanda bevanda = bevande.get(richiesta.idBevanda);
            if (bevanda == null) {
                pubblicaErrore("Bevanda non disponibile");
                return;
            }

            // Verifica disponibilita' cialde
            if (!gestoreCialde.verificaDisponibilitaCialde(bevanda.getCialde())) {
                pubblicaErrore("Cialde non sufficienti");
                return;
            }

            // Verifica pagamento
            if (gestoreCassa.processaPagamento(bevanda.getPrezzo())) {
                // Simulazione erogazione
                pubblicaStato("preparazione");
                Thread.sleep(5000); // Simula tempo di preparazione

                // Consuma le cialde
                gestoreCialde.consumaCialde(bevanda.getCialde());

                pubblicaStato("completata");
                registraErogazione(bevanda);
                // Aggiorna il repository delle transazioni
                TransazioneRepository transazioneRepo = ServiceRegistry.get(TransazioneRepository.class);
                Optional<Transazione> transazione = transazioneRepo.findById(richiesta.transazioneId);
                if (transazione.isPresent()) {
                    Transazione t = transazione.get();
                    transazioneRepo.update(t);
                }
            } else {
                pubblicaErrore("Credito insufficiente");
            }
        } catch (Exception e) {
            pubblicaErrore("Errore durante l'erogazione: " + e.getMessage());
        } finally {
            inErogazione.set(false);
        }
    }

    private void gestisciAggiornamentoBevanda(AggiornamentoBevanda aggiornamento) {
        Bevanda bevanda = bevande.get(aggiornamento.idBevanda);
        if (bevanda != null) {
            bevanda.setPrezzo(aggiornamento.nuovoPrezzo);
            pubblicaAggiornamentoBevande();
        }
    }

    private void pubblicaStato(String stato) {
        try {
            String topic = "macchine/" + idMacchina + "/bevande/stato";
            Map<String, Object> statoErogazione = Map.of(
                    "stato", stato,
                    "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topic, gson.toJson(statoErogazione));
        } catch (MqttException e) {
            System.err.println("Errore pubblicazione stato: " + e.getMessage());
        }
    }

    private void pubblicaAggiornamentoBevande() {
        try {
            String topic = "macchine/" + idMacchina + "/bevande/lista";
            mqttClient.publish(topic, gson.toJson(bevande));
        } catch (MqttException e) {
            System.err.println("Errore pubblicazione bevande: " + e.getMessage());
        }
    }

    private void pubblicaErrore(String messaggio) {
        try {
            String topic = "macchine/" + idMacchina + "/bevande/errore";
            Map<String, Object> errore = Map.of(
                    "messaggio", messaggio,
                    "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topic, gson.toJson(errore));
        } catch (MqttException e) {
            System.err.println("Errore pubblicazione errore: " + e.getMessage());
        }
    }

    private void registraErogazione(Bevanda bevanda) {
        TransazioneRepository transazioneRepo = ServiceRegistry.get(TransazioneRepository.class);
        Transazione transazione = new Transazione();

        try {
            String topic = "macchine/" + idMacchina + "/bevande/erogazione";
            int idT = transazioneRepo.getLastTransactionId() + 1;
            transazione.setId(idT);
            transazione.setMacchinaId(idMacchina);
            transazione.setBevandaId(bevanda.getId());
            transazione.setImporto(bevanda.getPrezzo());
            transazione.setDataOra(LocalDateTime.now());
            Map<String, Object> erogazione = Map.of(
                    "bevandaId", bevanda.getId(),
                    "nome", bevanda.getNome(),
                    "prezzo", bevanda.getPrezzo(),
                    "timestamp", System.currentTimeMillis(),
                    "transazioneId", transazione.getId()
            );
            mqttClient.publish(topic, gson.toJson(erogazione));
        } catch (MqttException e) {
            System.err.println("Errore registrazione erogazione: " + e.getMessage());
        }
    }

    public List<Bevanda> getBevandeMacchina(int macchinaId) {
        List<Bevanda> bevandeDisponibili = new ArrayList<>();

        // Itera su tutte le bevande gestite da questo gestore
        for (Bevanda bevanda : bevande.values()) {
            // Verifica se la bevanda è disponibile per questa macchina
            if (verificaDisponibilitaBevanda(bevanda)) {
                bevandeDisponibili.add(bevanda);
            }
        }

        return bevandeDisponibili;
    }

    public Map<String, Object> ottieniStato() {
        List<Map<String, Object>> listaBevande = new ArrayList<>();

        for (Bevanda bevanda : bevande.values()) {
            Map<String, Object> infoBevanda = new HashMap<>();
            infoBevanda.put("id", bevanda.getId());
            infoBevanda.put("nome", bevanda.getNome());
            infoBevanda.put("prezzo", bevanda.getPrezzo());
            infoBevanda.put("disponibile", verificaDisponibilitaBevanda(bevanda));
            listaBevande.add(infoBevanda);
        }

        Map<String, Object> stato = new HashMap<>();
        stato.put("bevande", listaBevande);
        stato.put("inErogazione", inErogazione.get());

        return stato;
    }

    private static class RichiestaBevanda {
        public int idBevanda;
        public int transazioneId;
        public double importo;
    }

    private static class AggiornamentoBevanda {

        public int idBevanda;
        public double nuovoPrezzo;
    }

    public void spegni() {
        mqttClient.disconnect();
    }
}

================
File: src/main/java/com/vending/iot/machines/GestoreCassa.java
================
package com.vending.iot.machines;

import com.google.gson.Gson;
import com.vending.ServiceRegistry;
import com.vending.core.models.Ricavo;
import com.vending.core.repositories.RicavoRepository;
import com.vending.iot.mqtt.MQTTClient;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.concurrent.atomic.AtomicReference;
import java.time.LocalDateTime;
import java.util.Map;

/**
 * Classe che rappresenta il gestore della cassa di una macchina distributrice.
 * Gestisce l'inserimento di monete, lo svuotamento della cassa e la
 * restituzione del credito.
 *
 * Un'operazione atomica è un'operazione che viene eseguita in un singolo passo
 * indivisibile. Questo significa che, in un contesto multi-thread, nessun
 * thread può osservare uno stato intermedio durante l'esecuzione
 * dell'operazione.
 */
public class GestoreCassa {

    private static final Logger logger = LoggerFactory.getLogger(GestoreCassa.class);
    private final int idMacchina;
    private final AtomicReference<Double> creditoAttuale;
    private final AtomicReference<Double> cassaAttuale;
    private final double cassaMassima;
    private final MQTTClient mqttClient;
    private final Gson gson;
    private static final double SOGLIA_AVVISO_CASSA_PIENA = 0.9; // 90%

    /**
     * Costruttore del gestore cassa.
     *
     * @param idMacchina ID della macchina distributrice
     * @param cassaMassima capacità massima della cassa
     * @throws MqttException se si verificano errori nella connessione MQTT
     */
    public GestoreCassa(int idMacchina, double cassaMassima) throws MqttException {
        if (cassaMassima <= 0) {
            throw new IllegalArgumentException("La capacità massima della cassa deve essere positiva");
        }

        this.idMacchina = idMacchina;
        this.cassaMassima = cassaMassima;
        this.creditoAttuale = new AtomicReference<>(0.0);
        this.cassaAttuale = new AtomicReference<>(0.0);
        this.gson = new Gson();
        this.mqttClient = new MQTTClient("cassa_" + idMacchina);

        logger.info("Inizializzazione GestoreCassa per macchina {}", idMacchina);
        inizializzaSottoscrizioni();
    }

    /**
     * Imposta il saldo corrente della cassa. Viene utilizzato principalmente
     * per inizializzare o sincronizzare lo stato della cassa.
     *
     * @param nuovoSaldo il nuovo saldo da impostare
     * @throws IllegalArgumentException se il saldo è negativo o supera la
     * capacità massima
     */
    public void impostaSaldoCassa(double nuovoSaldo) {
        if (nuovoSaldo < 0) {
            logger.error("Tentativo di impostare un saldo negativo: {}", nuovoSaldo);
            throw new IllegalArgumentException("Il saldo della cassa non può essere negativo");
        }
        if (nuovoSaldo > cassaMassima) {
            logger.error("Tentativo di impostare un saldo superiore alla capacità massima: {} > {}",
                    nuovoSaldo, cassaMassima);
            throw new IllegalArgumentException("Il saldo supera la capacità massima della cassa");
        }

        cassaAttuale.set(nuovoSaldo);
        logger.info("Saldo cassa impostato a {} per la macchina {}", nuovoSaldo, idMacchina);
        pubblicaStatoCassa();

        // Verifica se necessario pubblicare l'avviso di cassa quasi piena
        if ((nuovoSaldo / cassaMassima) > SOGLIA_AVVISO_CASSA_PIENA) {
            pubblicaAvvisoCassaPiena();
        }
    }

    /**
     * Restituisce lo stato attuale della cassa, inclusi credito, saldo e
     * percentuale di occupazione.
     *
     * @return una mappa contenente: creditoAttuale, cassaAttuale, cassaMassima
     * e percentualeOccupazione
     */
    public Map<String, Object> ottieniStato() {
        double saldoAttuale = cassaAttuale.get();
        return Map.of(
                "creditoAttuale", creditoAttuale.get(),
                "cassaAttuale", saldoAttuale,
                "cassaMassima", cassaMassima,
                "percentualeOccupazione", (saldoAttuale / cassaMassima) * 100
        );
    }

    /**
     * Inizializza le sottoscrizioni MQTT per gestire le operazioni della cassa.
     * Gestisce le operazioni di inserimento monete, svuotamento cassa e
     * restituzione credito.
     *
     * @throws MqttException se si verificano errori nella sottoscrizione ai
     * topic MQTT
     */
    private void inizializzaSottoscrizioni() throws MqttException {
        String baseTopic = "macchine/" + idMacchina + "/cassa/";
        mqttClient.subscribe(baseTopic + "#", (topic, messaggio) -> {
            logger.debug("Ricevuto messaggio sul topic {}: {}", topic, messaggio);
            String azione = topic.substring(baseTopic.length());
            double importo = gson.fromJson(messaggio, double.class);
            try {
                switch (azione) {
                    case "inserimento":
                        gestisciInserimentoMoneta(importo);
                        break;
                    case "svuotamento":
                        gestisciSvuotamentoCassa();
                        break;
                    case "cancella":
                        gestisciRestituzioneCredito();
                        break;
                    default:
                        logger.warn("Azione non riconosciuta: {}", azione);
                }
            } catch (Exception e) {
                logger.error("Errore durante l'elaborazione del messaggio", e);
                pubblicaErrore("Errore durante l'elaborazione dell'operazione: " + e.getMessage());
            }
        });
        logger.info("Sottoscrizioni inizializzate per la macchina {}", idMacchina);
    }

    /**
     * Gestisce l'inserimento di una moneta nella cassa. Verifica se l'importo
     * può essere accettato e aggiorna il credito attuale.
     *
     * @param operazione l'operazione di inserimento moneta contenente l'importo
     */
    public boolean gestisciInserimentoMoneta(double importo) {
        logger.debug("Gestione inserimento moneta: {}", importo);
        if (importo <= 0) {
            pubblicaErrore("L'importo deve essere positivo");
            return false;
        }

        if (puoAccettareImporto(importo)) {
            creditoAttuale.updateAndGet(credito -> credito + importo);
            logger.info("Credito aggiornato a {} per la macchina {}", creditoAttuale.get(), idMacchina);
            pubblicaStatoCredito();
            return true;
        } else {
            logger.warn("Impossibile accettare l'importo {} - cassa piena", importo);
            pubblicaErrore("Impossibile accettare l'importo - cassa piena");
            return false;
        }
    }

    /**
     * Gestisce l'operazione di svuotamento della cassa. Azzera il saldo attuale
     * e pubblica la conferma dell'operazione.
     */
    public void gestisciSvuotamentoCassa() {
        double importoSvuotato = cassaAttuale.getAndSet(0.0);
        logger.info("Svuotamento cassa effettuato: {} per la macchina {}", importoSvuotato, idMacchina);
        // Registra il ricavo
        try {
            RicavoRepository ricavoRepo = ServiceRegistry.get(RicavoRepository.class);
            Ricavo ricavo = new Ricavo(idMacchina, importoSvuotato);
            ricavo.setDataOra(LocalDateTime.now());
            ricavoRepo.save(ricavo);

            // Richiedi manutenzione per conferma svuotamento
            GestoreManutenzione gestoreManutenzione = new GestoreManutenzione(idMacchina);
            gestoreManutenzione.richiestaSvuotamentoCassa(idMacchina, importoSvuotato);

        } catch (Exception e) {
            logger.error("Errore durante la registrazione del ricavo per svuotamento cassa: {}", e.getMessage());
        }
        pubblicaConfermaSvuotamento(importoSvuotato);
        pubblicaStatoCassa();
    }

    /**
     * Gestisce la restituzione del credito all'utente. Azzera il credito
     * attuale e pubblica la conferma dell'operazione.
     */
    public void gestisciRestituzioneCredito() {
        double importoRestituito = creditoAttuale.getAndSet(0.0);
        logger.info("Restituzione credito: {} per la macchina {}", importoRestituito, idMacchina);
        pubblicaRestituzione(importoRestituito);
        pubblicaStatoCredito();
    }

    /**
     * Verifica se la cassa può accettare un determinato importo. Controlla che
     * l'importo non faccia superare la capacità massima della cassa.
     *
     * @param importo l'importo da verificare
     * @return true se l'importo può essere accettato, false altrimenti
     */
    public boolean puoAccettareImporto(double importo) {
        return (cassaAttuale.get() + creditoAttuale.get() + importo) <= cassaMassima;
    }

    /**
     * Pubblica lo stato attuale della cassa sul topic MQTT appropriato. Include
     * informazioni su saldo attuale, capacità massima e percentuale di
     * occupazione.
     */
    private void pubblicaStatoCassa() {
        try {
            String topic = "macchine/" + idMacchina + "/cassa/stato";
            Map<String, Object> stato = Map.of(
                    "cassaAttuale", cassaAttuale.get(),
                    "cassaMassima", cassaMassima,
                    "percentualeOccupazione", (cassaAttuale.get() / cassaMassima) * 100,
                    "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topic, gson.toJson(stato));
        } catch (MqttException e) {
            logger.error("Errore pubblicazione stato cassa", e);
        }
    }

    /**
     * Pubblica lo stato del credito attuale sul topic MQTT appropriato.
     */
    private void pubblicaStatoCredito() {
        try {
            String topic = "macchine/" + idMacchina + "/cassa/credito";
            Map<String, Object> stato = Map.of(
                    "creditoAttuale", creditoAttuale.get(),
                    "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topic, gson.toJson(stato));
        } catch (MqttException e) {
            logger.error("Errore pubblicazione stato credito", e);
        }
    }

    /**
     * Pubblica un avviso quando la cassa supera la soglia di riempimento.
     * L'avviso viene inviato quando la cassa supera il 90% della sua capacità.
     */
    private void pubblicaAvvisoCassaPiena() {
        try {
            String topicAvviso = "macchine/" + idMacchina + "/cassa/avviso";
            Map<String, Object> avviso = Map.of(
                    "tipo", "CASSA_QUASI_PIENA",
                    "messaggio", "La cassa ha superato il 90% della capacità",
                    "percentualeOccupazione", (cassaAttuale.get() / cassaMassima) * 100,
                    "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topicAvviso, gson.toJson(avviso));
            logger.warn("Avviso cassa quasi piena pubblicato per la macchina {}", idMacchina);
        } catch (MqttException e) {
            logger.error("Errore pubblicazione avviso cassa piena", e);
        }
    }

    /**
     * Pubblica la conferma di svuotamento della cassa con l'importo svuotato.
     *
     * @param importo l'importo che è stato prelevato dalla cassa
     */
    private void pubblicaConfermaSvuotamento(double importo) {
        try {
            String topic = "macchine/" + idMacchina + "/cassa/svuotamento/conferma";
            Map<String, Object> conferma = Map.of(
                    "importo", importo,
                    "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topic, gson.toJson(conferma));
        } catch (MqttException e) {
            logger.error("Errore pubblicazione conferma svuotamento", e);
        }
    }

    /**
     * Pubblica la conferma di restituzione del credito all'utente.
     *
     * @param importo l'importo che è stato restituito all'utente
     */
    private void pubblicaRestituzione(double importo) {
        try {
            String topic = "macchine/" + idMacchina + "/cassa/resto/conferma";
            Map<String, Object> resto = Map.of(
                    "importo", importo,
                    "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topic, gson.toJson(resto));
        } catch (MqttException e) {
            logger.error("Errore pubblicazione restituzione", e);
        }
    }

    /**
     * Pubblica un messaggio di errore sul topic MQTT appropriato.
     *
     * @param messaggio il messaggio di errore da pubblicare
     */
    private void pubblicaErrore(String messaggio) {
        try {
            String topic = "macchine/" + idMacchina + "/cassa/errore";
            Map<String, Object> errore = Map.of(
                    "messaggio", messaggio,
                    "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topic, gson.toJson(errore));
            logger.error("Errore cassa: {}", messaggio);
        } catch (MqttException e) {
            logger.error("Errore pubblicazione errore", e);
        }
    }

    /**
     * Processa un pagamento, verificando la disponibilità del credito e
     * aggiornando i saldi. Se il pagamento va a buon fine, aggiorna sia il
     * credito che la cassa e pubblica gli aggiornamenti.
     *
     * @param prezzo l'importo da addebitare
     * @return true se il pagamento è stato processato con successo, false
     * altrimenti
     */
    public boolean processaPagamento(double prezzo) {
        if (prezzo <= 0) {
            logger.error("Tentativo di processare un pagamento con prezzo non valido: {}", prezzo);
            return false;
        }

        if (creditoAttuale.get() >= prezzo) {
            creditoAttuale.updateAndGet(credito -> credito - prezzo);
            cassaAttuale.updateAndGet(cassa -> cassa + prezzo);

            try {
                pubblicaStatoCredito();
                pubblicaStatoCassa();

                if ((cassaAttuale.get() / cassaMassima) > SOGLIA_AVVISO_CASSA_PIENA) {
                    pubblicaAvvisoCassaPiena();
                }

                logger.info("Pagamento processato con successo: {} per la macchina {}", prezzo, idMacchina);
                return true;
            } catch (Exception e) {
                logger.error("Errore durante la pubblicazione degli aggiornamenti del pagamento", e);
                return true; // Il pagamento è comunque avvenuto con successo
            }
        }

        logger.warn("Credito insufficiente per il pagamento: {} < {}", creditoAttuale.get(), prezzo);
        return false;
    }

    // /**
    //  * Classe interna che rappresenta un'operazione di inserimento moneta.
    //  */
    // static class OperazioneMoneta {
    //         public double importo;
    // 		public double getImporto() {
    // 			return importo;
    // 		}
    // 		public void setImporto(double importo) {
    // 			this.importo = importo;
    // 		}
    //     }
    /**
     * Spegne il gestore cassa, disconnettendo il client MQTT. Da chiamare
     * quando la macchina viene spenta o riavviata.
     */
    public void spegni() {
        try {
            mqttClient.disconnect();
            logger.info("GestoreCassa spento per la macchina {}", idMacchina);
        } catch (Exception e) {
            logger.error("Errore durante lo spegnimento del GestoreCassa", e);
        }
    }
}

================
File: src/main/java/com/vending/iot/machines/GestoreCialde.java
================
package com.vending.iot.machines;

import com.google.gson.Gson;
import com.vending.iot.mqtt.MQTTClient;
import com.vending.core.models.Cialda;
import org.eclipse.paho.client.mqttv3.MqttException;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

public class GestoreCialde {
    private final int idMacchina;
    private final Map<Integer, InfoCialda> cialde;
    private final MQTTClient mqttClient;
    private final Gson gson;
    private static final double SOGLIA_RICARICA = 0.2; // 20%

    public GestoreCialde(int idMacchina) throws MqttException {
        this.idMacchina = idMacchina;
        this.cialde = new ConcurrentHashMap<>();
        this.gson = new Gson();
        this.mqttClient = new MQTTClient("cialde_" + idMacchina);
        
        inizializzaSottoscrizioni();
    }

    private void inizializzaSottoscrizioni() throws MqttException {
        String baseTopic = "macchine/" + idMacchina + "/cialde/";
        mqttClient.subscribe(baseTopic + "#", (topic, messaggio) -> {
            String azione = topic.substring(baseTopic.length());
            switch (azione) {
                case "ricarica":
                    gestisciRicaricaCialde(gson.fromJson(messaggio, RichiestaCialde.class));
                    break;
                case "verifica":
                    verificaStatoCialde();
                    break;
            }
        });
    }

    public void inizializzaCialda(int idCialda, int quantita, int quantitaMassima) {
        cialde.put(idCialda, new InfoCialda(quantita, quantitaMassima));
        pubblicaStatoCialde();
    }

    public boolean verificaDisponibilitaCialde(List<Cialda> cialdeNecessarie) {
        return cialdeNecessarie.stream()
                .allMatch(cialda -> {
                    InfoCialda info = cialde.get(cialda.getId());
                    return info != null && info.quantitaAttuale > 0;
                });
    }

    public void consumaCialde(List<Cialda> cialdeUsate) {
        cialdeUsate.forEach(cialda -> {
            InfoCialda info = cialde.get(cialda.getId());
            if (info != null) {
                info.decrementaQuantita();
                if (info.necessitaRicarica()) {
                    pubblicaAvvisoRicarica(cialda.getId());
                }
            }
        });
        pubblicaStatoCialde();
    }

    public void gestisciRicaricaCialde(RichiestaCialde richiesta) {
        InfoCialda info = cialde.get(richiesta.idCialda);
        if (info != null) {
            info.ricarica();
            pubblicaStatoCialde();
            pubblicaConfermaRicarica(richiesta.idCialda);
        }
    }

    public void verificaStatoCialde() {
        cialde.forEach((id, info) -> {
            if (info.necessitaRicarica()) {
                pubblicaAvvisoRicarica(id);
            }
        });
        pubblicaStatoCialde();
    }

    

    private void pubblicaStatoCialde() {
        try {
            String topic = "macchine/" + idMacchina + "/cialde/stato";
            Map<String, Object> stato = new ConcurrentHashMap<>();
            cialde.forEach((id, info) -> stato.put(String.valueOf(id), info.toMap()));
            mqttClient.publish(topic, gson.toJson(stato));
        } catch (MqttException e) {
            System.err.println("Errore pubblicazione stato cialde: " + e.getMessage());
        }
    }

    private void pubblicaAvvisoRicarica(int idCialda) {
        try {
            String topic = "macchine/" + idMacchina + "/cialde/avviso";
            Map<String, Object> avviso = Map.of(
                "idCialda", idCialda,
                "tipo", "ricarica_necessaria",
                "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topic, gson.toJson(avviso));
        } catch (MqttException e) {
            System.err.println("Errore pubblicazione avviso ricarica: " + e.getMessage());
        }
    }

    private void pubblicaConfermaRicarica(int idCialda) {
        try {
            String topic = "macchine/" + idMacchina + "/cialde/ricarica/conferma";
            Map<String, Object> conferma = Map.of(
                "idCialda", idCialda,
                "timestamp", System.currentTimeMillis()
            );
            mqttClient.publish(topic, gson.toJson(conferma));
        } catch (MqttException e) {
            System.err.println("Errore pubblicazione conferma ricarica: " + e.getMessage());
        }
    }

    private static class InfoCialda {
        private int quantitaAttuale;
        private final int quantitaMassima;

        public InfoCialda(int quantitaAttuale, int quantitaMassima) {
            this.quantitaAttuale = quantitaAttuale;
            this.quantitaMassima = quantitaMassima;
        }

        public void decrementaQuantita() {
            if (quantitaAttuale > 0) quantitaAttuale--;
        }

        public void ricarica() {
            quantitaAttuale = quantitaMassima;
        }

        public boolean necessitaRicarica() {
            return quantitaAttuale < (quantitaMassima * SOGLIA_RICARICA);
        }

        public Map<String, Object> toMap() {
            return Map.of(
                "quantitaAttuale", quantitaAttuale,
                "quantitaMassima", quantitaMassima,
                "percentuale", (double) quantitaAttuale / quantitaMassima * 100,
                "necessitaRicarica", necessitaRicarica()
            );
        }
    }

    public static class RichiestaCialde {
        public int idCialda;
    }

    public Map<String, Object> ottieniStato() {
        Map<String, Object> statoCialde = new HashMap<>();
        cialde.forEach((id, info) -> 
            statoCialde.put(String.valueOf(id), Map.of(
                "quantitaAttuale", info.quantitaAttuale,
                "quantitaMassima", info.quantitaMassima,
                "necessitaRicarica", info.quantitaAttuale < info.quantitaMassima * 0.2
            ))
        );
        return statoCialde;
        }

    public void spegni() {
        mqttClient.disconnect();
    }
}

================
File: src/main/java/com/vending/iot/machines/GestoreManutenzione.java
================
package com.vending.iot.machines;

import com.google.gson.Gson;
import com.vending.Main;
import com.vending.ServiceRegistry;
import com.vending.core.models.Macchina;
import com.vending.core.models.Manutenzione;
import com.vending.core.models.Ricavo;
import com.vending.core.repositories.MacchinaRepository;
import com.vending.core.repositories.ManutenzioneRepository;
import com.vending.core.repositories.RicavoRepository;
import com.vending.iot.mqtt.MQTTClient;

import org.eclipse.paho.client.mqttv3.MqttException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

public class GestoreManutenzione {

    private static final Logger logger = LoggerFactory.getLogger(Main.class);
    private final int idMacchina;
    private final MQTTClient mqttClient;
    private final Map<String, String> problemiAttivi; // Mappa per tenere traccia dei problemi attivi
    private final Gson gson;
    private final ManutenzioneRepository manutenzioneRepo;

    public GestoreManutenzione(int idMacchina) throws MqttException {
        this.idMacchina = idMacchina;
        this.problemiAttivi = new HashMap<>();
        this.gson = new Gson();
        this.mqttClient = new MQTTClient("manutenzione_" + idMacchina);
        this.manutenzioneRepo = ServiceRegistry.get(ManutenzioneRepository.class);
        inizializzaSottoscrizioni();
    }

    private void inizializzaSottoscrizioni() throws MqttException {
        String baseTopic = "macchine/" + idMacchina + "/manutenzione/";
        mqttClient.subscribe(baseTopic + "#", (topic, messaggio) -> {
            String azione = topic.substring(baseTopic.length());
            switch (azione) {
                case "segnalazione":
                    gestisciSegnalazione(gson.fromJson(messaggio, SegnalazioneProblema.class));
                    break;
                case "risoluzione":
                    gestisciRisoluzione(gson.fromJson(messaggio, RisoluzioneProblema.class));
                    break;
                case "verifica":
                    verificaStato();
                    break;
            }
        });
    }

    public void segnalaProblema(String tipo, String descrizione, Map<String, Object> dettagliAggiuntivi) {
        try {
            SegnalazioneProblema segnalazione = new SegnalazioneProblema();
            segnalazione.tipo = tipo;
            segnalazione.descrizione = descrizione;
            segnalazione.dettagli = dettagliAggiuntivi;

            String topic = "macchine/" + idMacchina + "/manutenzione/segnalazione";
            mqttClient.publish(topic, gson.toJson(segnalazione));

            String descProblema = "Problema " + segnalazione.tipo + ": " + segnalazione.descrizione;
            problemiAttivi.put(String.valueOf(segnalazione.timestamp), descProblema);
            pubblicaStatoManutenzione();

            // Registra la manutenzione nel database
            registraManutenzione(tipo, descrizione, dettagliAggiuntivi);

        } catch (MqttException e) {
            logger.error("Errore durante la segnalazione del problema: {}", e.getMessage());
        }
    }

    private void registraManutenzione(String tipoIntervento, String descrizione, Map<String, Object> dettagli) {
        try {
            Manutenzione manutenzione = new Manutenzione();
            manutenzione.setMacchinaId(idMacchina);
            manutenzione.setTipoIntervento(tipoIntervento);
            manutenzione.setDescrizione(descrizione);
            manutenzione.setDataRichiesta(LocalDateTime.now());
            manutenzione.setStato("IN_ATTESA");
            manutenzione.setUrgenza((String) dettagli.getOrDefault("urgenza", "MEDIA"));
            manutenzione.setNote((String) dettagli.get("note"));

            manutenzioneRepo.save(manutenzione);
            logger.info("Registrata nuova manutenzione per la macchina {}: {}", idMacchina, tipoIntervento);

        } catch (Exception e) {
            logger.error("Errore durante la registrazione della manutenzione: {}", e.getMessage());
        }
    }

    public void risolviProblema(String idProblema, String descrizioneRisoluzione, String tecnico) {
        try {
            RisoluzioneProblema risoluzione = new RisoluzioneProblema();
            risoluzione.idProblema = idProblema;
            risoluzione.descrizioneRisoluzione = descrizioneRisoluzione;
            risoluzione.tecnico = tecnico;
            risoluzione.timestampRisoluzione = System.currentTimeMillis();

            String topic = "macchine/" + idMacchina + "/manutenzione/risoluzione";
            mqttClient.publish(topic, gson.toJson(risoluzione));

            problemiAttivi.remove(idProblema);
            pubblicaStatoManutenzione();

            // Aggiorna la manutenzione nel database
            aggiornaManutenzione(idProblema, descrizioneRisoluzione, tecnico);

        } catch (MqttException e) {
            logger.error("Errore durante la risoluzione del problema: {}", e.getMessage());
        }
    }
    
    private void aggiornaManutenzione(String idProblema, String descrizioneRisoluzione, String tecnico) {
        try {
            // Trova la manutenzione per ID
            Optional<Manutenzione> optionalManutenzione = manutenzioneRepo.findById(Integer.parseInt(idProblema));

            // Se la manutenzione è presente, aggiornala
            if (optionalManutenzione.isPresent()) {
                Manutenzione manutenzione = optionalManutenzione.get(); // Estrai l'oggetto Manutenzione dall'Optional
                manutenzione.setStato("COMPLETATA");
                manutenzione.setDataCompletamento(LocalDateTime.now());
                manutenzione.setNote(descrizioneRisoluzione);
                manutenzione.setTecnicoId(Integer.parseInt(tecnico)); // Supponendo che tecnico sia l'ID del tecnico

                // Aggiorna la manutenzione nel repository
                manutenzioneRepo.update(manutenzione);
                logger.info("Manutenzione {} completata dal tecnico {}", idProblema, tecnico);
            } else {
                logger.warn("Manutenzione con ID {} non trovata", idProblema);
            }
        } catch (Exception e) {
            logger.error("Errore durante l'aggiornamento della manutenzione: {}", e.getMessage());
        }
    }
    private void gestisciSegnalazione(SegnalazioneProblema segnalazione) {
        problemiAttivi.put(String.valueOf(segnalazione.timestamp), segnalazione.descrizione);
        pubblicaStatoManutenzione();
    }

    private void gestisciRisoluzione(RisoluzioneProblema risoluzione) {
        problemiAttivi.remove(risoluzione.idProblema);
        pubblicaStatoManutenzione();
    }

    public Map<String, Object> getStatoManutenzione() {
        return Map.of(
                "problemiAttivi", problemiAttivi,
                "ultimoControllo", System.currentTimeMillis(),
                "richiedeIntervento", !problemiAttivi.isEmpty(),
                "numeroProblemi", problemiAttivi.size()
        );
    }

    private void pubblicaStatoManutenzione() {
        try {
            String topic = "macchine/" + idMacchina + "/manutenzione/stato";
            Map<String, Object> stato = getStatoManutenzione();
            mqttClient.publish(topic, gson.toJson(stato));

            if ((boolean) stato.get("richiedeIntervento")) {
                String topicAvviso = "macchine/" + idMacchina + "/manutenzione/avviso";
                Map<String, Object> avviso = Map.of(
                        "tipo", "RICHIESTA_INTERVENTO",
                        "numeroProblemi", stato.get("numeroProblemi"),
                        "ultimoControllo", stato.get("ultimoControllo"),
                        "timestamp", System.currentTimeMillis()
                );
                mqttClient.publish(topicAvviso, gson.toJson(avviso));
            }
        } catch (MqttException e) {
            logger.error("Errore durante la pubblicazione dello stato: {}", e.getMessage());
        }
    }

    public void verificaStato() {
        boolean interventoUrgente = !problemiAttivi.isEmpty();

        if (interventoUrgente) {
            try {
                String topic = "macchine/" + idMacchina + "/manutenzione/urgente";
                Map<String, Object> avviso = Map.of(
                        "tipo", "INTERVENTO_URGENTE",
                        "timestamp", System.currentTimeMillis(),
                        "problemi", problemiAttivi
                );
                mqttClient.publish(topic, gson.toJson(avviso));
            } catch (MqttException e) {
                logger.error("Errore durante la pubblicazione dell'avviso urgente: {}", e.getMessage());
            }
        }
    }

    public Map<String, Object> ottieniStato() {
        return Map.of(
                "problemiAttivi", problemiAttivi,
                "ultimoControllo", System.currentTimeMillis(),
                "richiedeIntervento", !problemiAttivi.isEmpty(),
                "numeroProblemi", problemiAttivi.size()
        );
    }

    public void richiestaManutenzioneCialde(int macchinaId, String messaggio) {
        try {
            Map<String, Object> dettagli = Map.of(
                    "tipoIntervento", "RIFORNIMENTO_CIALDE",
                    "urgenza", "MEDIA",
                    "stato", "IN_ATTESA"
            );

            segnalaProblema("CIALDE_ESAURITE", messaggio, dettagli);

            // Aggiorna stato macchina a "In manutenzione"
            MacchinaRepository macchinaRepo = ServiceRegistry.get(MacchinaRepository.class);
            Macchina macchina = macchinaRepo.findById(macchinaId);
            if (macchina != null) {
                macchina.setStatoId(2); // 2 = In manutenzione
                macchinaRepo.update(macchina);
            }

        } catch (Exception e) {
            logger.error("Errore nella richiesta manutenzione cialde: {}", e.getMessage());
        }
    }

    public void richiestaSvuotamentoCassa(int macchinaId, double importo) {
        try {
            Map<String, Object> dettagli = Map.of(
                    "tipoIntervento", "SVUOTAMENTO_CASSA",
                    "urgenza", "ALTA",
                    "importo", importo
            );

            segnalaProblema("CASSA_PIENA",
                    "Necessario svuotamento cassa - Importo: " + importo + "€",
                    dettagli);

            // Registra il ricavo
            registraRicavo(macchinaId, importo);

        } catch (Exception e) {
            logger.error("Errore nella richiesta svuotamento cassa: {}", e.getMessage());
        }
    }

    private void registraRicavo(int macchinaId, double importo) {
        try {
            RicavoRepository ricavoRepo = ServiceRegistry.get(RicavoRepository.class);

            Ricavo ricavo = new Ricavo();
            ricavo.setMacchinaId(macchinaId);
            ricavo.setImporto(importo);
            ricavo.setDataOra(LocalDateTime.now());

            ricavoRepo.save(ricavo);
            logger.info("Registrato ricavo di {}€ per la macchina {}", importo, macchinaId);

        } catch (Exception e) {
            logger.error("Errore nella registrazione del ricavo: {}", e.getMessage());
        }
    }

    public void spegni() {
        mqttClient.disconnect();
    }

    private static class SegnalazioneProblema {
        String tipo;
        String descrizione;
        Map<String, Object> dettagli;
        long timestamp;

        public SegnalazioneProblema() {
            this.timestamp = System.currentTimeMillis();
        }
    }

    private static class RisoluzioneProblema {
        String idProblema;
        String descrizioneRisoluzione;
        String tecnico;
        long timestampRisoluzione;
    }
}

================
File: src/main/java/com/vending/iot/machines/MacchinaPrincipale.java
================
package com.vending.iot.machines;

import com.vending.core.models.Macchina;
import com.vending.core.models.Bevanda;
import com.vending.iot.mqtt.MQTTClient;
import org.eclipse.paho.client.mqttv3.MqttException;
import com.google.gson.Gson;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.concurrent.atomic.AtomicBoolean;

public class MacchinaPrincipale {

    private final int id;
    public final GestoreCassa gestoreCassa;
    public final GestoreBevande gestoreBevande;
    public final GestoreCialde gestoreCialde;
    public final GestoreManutenzione gestoreManutenzione;
    private final MQTTClient clientMqtt;
    private final Gson gson;
    private final AtomicBoolean inErogazione;

    public MacchinaPrincipale(Macchina macchina) throws MqttException {
        this.id = macchina.getId();
        this.gson = new Gson();
        this.clientMqtt = new MQTTClient("macchina_" + id);
        this.gestoreCassa = new GestoreCassa(id, macchina.getCassaMassima());
        this.gestoreCialde = new GestoreCialde(id);
        this.gestoreBevande = new GestoreBevande(id, gestoreCassa, gestoreCialde);
        this.gestoreManutenzione = new GestoreManutenzione(id);
        this.inErogazione = new AtomicBoolean(false);

        inizializzaMacchina(macchina);
        configuraSottoscrizioni();
    }

    private void inizializzaMacchina(Macchina macchina) {
        // Inizializza bevande e cialde
        macchina.getBevande().forEach(gestoreBevande::aggiungiBevanda);
        macchina.getCialde().forEach(cialda
                -> gestoreCialde.inizializzaCialda(
                        cialda.getCialdaId(),
                        cialda.getQuantita(),
                        cialda.getQuantitaMassima()
                )
        );
        
        // Imposta stato cassa
        gestoreCassa.impostaSaldoCassa(macchina.getCassaAttuale());
        pubblicaStatoMacchina();
    }

    private void configuraSottoscrizioni() throws MqttException {
        String topicBase = "macchine/" + id + "/";

        // Comandi generali
        clientMqtt.subscribe(topicBase + "comandi/#", (topic, messaggio) -> {
            String comando = topic.substring((topicBase + "comandi/").length());
            switch (comando) {
                case "spegnimento":
                    eseguiSpegnimento();
                    break;
                case "riavvio":
                    eseguiRiavvio();
                    break;
                case "stato":
                    pubblicaStatoMacchina();
                    break;
            }
        });

        // Operazioni cliente
        clientMqtt.subscribe(topicBase + "operazioni/#", (topic, messaggio) -> {
            String operazione = topic.substring((topicBase + "operazioni/").length());
            Map<String, Object> dati = gson.fromJson(messaggio, Map.class);

            switch (operazione) {
                case "inserimentoCredito":
                    try {
                        double importo = ((Number) dati.get("importo")).doubleValue();
                        gestoreCassa.gestisciInserimentoMoneta(importo);
                    } catch (Exception e) {
                        pubblicaErrore("errore_inserimento_credito", "Errore nell'inserimento del credito");
                    }
                    break;

                case "richiestaBevanda":
                    if (!inErogazione.compareAndSet(false, true)) {
                        pubblicaErrore("macchina_occupata", "Erogazione già in corso");
                        return;
                    }

                    try {
                        int bevandaId = ((Number) dati.get("bevandaId")).intValue();
                        int livelloZucchero = ((Number) dati.get("livelloZucchero")).intValue();
                        gestisciErogazioneBevanda(bevandaId, livelloZucchero);
                    } catch (Exception e) {
                        pubblicaErrore("errore_erogazione", "Errore nell'erogazione della bevanda");
                        inErogazione.set(false);
                    }
                    break;

                case "richiestaResto":
                    gestoreCassa.gestisciRestituzioneCredito();
                    break;
            }
        });
    }

    public void gestisciErogazioneBevanda(int bevandaId, int livelloZucchero) {
        try {
            // Verifica che la bevanda sia disponibile
            List<Bevanda> bevandeDisponibili = gestoreBevande.getBevandeMacchina(id);
            Bevanda bevandaRichiesta = null;

            for (Bevanda bevanda : bevandeDisponibili) {
                if (bevanda.getId() == bevandaId) {
                    bevandaRichiesta = bevanda;
                    break;
                }
            }

            if (bevandaRichiesta == null) {
                pubblicaErrore("bevanda_non_disponibile", "Bevanda non disponibile");
                return;
            }

            // Verifica che ci siano cialde sufficienti
            if (!gestoreCialde.verificaDisponibilitaCialde(bevandaRichiesta.getCialde())) {
                pubblicaErrore("cialde_insufficienti", "Cialde insufficienti per l'erogazione");
                return;
            }

            // Verifica che ci sia spazio sufficiente nella cassa
            if (!gestoreCassa.puoAccettareImporto(bevandaRichiesta.getPrezzo())) {
                pubblicaErrore("cassa_piena", "Non c'è spazio sufficiente nella cassa");
                return;
            }

            // Se tutti i controlli sono superati, procedi con l'erogazione
            pubblicaEvento("inizio_erogazione", "Preparazione bevanda in corso");

            // Simula tempo di preparazione
            Thread.sleep(5000);

            // Consuma le cialde
            gestoreCialde.consumaCialde(bevandaRichiesta.getCialde());

            // Aggiorna il saldo della cassa
            gestoreCassa.processaPagamento(bevandaRichiesta.getPrezzo());

            // Completa erogazione
            pubblicaEvento("fine_erogazione", "Bevanda pronta");

        } catch (Exception e) {
            pubblicaErrore("errore_erogazione", "Errore durante l'erogazione: " + e.getMessage());
        } finally {
            inErogazione.set(false);
        }
    }

    public void pubblicaStatoMacchina() {
        try {
            Map<String, Object> stato = new HashMap<>();
            stato.put("id", id);
            stato.put("statoCassa", gestoreCassa.ottieniStato());
            stato.put("statoBevande", gestoreBevande.ottieniStato());
            stato.put("statoCialde", gestoreCialde.ottieniStato());
            stato.put("statoManutenzione", gestoreManutenzione.ottieniStato());
            stato.put("inErogazione", inErogazione.get());

            clientMqtt.publish("macchine/" + id + "/stato", gson.toJson(stato));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void pubblicaEvento(String tipo, String messaggio) {
        try {
            Map<String, Object> evento = Map.of(
                    "tipo", tipo,
                    "messaggio", messaggio,
                    "timestamp", System.currentTimeMillis()
            );

            clientMqtt.publish("macchine/" + id + "/eventi", gson.toJson(evento));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void pubblicaErrore(String codice, String messaggio) {
        pubblicaEvento("errore", Map.of(
                "codice", codice,
                "messaggio", messaggio
        ).toString());
    }

    public void eseguiSpegnimento() {
        try {
            pubblicaEvento("spegnimento", "Spegnimento macchina in corso");
            gestoreCassa.spegni();
            gestoreBevande.spegni();
            gestoreCialde.spegni();
            gestoreManutenzione.spegni();
            clientMqtt.disconnect();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void eseguiRiavvio() {
        try {
            pubblicaEvento("riavvio", "Riavvio macchina in corso");
            eseguiSpegnimento();
            Thread.sleep(5000);
            inizializzaMacchina(new Macchina());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

================
File: src/main/java/com/vending/iot/monitor/AlertManager.java
================
package com.vending.iot.monitor;

import com.google.gson.Gson;
import com.vending.iot.mqtt.MQTTClient;
import org.eclipse.paho.client.mqttv3.MqttException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Map;

public class AlertManager {
    private final MQTTClient mqttClient;
    private final Gson gson;
    private final Map<String, Integer> contatoreFallimenti;

    public AlertManager(MQTTClient mqttClient) {
        this.mqttClient = mqttClient;
        this.gson = new Gson();
        this.contatoreFallimenti = new ConcurrentHashMap<>();
    }

    public void inviaAlert(int macchinaId, String tipo, String messaggio, int severita) {
        try {
            Alert alert = new Alert(macchinaId, tipo, messaggio, severita);
            String topic = "monitoraggio/alert/" + macchinaId;
            mqttClient.publish(topic, gson.toJson(alert));
            
            // Reset contatore fallimenti per questa macchina
            contatoreFallimenti.remove(String.valueOf(macchinaId));
            
            // Se severità alta, invia anche notifica di manutenzione
            if (severita == 3) {
                inviaNotificaManutenzione(macchinaId, messaggio);
            }
            
        } catch (MqttException e) {
            gestisciFallimentoInvio(macchinaId);
        }
    }

    private void inviaNotificaManutenzione(int macchinaId, String messaggio) {
        try {
            Map<String, Object> notifica = Map.of(
                "macchinaId", macchinaId,
                "messaggio", messaggio,
                "timestamp", System.currentTimeMillis(),
                "urgente", true
            );
            mqttClient.publish("manutenzione/richieste/" + macchinaId, gson.toJson(notifica));
        } catch (MqttException e) {
            System.err.println("Errore nell'invio notifica manutenzione: " + e.getMessage());
        }
    }

    private void gestisciFallimentoInvio(int macchinaId) {
        String key = String.valueOf(macchinaId);
        int contatore = contatoreFallimenti.getOrDefault(key, 0) + 1;
        contatoreFallimenti.put(key, contatore);
        
        if (contatore >= 3) {
            System.err.println("Errore critico: impossibile inviare alert per la macchina " + macchinaId);
            // Qui potrebbe essere implementata una logica di fallback
        }
    }

    private static class Alert {
        private final int macchinaId;
        private final String tipo;
        private final String messaggio;
        private final int severita;
        private final long timestamp;

        public Alert(int macchinaId, String tipo, String messaggio, int severita) {
            this.macchinaId = macchinaId;
            this.tipo = tipo;
            this.messaggio = messaggio;
            this.severita = severita;
            this.timestamp = System.currentTimeMillis();
        }
    }
}

================
File: src/main/java/com/vending/iot/monitor/Allarme.java
================
package com.vending.iot.monitor;

import java.time.LocalDateTime;

public class Allarme {
    private String tipo;
    private String messaggio;
    private int severita;  // 1: bassa, 2: media, 3: alta
    private LocalDateTime timestamp;

    public Allarme(String tipo, String messaggio, int severita) {
        this.tipo = tipo;
        this.messaggio = messaggio;
        this.severita = severita;
        this.timestamp = LocalDateTime.now();
    }

    // Getters
    public String getTipo() { return tipo; }
    public String getMessaggio() { return messaggio; }
    public int getSeverita() { return severita; }
    public LocalDateTime getTimestamp() { return timestamp; }
}

================
File: src/main/java/com/vending/iot/monitor/MonitorMacchine.java
================
package com.vending.iot.monitor;

import com.google.gson.Gson;
import com.vending.iot.mqtt.MQTTClient;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.eclipse.paho.client.mqttv3.MqttException;

public class MonitorMacchine {
    private final Map<Integer, StatoMacchina> statiMacchine;
    private final MQTTClient mqttClient;
    private final AlertManager alertManager;
    private final Gson gson;

    public MonitorMacchine() throws MqttException {
        this.statiMacchine = new ConcurrentHashMap<>();
        this.mqttClient = new MQTTClient("monitor_macchine");
        this.alertManager = new AlertManager(mqttClient);
        this.gson = new Gson();
        
        inizializzaMonitoraggio();
    }

    private void inizializzaMonitoraggio() throws MqttException {
        // Sottoscrizione agli stati delle macchine
        mqttClient.subscribe("macchine/+/stato", (topic, messaggio) -> {
            int macchinaId = estraiIdMacchina(topic);
            StatoMacchina stato = gson.fromJson(messaggio, StatoMacchina.class);
            aggiornaStatoMacchina(macchinaId, stato);
        });

        // Sottoscrizione agli allarmi
        mqttClient.subscribe("macchine/+/allarmi", (topic, messaggio) -> {
            int macchinaId = estraiIdMacchina(topic);
            Allarme allarme = gson.fromJson(messaggio, Allarme.class);
            gestisciAllarme(macchinaId, allarme);
        });
    }

    private int estraiIdMacchina(String topic) {
        String[] parts = topic.split("/");
        return Integer.parseInt(parts[1]);
    }

    private void aggiornaStatoMacchina(int macchinaId, StatoMacchina stato) {
        StatoMacchina statoPrec = statiMacchine.put(macchinaId, stato);
        
        // Verifica cambiamenti significativi
        if (statoPrec != null) {
            verificaCambiamenti(macchinaId, statoPrec, stato);
        }

        // Pubblica aggiornamento
        pubblicaStatoAggiornato(macchinaId, stato);
    }

    private void verificaCambiamenti(int macchinaId, StatoMacchina statoPrec, StatoMacchina statoNuovo) {
        // Verifica livello cialde
        if (statoNuovo.getLivelloCialde() < (statoNuovo.getCialdeMassime() * 0.2)) {
            alertManager.inviaAlert(
                macchinaId,
                "CIALDE_BASSE",
                "Livello cialde sotto il 20%",
                2
            );
        }

        // Verifica cassa
        if (statoNuovo.getLivelloCassa() > (statoNuovo.getCassaMassima() * 0.9)) {
            alertManager.inviaAlert(
                macchinaId,
                "CASSA_PIENA",
                "Livello cassa sopra il 90%",
                2
            );
        }

        // Verifica cambio stato
        if (!statoPrec.getStato().equals(statoNuovo.getStato())) {
            alertManager.inviaAlert(
                macchinaId,
                "CAMBIO_STATO",
                "Cambio stato da " + statoPrec.getStato() + " a " + statoNuovo.getStato(),
                1
            );
        }
    }

    private void gestisciAllarme(int macchinaId, Allarme allarme) {
        // Aggiorna stato macchina con allarme
        StatoMacchina stato = statiMacchine.get(macchinaId);
        if (stato != null) {
            stato.aggiungiAllarme(allarme);
            statiMacchine.put(macchinaId, stato);
        }

        // Invia alert appropriato
        alertManager.inviaAlert(
            macchinaId,
            allarme.getTipo(),
            allarme.getMessaggio(),
            allarme.getSeverita()
        );
    }

    private void pubblicaStatoAggiornato(int macchinaId, StatoMacchina stato) {
        try {
            String topic = "macchine/" + macchinaId + "/stato/monitoraggio";
            mqttClient.pubblicaConRitenzione(topic, gson.toJson(stato));
        } catch (MqttException e) {
            System.err.println("Errore nella pubblicazione dello stato: " + e.getMessage());
        }
    }

    public Map<Integer, StatoMacchina> getStatiMacchine() {
        return new ConcurrentHashMap<>(statiMacchine);
    }

    public StatoMacchina getStatoMacchina(int macchinaId) {
        return statiMacchine.get(macchinaId);
    }

    public void spegni() {
        mqttClient.disconnect();
    }
}

================
File: src/main/java/com/vending/iot/monitor/StatoMacchina.java
================
package com.vending.iot.monitor;

import java.util.ArrayList;
import java.util.List;
import java.time.LocalDateTime;

public class StatoMacchina {
    private String stato;
    private double livelloCassa;
    private double cassaMassima;
    private int livelloCialde;
    private int cialdeMassime;
    private double creditoAttuale;
    private List<Allarme> allarmi;
    private LocalDateTime ultimoAggiornamento;
    private boolean richiedeManutenzione;
    private String ultimaManutenzione;

    public StatoMacchina() {
        this.allarmi = new ArrayList<>();
        this.ultimoAggiornamento = LocalDateTime.now();
    }

    // Getters e Setters
    public String getStato() { return stato; }
    public void setStato(String stato) { this.stato = stato; }

    public double getLivelloCassa() { return livelloCassa; }
    public void setLivelloCassa(double livelloCassa) { this.livelloCassa = livelloCassa; }

    public double getCassaMassima() { return cassaMassima; }
    public void setCassaMassima(double cassaMassima) { this.cassaMassima = cassaMassima; }

    public int getLivelloCialde() { return livelloCialde; }
    public void setLivelloCialde(int livelloCialde) { this.livelloCialde = livelloCialde; }

    public int getCialdeMassime() { return cialdeMassime; }
    public void setCialdeMassime(int cialdeMassime) { this.cialdeMassime = cialdeMassime; }

    public double getCreditoAttuale() { return creditoAttuale; }
    public void setCreditoAttuale(double creditoAttuale) { this.creditoAttuale = creditoAttuale; }

    public List<Allarme> getAllarmi() { return new ArrayList<>(allarmi); }

    public LocalDateTime getUltimoAggiornamento() { return ultimoAggiornamento; }
    public void aggiornaTimestamp() { this.ultimoAggiornamento = LocalDateTime.now(); }

    public void aggiungiAllarme(Allarme allarme) {
        this.allarmi.add(allarme);
        this.richiedeManutenzione = true;
    }

    public void risolviAllarmi() {
        this.allarmi.clear();
        this.richiedeManutenzione = false;
    }

    public boolean isRichiedeManutenzione() { return richiedeManutenzione; }
    
    public String getUltimaManutenzione() { return ultimaManutenzione; }
    public void setUltimaManutenzione(String ultimaManutenzione) { 
        this.ultimaManutenzione = ultimaManutenzione; 
    }
}

================
File: src/main/java/com/vending/iot/mqtt/MessageHandler.java
================
package com.vending.iot.mqtt;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import java.util.function.Consumer;

public class MessageHandler {
    private final Gson gson;

    public MessageHandler() {
        this.gson = new Gson();
    }

    public <T> void gestisciMessaggio(String payload, Class<T> tipo, Consumer<T> handler) {
        try {
            T oggetto = gson.fromJson(payload, tipo);
            handler.accept(oggetto);
        } catch (JsonSyntaxException e) {
            System.err.println("Errore nella deserializzazione del messaggio: " + e.getMessage());
        } catch (Exception e) {
            System.err.println("Errore nella gestione del messaggio: " + e.getMessage());
        }
    }

    public String creaMessaggio(Object oggetto) {
        try {
            return gson.toJson(oggetto);
        } catch (Exception e) {
            System.err.println("Errore nella serializzazione del messaggio: " + e.getMessage());
            return "{}";
        }
    }

    public static class MessaggioStato {
        public String stato;
        public long timestamp;

        public MessaggioStato(String stato) {
            this.stato = stato;
            this.timestamp = System.currentTimeMillis();
        }
    }

    public static class MessaggioErrore {
        public String codice;
        public String descrizione;
        public long timestamp;

        public MessaggioErrore(String codice, String descrizione) {
            this.codice = codice;
            this.descrizione = descrizione;
            this.timestamp = System.currentTimeMillis();
        }
    }

    public static class MessaggioAllarme {
        public String tipo;
        public String messaggio;
        public int livelloSeverita;
        public long timestamp;

        public MessaggioAllarme(String tipo, String messaggio, int livelloSeverita) {
            this.tipo = tipo;
            this.messaggio = messaggio;
            this.livelloSeverita = livelloSeverita;
            this.timestamp = System.currentTimeMillis();
        }
    }
}

================
File: src/main/java/com/vending/iot/mqtt/MQTTClient.java
================
package com.vending.iot.mqtt;

import org.eclipse.paho.client.mqttv3.*;
import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Map;
import java.util.Properties;
import java.util.function.BiConsumer;

public class MQTTClient {
    private final MqttClient client;
    private final String clientId;
    private final Map<String, BiConsumer<String, String>> topicHandlers;
    private volatile boolean isConnecting;
    private int retryCount;

    public MQTTClient(String prefix) throws MqttException {
        this.clientId = MQTTConfig.CLIENT_ID_PREFIX + prefix + "_" + UUID.randomUUID().toString();
        this.client = new MqttClient(MQTTConfig.BROKER_URL, clientId, new MemoryPersistence());
        this.topicHandlers = new ConcurrentHashMap<>();
        this.retryCount = 0;
        this.isConnecting = false;
        inizializzaClient();
    }

    private void inizializzaClient() throws MqttException {
    	MqttConnectOptions options = new MqttConnectOptions();
        
        // Configurazione base
    	options.setCleanSession(true);
        options.setAutomaticReconnect(false);
        options.setConnectionTimeout(MQTTConfig.CONNECTION_TIMEOUT);
        options.setKeepAliveInterval(MQTTConfig.KEEP_ALIVE_INTERVAL);
        
        // Configurazione autenticazione
        options.setUserName(MQTTConfig.USERNAME);
        options.setPassword(MQTTConfig.PASSWORD.toCharArray());
        
	     // Configurazione SSL
	        try {
	            System.setProperty("javax.net.ssl.trustStore", MQTTConfig.TRUSTSTORE_PATH);
	            System.setProperty("javax.net.ssl.trustStorePassword", MQTTConfig.TRUSTSTORE_PASSWORD);
	            System.setProperty("javax.net.ssl.trustStoreType", MQTTConfig.TRUSTSTORE_TYPE);
	            
	            Properties sslProperties = new Properties();
	            sslProperties.setProperty("com.ibm.ssl.protocol", "TLSv1.2");
	            options.setSSLProperties(sslProperties);
	        } catch (Exception e) {
	            throw new MqttException(new RuntimeException("Errore nella configurazione SSL", e));
	        }

        client.setCallback(new MqttCallback() {
        	 @Override
        	 public void connectionLost(Throwable cause) {
                 System.err.println("Connessione persa per il client " + clientId);
                 System.err.println("Causa: " + (cause != null ? cause.getMessage() : "sconosciuta"));
                 scheduleReconnect();
             }

            @Override
            public void messageArrived(String topic, MqttMessage message) {
                String payload = new String(message.getPayload());
                BiConsumer<String, String> handler = topicHandlers.get(topic);
                if (handler != null) {
                    handler.accept(topic, payload);
                }
            }

            @Override
            public void deliveryComplete(IMqttDeliveryToken token) {
                // Gestione completamento consegna se necessario
            }
        });

        connetti(options);
    }
    
    private void scheduleReconnect() {
        if (!isConnecting && retryCount < MQTTConfig.MAX_RETRY_ATTEMPTS) {
            new Thread(() -> {
                try {
                    Thread.sleep(MQTTConfig.RETRY_INTERVAL);
                    tentaRiconnessione();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        }
    }

    public synchronized void connetti(MqttConnectOptions options) throws MqttException {
    	if (isConnecting) {
            return;
        }
        try {
        	isConnecting = true;
        	if (!client.isConnected()) {
                client.connect(options);
                System.out.println("Client " + clientId + " connesso con successo");
                retryCount = 0;
                
                // Ricrea le sottoscrizioni dopo la riconnessione
                for (String topic : topicHandlers.keySet()) {
                    client.subscribe(topic, MQTTConfig.QOS);
                }
            }
        } finally {
            isConnecting = false;
        }
    }

    private void tentaRiconnessione() {
    	 if (!client.isConnected() && retryCount < MQTTConfig.MAX_RETRY_ATTEMPTS) {
             retryCount++;
             System.out.println("Tentativo di riconnessione " + retryCount + " per il client " + clientId);
             try {
                 MqttConnectOptions options = new MqttConnectOptions();
                 options.setCleanSession(true);
                 options.setAutomaticReconnect(false);
                 options.setUserName(MQTTConfig.USERNAME);
                 options.setPassword(MQTTConfig.PASSWORD.toCharArray());
                 connetti(options);
             } catch (MqttException e) {
                 System.err.println("Riconnessione fallita per il client " + clientId);
                 scheduleReconnect();
             }
         }
     }

    public void subscribe(String topic, BiConsumer<String, String> handler) throws MqttException {
        client.subscribe(topic, MQTTConfig.QOS);
        topicHandlers.put(topic, handler);
        System.out.println("Client " + clientId + " sottoscritto al topic: " + topic);
    }

    public void publish(String topic, String message) throws MqttException {
        MqttMessage mqttMessage = new MqttMessage(message.getBytes());
        mqttMessage.setQos(MQTTConfig.QOS);
        client.publish(topic, mqttMessage);
    }

    public void pubblicaConRitenzione(String topic, String message) throws MqttException {
        MqttMessage mqttMessage = new MqttMessage(message.getBytes());
        mqttMessage.setQos(MQTTConfig.QOS);
        mqttMessage.setRetained(true);
        client.publish(topic, mqttMessage);
    }

    public void rimuoviSottoscrizione(String topic) throws MqttException {
        client.unsubscribe(topic);
        topicHandlers.remove(topic);
    }

    public void disconnect() {
        try {
            if (client.isConnected()) {
                client.disconnect();
            }
            client.close();
            System.out.println("Client " + clientId + " disconnesso con successo");
        } catch (MqttException e) {
            System.err.println("Errore durante la disconnessione del client " + clientId);
        }
    }

    public boolean isConnesso() {
        return client.isConnected();
    }
}

================
File: src/main/java/com/vending/iot/mqtt/MQTTConfig.java
================
package com.vending.iot.mqtt;

public class MQTTConfig {
	// Configurazione broker
    public static final String BROKER_URL = "ssl://localhost:8883";
    public static final String CLIENT_ID_PREFIX = "pissir_";
    public static final String USERNAME = "20019309";
    public static final String PASSWORD = "Pissir2024!";
    public static final int QOS = 1;
    
    // Configurazione SSL
    public static final String TRUSTSTORE_PATH = "C:\\Program Files\\mosquitto\\certs\\mosquitto.jks";
    public static final String TRUSTSTORE_PASSWORD = "mosquitto";
    public static final String TRUSTSTORE_TYPE = "JKS";
    
    // Timeout e retry
    public static final int CONNECTION_TIMEOUT = 10;
    public static final int KEEP_ALIVE_INTERVAL = 30;
    public static final int MAX_RETRY_ATTEMPTS = 3;
    public static final int RETRY_INTERVAL = 5000;
    
    // Topic base per la comunicazione
    public static final String TOPIC_BASE = "distributori/";
    
    // Topic per le macchine
    public static final String TOPIC_MACCHINE = TOPIC_BASE + "macchine/";
    public static final String TOPIC_STATO = TOPIC_BASE + "/stato";
    public static final String TOPIC_CREDITO = "/credito";
    public static final String TOPIC_EROGAZIONE = "/erogazione";
    public static final String TOPIC_MANUTENZIONE = "/manutenzione";
    public static final String TOPIC_CIALDE = "/cialde";
    public static final String TOPIC_CASSA = "/cassa";
    
    // Topic per il monitoraggio
    public static final String TOPIC_MONITORAGGIO = TOPIC_BASE + "monitoraggio/";
    public static final String TOPIC_ALLARMI = TOPIC_MONITORAGGIO + "allarmi/";
    public static final String TOPIC_STATISTICHE = TOPIC_MONITORAGGIO + "statistiche/";
    
    
    
}

================
File: src/main/java/com/vending/Main.java
================
package com.vending;

import com.google.gson.Gson;

import static spark.Spark.*;

import com.vending.api.controllers.*;
import com.vending.api.middleware.AuthMiddleware;
import com.vending.api.middleware.CORSMiddleware;
import com.vending.api.routes.Routes;
import com.vending.core.services.*;
import com.vending.iot.machines.MacchinaPrincipale;
import com.vending.iot.mqtt.MQTTClient;
import com.vending.security.auth.AuthenticationService;
import com.vending.security.auth.PasswordService;
import com.vending.security.jwt.JWTService;
import com.vending.utils.config.ConfigUtil;

import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;

import javax.net.ssl.SSLSocketFactory;

import com.vending.core.models.Cialda;
import com.vending.core.models.Macchina;
import com.vending.core.repositories.BevandaRepository;
import com.vending.core.repositories.CialdaRepository;
import com.vending.core.repositories.IstitutoRepository;
import com.vending.core.repositories.MacchinaRepository;
import com.vending.core.repositories.ManutenzioneRepository;
import com.vending.core.repositories.RicavoRepository;
import com.vending.core.repositories.TransazioneRepository;
import com.vending.core.repositories.UtenteRepository;

/**
 * Classe principale che avvia l'applicazione del sistema di gestione distributori automatici.
 */
public class Main {
    private static final Logger logger = LoggerFactory.getLogger(Main.class);
    private static final Gson gson = new Gson();
    private static Properties config;
    private static MQTTClient mqttClient;
    
    private static final Map<Integer, MacchinaPrincipale> macchineAttive = new ConcurrentHashMap<>();

    public static void main(String[] args) {
        try {
            // Carica la configurazione
            initConfig();

            // Inizializza i servizi
            initServices();

            // Configura Spark
            configureServer();

            // Inizializza MQTT
            initMQTT();

            // Inizializza le macchine
            initMacchine();

            // Configura i controller e le route
            setupRoutes();

            logger.info("Applicazione avviata con successo sulla porta {}", config.getProperty("server.port"));
            
            // Apri il browser con la dashboard
            openDashboard(config.getProperty("server.port", "8080"));

        } catch (Exception e) {
            logger.error("Errore durante l'avvio dell'applicazione", e);
            System.exit(1);
        }
    }

    private static void initConfig() throws Exception {
        config = ConfigUtil.loadProperties("config.properties");
        
        // Imposta la porta del server
        port(Integer.parseInt(config.getProperty("server.port", "8080")));
        
        // Imposta il timeout delle sessioni
        int maxThreads = Integer.parseInt(config.getProperty("server.maxThreads", "100"));
        int minThreads = Integer.parseInt(config.getProperty("server.minThreads", "2"));
        int timeOutMillis = Integer.parseInt(config.getProperty("server.timeOutMillis", "30000"));
        threadPool(maxThreads, minThreads, timeOutMillis);
    }

    private static void initServices() {
    	// Inizializza i repository
        CialdaRepository cialdaRepository = new CialdaRepository();
        BevandaRepository bevandaRepository = new BevandaRepository(cialdaRepository);
        UtenteRepository utenteRepository = new UtenteRepository();
        MacchinaRepository macchinaRepository = new MacchinaRepository();
        ManutenzioneRepository manutenzioneRepository = new ManutenzioneRepository();
        RicavoRepository ricavoRepository = new RicavoRepository();
        TransazioneRepository transazioneRepository = new TransazioneRepository();
        IstitutoRepository istitutoRepository = new IstitutoRepository(macchinaRepository);
        
        // Registra i repository nel ServiceRegistry
        ServiceRegistry.register("istitutoRepository", istitutoRepository);
        ServiceRegistry.register("macchinaRepository", macchinaRepository);
        ServiceRegistry.register("manutenzioneRepository", manutenzioneRepository);
        
        // Inizializza i servizi
        JWTService jwtService = new JWTService();
        BevandaService bevandaService = new BevandaService(bevandaRepository, cialdaRepository);
        UtenteService utenteService = new UtenteService(utenteRepository);
        ManutenzioneService manutenzioneService = new ManutenzioneService(manutenzioneRepository, macchinaRepository);
        RicavoService ricavoService = new RicavoService(ricavoRepository);
        TransazioneService transazioneService = new TransazioneService(transazioneRepository);
        IstitutoService istitutoService = new IstitutoService(istitutoRepository, macchinaRepository);
        MacchinaService macchinaService = new MacchinaService(macchinaRepository, ricavoRepository, transazioneRepository);

        // Registra i servizi
        ServiceRegistry.register("jwtService", jwtService);
        ServiceRegistry.register("authService", new AuthenticationService(utenteRepository, new PasswordService(), jwtService));
        ServiceRegistry.register("bevandaService", bevandaService);
        ServiceRegistry.register("utenteService", utenteService);
        ServiceRegistry.register("macchinaService", macchinaService);
        ServiceRegistry.register("istitutoService", istitutoService);
        ServiceRegistry.register("manutenzioneService", manutenzioneService);
        ServiceRegistry.register("ricavoService", ricavoService);
        ServiceRegistry.register("transazioneService", transazioneService);
    }

    private static void configureServer() {
        // Configura la cartella dei file statici
        staticFiles.location("/public");
        
        // Route per le pagine HTML
        get("/pages/client/machineSelection.html", (req, res) -> {
            res.type("text/html");
            return new java.io.File("src/main/resources/public/pages/client/machineSelection.html");
        });

        // Inizializza il middleware CORS per le richieste HTTP
        CORSMiddleware corsMiddleware = new CORSMiddleware();

        // Applica CORS a tutte le richieste 
        before((request, response) -> corsMiddleware.applicaCORS(request, response));
        
        // Gestisce le richieste OPTIONS per il CORS
        options("/*", (request, response) -> {
            corsMiddleware.applicaCORS(request, response);
            return "OK";
        });

        // Configurazione sicurezza
        AuthController authController = new AuthController(ServiceRegistry.get(AdminLoginService.class),
	            ServiceRegistry.get(UtenteService.class)
        );
        before("/api/*", authController::verificaToken);

        // Configurazione parser JSON
        after((request, response) -> {
            response.type("application/json");
        });

        // Gestione errori
        exception(Exception.class, (e, request, response) -> {
            logger.error("Errore non gestito", e);
            response.status(500);
            response.body(gson.toJson(new ErrorResponse("Errore interno del server")));
        });

        notFound((request, response) -> {
            response.type("application/json");
            return gson.toJson(new ErrorResponse("Risorsa non trovata"));
        });
    }

    private static void initMQTT() throws Exception {
        // Configurazione delle opzioni di connessione MQTT
        MqttConnectOptions options = new MqttConnectOptions();
        options.setCleanSession(true);
        options.setConnectionTimeout(30);
        options.setKeepAliveInterval(60);
        options.setAutomaticReconnect(true);
        options.setUserName(config.getProperty("mqtt.client.username"));
        options.setPassword(config.getProperty("mqtt.client.password").toCharArray());

        // Configurazione SSL se necessario
        if (Boolean.parseBoolean(config.getProperty("mqtt.ssl.enabled", "true"))) {
            options.setSocketFactory(SSLSocketFactory.getDefault());
        }

        // Configurazione Last Will and Testament (LWT)
        options.setWill("system/server/status", "offline".getBytes(), 1, true);

        mqttClient = new MQTTClient("server");
        mqttClient.connetti(options);

        // Sottoscrizione ai topic di sistema
        mqttClient.subscribe("macchine/+/stato", (topic, message) -> {
            // Gestione messaggi di stato
            logger.debug("Ricevuto messaggio stato: {} - {}", topic, message);
            ServiceRegistry.get(ManutenzioneService.class)
                         .processaMacchinaStato(topic, message);
            // Estrai l'ID della macchina dal topic
            String[] parts = topic.split("/");
            if (parts.length >= 2) {
                try {
                    int macchinaId = Integer.parseInt(parts[1]);
                    MacchinaPrincipale macchina = macchineAttive.get(macchinaId);
                    if (macchina != null) {
                        // Aggiorna lo stato della macchina
                        macchina.pubblicaStatoMacchina();
                    }
                } catch (NumberFormatException e) {
                    logger.error("ID macchina non valido nel topic: {}", topic);
                }
            }
        });


        logger.info("Client MQTT inizializzato e connesso");
    }

    private static void initMacchine() {
        try {
            MacchinaRepository macchinaRepo = new MacchinaRepository();
            var macchine = macchinaRepo.findAll();
            
            for (Macchina macchina : macchine) {
                try {
                    MacchinaPrincipale macchinaPrincipale = new MacchinaPrincipale(macchina);
                    macchineAttive.put(macchina.getId(), macchinaPrincipale);
                    logger.info("Macchina {} inizializzata con successo", macchina.getId());
                } catch (Exception e) {
                    logger.error("Errore nell'inizializzazione della macchina {}: {}", 
                        macchina.getId(), e.getMessage());
                }
            }
            
            logger.info("Inizializzate {} macchine", macchineAttive.size());
        } catch (Exception e) {
            logger.error("Errore durante l'inizializzazione delle macchine", e);
        }
    }


    private static void setupRoutes() throws MqttException {
    	
    	 // Aggiungi una route per la home
        get("/", (req, res) -> {
            res.redirect("/index.html");
            return null;
        });

        // Aggiungi una route per le pagine client
        get("/pages/client/*", (req, res) -> {
            return new java.io.File("src/main/resources/public" + req.pathInfo());
        });
        
        // Inizializzazione dei controller
        IstitutoController istitutoController = new IstitutoController(
            ServiceRegistry.get(IstitutoRepository.class),
            ServiceRegistry.get(MacchinaRepository.class)
        );
        
        MacchinaController macchinaController = new MacchinaController(
            ServiceRegistry.get(MacchinaRepository.class)
        );
     
        AuthController authController = new AuthController(ServiceRegistry.get(AdminLoginService.class),
	            ServiceRegistry.get(UtenteService.class)
        );
        
        ManutenzioneController manutenzioneController = new ManutenzioneController(
            ServiceRegistry.get(ManutenzioneRepository.class)
        );
        
        BevandaController bevandaController = new BevandaController(
                ServiceRegistry.get(BevandaService.class)
        );
        // Autenticazione e gestione utenti
        path("/api/auth", () -> {
            post("/login", authController::login);
            post("/refresh", authController::refreshToken);
            post("/registrazione", authController::registrazione);
        });

        Routes R = new Routes(istitutoController, macchinaController, bevandaController, manutenzioneController);
        if( R != null) {
            logger.info("Routes configurate con successo");
        }
        
    //     // Gestione istituti
    //     path("/api/istituti", () -> {
    //         get("", istitutoController::getAll);
    //         post("", istitutoController::create);
            
    //         path("/:id", () -> {
    //             get("", istitutoController::getById);
    //             delete("", istitutoController::delete);
    //         });
    //     });

    //     // Gestione macchine distributrici
    //     path("/api/macchine", () -> {
    //         get("", macchinaController::getAll);
    //         post("", macchinaController::create);
            
    //         path("/:id", () -> {
    //             get("", macchinaController::getById);
    //             delete("", macchinaController::delete);
                
    //             // Gestione stato e manutenzione
    //             post("/manutenzione", macchinaController::updateStato);
    //         });
    //     });

    //     /* Utenti routes
    //     get("/api/utenti", utenteController::getAllUtenti);
    //     post("/api/utenti", utenteController::createUtente);
    //     get("/api/utenti/:id", utenteController::getUtente);
    //     delete("/api/utenti/:id", utenteController::deleteUtente);*/

    //    // Routes per la gestione delle manutenzioni
    //     path("/api/manutenzione", () -> {
    //         // Recupera tutte le manutenzioni in corso
    //         get("/", manutenzioneController::getManutenzioni);
            
    //         // Gestione manutenzioni per istituto
    //         get("/istituti/:istitutoId", manutenzioneController::getManutenzioniIstituto);
            
    //         // Gestione manutenzioni per tecnico
    //         get("/tecnici/:tecnicoId", manutenzioneController::getManutenzioniTecnico);
            
    //         // Gestione singola macchina
    //         path("/macchine/:id", () -> {
    //             // Imposta macchina fuori servizio
    //             put("/fuori-servizio", manutenzioneController::setFuoriServizio);
                
    //             // Avvia nuova manutenzione
    //             post("/manutenzioni", manutenzioneController::iniziaManutenzione);
                
    //             // Completa una manutenzione esistente
    //             put("/manutenzioni/:id/completa", manutenzioneController::completaManutenzione);
    //         });
    //     });

    //     // Gestione bevande
    //     path("/api/bevande", () -> {
    //         get("", bevandaController::getAll);
    //         post("", bevandaController::create);
            
    //         path("/:id", () -> {
    //             get("", bevandaController::getById);
    //             put("", bevandaController::update);
    //             delete("", bevandaController::delete);
    //         });
    //     });

        //TOPIC MQTT

        // Configurazione MQTT per lo stato delle macchine
        mqttClient.subscribe("macchine/+/stato", (topic, message) -> {
            ServiceRegistry.get(ManutenzioneService.class).processaMacchinaStato(topic, message);
        });

        // Topic MQTT specifici per ogni tipo di stato
        mqttClient.subscribe("macchine/+/guasti", (topic, message) -> {
            // Il formato del topic è: macchine/{id}/guasti
            ServiceRegistry.get(ManutenzioneService.class).processaMacchinaStato(topic, message);
        });

        mqttClient.subscribe("macchine/+/cialde", (topic, message) -> {
            // Il formato del topic è: macchine/{id}/cialde
            ServiceRegistry.get(ManutenzioneService.class).processaMacchinaStato(topic, message);
        });

        mqttClient.subscribe("macchine/+/cassa", (topic, message) -> {
            // Il formato del topic è: macchine/{id}/cassa
            ServiceRegistry.get(ManutenzioneService.class).processaMacchinaStato(topic, message);
        });
        
    }

    /**
     * Apre il browser predefinito del sistema con la dashboard dell'applicazione.
     * 
     * @param port la porta su cui � in ascolto il server
     */
    private static void openDashboard(String port) {
        try {
            // Attendi 1.5 secondi per assicurarsi che il server sia completamente avviato
            Thread.sleep(1500);
            
            String url = "http://localhost:" + port + "/index.html";
            String os = System.getProperty("os.name").toLowerCase();
            
            // Apri il browser in base al sistema operativo
            if (os.contains("win")) {
                // Windows
                Runtime.getRuntime().exec("rundll32 url.dll,FileProtocolHandler " + url);
            } else if (os.contains("mac")) {
                // macOS
                Runtime.getRuntime().exec("open " + url);
            } else if (os.contains("nix") || os.contains("nux")) {
                // Linux
                String[] browsers = {"google-chrome", "firefox", "mozilla", "epiphany", "konqueror", "netscape", "opera", "links", "lynx"};
                
                StringBuffer cmd = new StringBuffer();
                for (int i = 0; i < browsers.length; i++) {
                    if (i == 0) {
                        cmd.append(String.format("%s \"%s\"", browsers[i], url));
                    } else {
                        cmd.append(String.format(" || %s \"%s\"", browsers[i], url));
                    }
                }
                
                Runtime.getRuntime().exec(new String[] {"sh", "-c", cmd.toString()});
            }
            
            logger.info("Dashboard aperta nel browser: {}", url);
        } catch (Exception e) {
            logger.error("Impossibile aprire il browser automaticamente", e);
            logger.info("Per accedere alla dashboard, apri manualmente: http://localhost:{}/dashboard.html", port);
        }
    }

    private static class ErrorResponse {
        private final String message;

        public ErrorResponse(String message) {
            this.message = message;
        }
    }

    // Metodo per lo spegnimento ordinato del sistema
    public static void shutdown() {
        logger.info("Avvio procedura di spegnimento...");
        
        // Spegni tutte le macchine attive
        macchineAttive.values().forEach(macchina -> {
            try {
                macchina.eseguiSpegnimento();
            } catch (Exception e) {
                logger.error("Errore durante lo spegnimento della macchina", e);
            }
        });
        
        // Pulisci la mappa delle macchine
        macchineAttive.clear();
        
        // Disconnetti il client MQTT
        try {
            if (mqttClient != null) {
                mqttClient.disconnect();
            }
        } catch (Exception e) {
            logger.error("Errore durante la disconnessione del client MQTT", e);
        }
        
        logger.info("Spegnimento completato");
    }
}

================
File: src/main/java/com/vending/MainV1.java
================
package com.vending;

import static spark.Spark.*;
import com.google.gson.Gson;
import com.vending.api.controllers.*;
import com.vending.api.middleware.*;
import com.vending.core.services.*;
import com.vending.iot.machines.GestoreCassa;
import com.vending.iot.machines.GestoreCialde;
import com.vending.iot.machines.MacchinaPrincipale;
import com.vending.iot.mqtt.MQTTClient;
import com.vending.security.auth.*;
import com.vending.security.jwt.JWTService;
import com.vending.utils.config.ConfigUtil;
import com.vending.core.models.*;
import com.vending.core.repositories.*;

import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import javax.net.ssl.SSLSocketFactory;

public class MainV1 {

    private static final Logger logger = LoggerFactory.getLogger(Main.class);
    private static final Gson gson = new Gson();
    private static Properties config;
    private static MQTTClient mqttClient;
    private static final Map<Integer, MacchinaPrincipale> macchineAttive = new ConcurrentHashMap<>();

    public static void main(String[] args) {
        try {
            // Carica la configurazione
            initConfig();

            // Inizializza i servizi
            initServices();

            // Configura il server Spark
            configureServer();

            // Inizializza MQTT
            initMQTT();

            // Inizializza le macchine
            initMacchine();

            // Configura i controller e le route
            setupRoutes();

            logger.info("Applicazione avviata con successo sulla porta {}", config.getProperty("server.port"));

            // Apri il browser con la dashboard
            openDashboard(config.getProperty("server.port", "8080"));

        } catch (Exception e) {
            logger.error("Errore durante l'avvio dell'applicazione", e);
            System.exit(1);
        }
    }

    private static void initConfig() throws Exception {
        // Carica il file di configurazione
        config = ConfigUtil.loadProperties("config.properties");

        // Imposta la porta del server
        port(Integer.parseInt(config.getProperty("server.port", "8080")));

        // Configurazione thread pool
        int maxThreads = Integer.parseInt(config.getProperty("server.maxThreads", "100"));
        int minThreads = Integer.parseInt(config.getProperty("server.minThreads", "2"));
        int timeOutMillis = Integer.parseInt(config.getProperty("server.timeOutMillis", "30000"));
        threadPool(maxThreads, minThreads, timeOutMillis);
    }

    private static void initServices() {
        // Inizializza i repository
        CialdaRepository cialdaRepository = new CialdaRepository();
        BevandaRepository bevandaRepository = new BevandaRepository(cialdaRepository);
        UtenteRepository utenteRepository = new UtenteRepository();
        MacchinaRepository macchinaRepository = new MacchinaRepository();
        ManutenzioneRepository manutenzioneRepository = new ManutenzioneRepository();
        RicavoRepository ricavoRepository = new RicavoRepository();
        TransazioneRepository transazioneRepository = new TransazioneRepository();
        IstitutoRepository istitutoRepository = new IstitutoRepository(macchinaRepository);
        AdminLoginRepository adminLoginRepository = new AdminLoginRepository(utenteRepository);

        // Registra i repository nel ServiceRegistry
        ServiceRegistry.register("cialdaRepository", cialdaRepository);
        ServiceRegistry.register("bevandaRepository", bevandaRepository);
        ServiceRegistry.register("utenteRepository", utenteRepository);
        ServiceRegistry.register("macchinaRepository", macchinaRepository);
        ServiceRegistry.register("manutenzioneRepository", manutenzioneRepository);
        ServiceRegistry.register("ricavoRepository", ricavoRepository);
        ServiceRegistry.register("transazioneRepository", transazioneRepository);
        ServiceRegistry.register("istitutoRepository", istitutoRepository);
        ServiceRegistry.register("adminLoginRepository", adminLoginRepository);

        // Inizializza i servizi
        JWTService jwtService = new JWTService();
        PasswordService passwordService = new PasswordService();
        AuthenticationService authService = new AuthenticationService(utenteRepository, passwordService, jwtService);
        BevandaService bevandaService = new BevandaService(bevandaRepository, cialdaRepository);
        UtenteService utenteService = new UtenteService(utenteRepository);
        MacchinaService macchinaService = new MacchinaService(macchinaRepository, ricavoRepository, transazioneRepository);
        IstitutoService istitutoService = new IstitutoService(istitutoRepository, macchinaRepository);
        ManutenzioneService manutenzioneService = new ManutenzioneService(manutenzioneRepository, macchinaRepository);
        RicavoService ricavoService = new RicavoService(ricavoRepository);
        TransazioneService transazioneService = new TransazioneService(transazioneRepository);
        MacchinaController macchinaController = new MacchinaController(macchinaRepository, bevandaRepository);
        PublicController publicController = new PublicController(macchinaRepository, bevandaRepository, istitutoRepository, transazioneRepository);
        AdminLoginService adminLoginService = new AdminLoginService(adminLoginRepository, utenteRepository);

        // Registra i servizi
        ServiceRegistry.register("jwtService", jwtService);
        ServiceRegistry.register("authService", authService);
        ServiceRegistry.register("bevandaService", bevandaService);
        ServiceRegistry.register("utenteService", utenteService);
        ServiceRegistry.register("macchinaService", macchinaService);
        ServiceRegistry.register("istitutoService", istitutoService);
        ServiceRegistry.register("manutenzioneService", manutenzioneService);
        ServiceRegistry.register("ricavoService", ricavoService);
        ServiceRegistry.register("transazioneService", transazioneService);
        ServiceRegistry.register("publicController", publicController);
        ServiceRegistry.register("adminLoginService", adminLoginService);
        ServiceRegistry.register("macchinaController", macchinaController);

    }

    private static void configureServer() {
        // Configura la cartella dei file statici
        staticFiles.location("/public");
        staticFiles.header("Access-Control-Allow-Origin", "*");
        staticFiles.header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
        staticFiles.header("Access-Control-Allow-Headers", "Content-Type, Authorization");

        // Configura CORS
        CORSMiddleware corsMiddleware = new CORSMiddleware();
        before((request, response) -> corsMiddleware.applicaCORS(request, response));

        // Gestione OPTIONS per CORS
        options("/*", (request, response) -> {
            corsMiddleware.applicaCORS(request, response);
            return "OK";
        });

        // Configurazione autenticazione
        AuthController authController = new AuthController(ServiceRegistry.get(AdminLoginService.class),
                ServiceRegistry.get(UtenteService.class));
        before("/api/*", authController::verificaToken);

        // Configurazione parser JSON
        after((request, response) -> {
            response.type("application/json");
        });

        // Gestione errori
        exception(Exception.class, (e, request, response) -> {
            logger.error("Errore non gestito", e);
            response.status(500);
            response.body(gson.toJson(new ErrorResponse("Errore interno del server")));
        });

        notFound((request, response) -> {
            response.type("application/json");
            return gson.toJson(new ErrorResponse("Risorsa non trovata"));
        });
    }

    /* private static void initMQTT() throws Exception {
        // Configurazione opzioni MQTT
        MqttConnectOptions options = new MqttConnectOptions();
        options.setCleanSession(true);
        options.setConnectionTimeout(30);
        options.setKeepAliveInterval(60);
        options.setAutomaticReconnect(true);
        options.setUserName(config.getProperty("mqtt.client.username"));
        options.setPassword(config.getProperty("mqtt.client.password").toCharArray());

        // Configurazione SSL se abilitato
        if (Boolean.parseBoolean(config.getProperty("mqtt.ssl.enabled", "true"))) {
            options.setSocketFactory(SSLSocketFactory.getDefault());
        }

        // Configurazione Last Will and Testament
        options.setWill("system/server/status", "offline".getBytes(), 1, true);

        // Inizializza e connetti il client MQTT
        mqttClient = new MQTTClient("server");
        mqttClient.connetti(options);

        // Sottoscrizione ai topic di sistema
        mqttClient.subscribe("macchine/+/stato", (topic, message) -> {
            logger.debug("Ricevuto messaggio stato: {} - {}", topic, message);
            ServiceRegistry.get(ManutenzioneService.class).processaMacchinaStato(topic, message);
            
            String[] parts = topic.split("/");
            if (parts.length >= 2) {
                try {
                    int macchinaId = Integer.parseInt(parts[1]);
                    MacchinaPrincipale macchina = macchineAttive.get(macchinaId);
                    if (macchina != null) {
                        macchina.pubblicaStatoMacchina();
                    }
                } catch (NumberFormatException e) {
                    logger.error("ID macchina non valido nel topic: {}", topic);
                }
            }
        });

        logger.info("Client MQTT inizializzato e connesso");
    }*/
    private static void initMQTT() throws Exception {
        // Configurazione opzioni MQTT
        MqttConnectOptions options = new MqttConnectOptions();
        options.setCleanSession(true);
        options.setConnectionTimeout(30);
        options.setKeepAliveInterval(60);
        options.setAutomaticReconnect(true);
        options.setUserName(config.getProperty("mqtt.client.username"));
        options.setPassword(config.getProperty("mqtt.client.password").toCharArray());

        // Configurazione SSL
        if (Boolean.parseBoolean(config.getProperty("mqtt.ssl.enabled", "true"))) {
            try {
                String trustStorePath = config.getProperty("mqtt.ssl.truststore");
                String trustStorePassword = config.getProperty("mqtt.ssl.password");
                String trustStoreType = config.getProperty("mqtt.ssl.type", "JKS");

                if (trustStorePath != null && trustStorePassword != null) {
                    System.setProperty("javax.net.ssl.trustStore", trustStorePath);
                    System.setProperty("javax.net.ssl.trustStorePassword", trustStorePassword);
                    System.setProperty("javax.net.ssl.trustStoreType", trustStoreType);

                    Properties sslProperties = new Properties();
                    sslProperties.setProperty("com.ibm.ssl.protocol", "TLSv1.2");
                    options.setSSLProperties(sslProperties);
                } else {
                    logger.warn("SSL enabled but truststore settings not found, using default SSL configuration");
                    options.setSocketFactory(SSLSocketFactory.getDefault());
                }
            } catch (Exception e) {
                logger.error("Error configuring SSL: {}", e.getMessage());
                throw new RuntimeException("Error configuring SSL", e);
            }
        }

        // Configurazione Last Will and Testament (LWT)
        options.setWill("system/server/status", "offline".getBytes(), 1, true);

        // Inizializza e connetti il client MQTT
        mqttClient = new MQTTClient("server");
        mqttClient.connetti(options);

        logger.info("Client MQTT inizializzato e connesso");
    }

    private static void initMacchine() {
        try {
            MacchinaRepository macchinaRepo = ServiceRegistry.get(MacchinaRepository.class);
            var macchine = macchinaRepo.findAll();

            for (Macchina macchina : macchine) {
                try {
                    MacchinaPrincipale macchinaPrincipale = new MacchinaPrincipale(macchina);
                    macchineAttive.put(macchina.getId(), macchinaPrincipale);
                    logger.info("Macchina {} inizializzata con successo", macchina.getId());
                } catch (Exception e) {
                    logger.error("Errore nell'inizializzazione della macchina {}: {}",
                            macchina.getId(), e.getMessage());
                }
            }

            logger.info("Inizializzate {} macchine", macchineAttive.size());
        } catch (Exception e) {
            logger.error("Errore durante l'inizializzazione delle macchine", e);
        }
    }

    private static void setupRoutes() throws MqttException {
        // Middleware per autenticazione e logging
        AuthMiddleware authMiddleware = new AuthMiddleware();
        LogMiddleware logMiddleware = new LogMiddleware();
        CORSMiddleware corsMiddleware = new CORSMiddleware();

        // Controller e servizi
        IstitutoController istitutoController = new IstitutoController(
                ServiceRegistry.get(IstitutoRepository.class),
                ServiceRegistry.get(MacchinaRepository.class)
        );

        MacchinaController macchinaController = new MacchinaController(
                ServiceRegistry.get(MacchinaRepository.class),
                ServiceRegistry.get(BevandaRepository.class)
        );

        AuthController authController = new AuthController(ServiceRegistry.get(AdminLoginService.class),
                ServiceRegistry.get(UtenteService.class)
        );

        ManutenzioneController manutenzioneController = new ManutenzioneController(
                ServiceRegistry.get(ManutenzioneRepository.class)
        );

        BevandaController bevandaController = new BevandaController(
                ServiceRegistry.get(BevandaService.class)
        );
        
        UtenteController utenteController = new UtenteController(
        		ServiceRegistry.get(UtenteRepository.class)
        );
        
        // Register controllers in the ServiceRegistry
        ServiceRegistry.register("istitutoController", istitutoController);
        ServiceRegistry.register("macchinaController", macchinaController);
        ServiceRegistry.register("bevandaController", bevandaController);
        ServiceRegistry.register("manutenzioneController", manutenzioneController);
        ServiceRegistry.register("utenteController", utenteController);

        String base = "/api";
        get("/", (req, res) -> {
            res.redirect("/index.html");
            return null;
        });

        // Configurazione CORS e logging globale
        before((request, response) -> corsMiddleware.applicaCORS(request, response));
        after((request, response) -> logMiddleware.logRequest(request, response));
        
        // Autenticazione
        path("/api/auth", () -> {
            post("/login", authController::login);
            post("/register", authController::registrazione);
            post("/refresh", authController::refreshToken);
            post("/verify", authController::verificaToken);
            post("/anonymous", authController::getAnonymousToken);
        });

        // Root path e redirect alla homepage
        get("/", (req, res) -> {
            res.redirect("/index.html");
            return null;
        });

        // Accesso alle risorse
        get("/api/macchine", ServiceRegistry.get(MacchinaController.class)::getAll);
        get("/api/macchine/:id", ServiceRegistry.get(MacchinaController.class)::getById);
        get("/api/macchine/istituto/:istitutoId", ServiceRegistry.get(MacchinaController.class)::getByIstituto);
        get("/api/macchine/:id/stato", ServiceRegistry.get(MacchinaController.class)::getStatoMacchina);
        get("/api/macchine/:id/bevande", (req, res) -> {
            int macchinaId = Integer.parseInt(req.params(":id"));
            return macchinaController.getBevandeMacchina(macchinaId, res);
        });

        get("/api/istituti", ServiceRegistry.get(IstitutoController.class)::getAll);
        get("/api/istituti/:id", ServiceRegistry.get(IstitutoController.class)::getById);

        get("/api/bevande", bevandaController::getAll);
        get("/api/bevande/:id", bevandaController::getById);
        get("/api/bevande/:id/disponibilita/:macchinaId", (req, res) -> {
            int bevandaId = Integer.parseInt(req.params(":id"));
            int macchinaId = Integer.parseInt(req.params(":macchinaId"));
            return macchinaController.verificaDisponibilitaBevanda(bevandaId, macchinaId, res);
        });

        // Rotte per la gestione del denaro e erogazione bevande
        path("/api/macchine/:id", () -> {
            // Inserimento denaro
            post("/insertMoney", (req, res) -> {
                int macchinaId = Integer.parseInt(req.params(":id"));
                double importo = Double.parseDouble(req.queryParams("importo"));

                // Recupera la macchina e verifica che sia attiva
                Macchina macchina = ServiceRegistry.get(MacchinaRepository.class).findById(macchinaId);
                if (macchina == null) {
                    res.status(404);
                    return gson.toJson(Map.of("error", "Macchina non trovata"));
                }

                if (macchina.getStatoId() != 1) { // 1 = Attiva
                    res.status(400);
                    return gson.toJson(Map.of("error", "Macchina non disponibile"));
                }

                // Crea un'istanza del GestoreCassa per questa macchina
                GestoreCassa gestoreCassa = new GestoreCassa(macchinaId, macchina.getCassaMassima());

                // Tenta di inserire il denaro
                boolean inserimentoRiuscito = gestoreCassa.gestisciInserimentoMoneta(importo);

                if (inserimentoRiuscito) {
                    return gson.toJson(Map.of(
                            "success", true,
                            "message", "Denaro inserito con successo",
                            "creditoAttuale", gestoreCassa.ottieniStato().get("creditoAttuale")
                    ));
                } else {
                    res.status(400);
                    return gson.toJson(Map.of("error", "Impossibile accettare il denaro"));
                }
            });

            // Erogazione bevanda
            post("/erogazione", (req, res) -> {
                int macchinaId = Integer.parseInt(req.params(":id"));
                Map<String, Object> body = gson.fromJson(req.body(), Map.class);
                int bevandaId = ((Number) body.get("bevandaId")).intValue();
                double importo = ((Number) body.get("importo")).doubleValue();

                // Recupera la macchina
                MacchinaPrincipale macchina = macchineAttive.get(macchinaId);
                if (macchina == null) {
                    res.status(404);
                    return gson.toJson(Map.of("error", "Macchina non trovata"));
                }

                // Recupera la bevanda per verificare il prezzo
                BevandaRepository bevandaRepo = ServiceRegistry.get(BevandaRepository.class);
                Optional<Bevanda> bevanda = bevandaRepo.findById(bevandaId);
                if (!bevanda.isPresent()) {
                    res.status(404);
                    return gson.toJson(Map.of("error", "Bevanda non trovata"));
                }

                // Crea la transazione
                TransazioneRepository transazioneRepo = ServiceRegistry.get(TransazioneRepository.class);
                Transazione transazione = new Transazione();
                int idT = transazioneRepo.getLastTransactionId() + 1;
                transazione.setId(idT);
                transazione.setMacchinaId(macchinaId);
                transazione.setBevandaId(bevandaId);
                transazione.setImporto(importo);
                transazione.setDataOra(LocalDateTime.now());

                // Pubblica la richiesta sul topic MQTT appropriato
                String topic = "macchine/" + macchinaId + "/bevande/richiesta";
                Map<String, Object> message = Map.of(
                        "bevandaId", bevandaId,
                        "importo", importo,
                        "timestamp", System.currentTimeMillis(),
                        "transazioneId", transazione.getId()
                );

                try {
                    mqttClient.publish(topic, gson.toJson(message));
                    transazione = transazioneRepo.save(transazione);

                    return gson.toJson(Map.of(
                            "success", true,
                            "message", "Richiesta erogazione inviata",
                            "transazioneId", transazione.getId()
                    ));
                } catch (Exception e) {
                    res.status(500);
                    return gson.toJson(Map.of("error", "Errore durante il salvataggio della transazione: " + e.getMessage()));
                }
            });

            // Annulla inserimento e restituisci credito
            post("/cancelInsert", (req, res) -> {
                int macchinaId = Integer.parseInt(req.params(":id"));

                // Recupera la macchina
                Macchina macchina = ServiceRegistry.get(MacchinaRepository.class).findById(macchinaId);
                if (macchina == null) {
                    res.status(404);
                    return gson.toJson(Map.of("error", "Macchina non trovata"));
                }

                // Crea un'istanza del GestoreCassa
                GestoreCassa gestoreCassa = new GestoreCassa(macchinaId, macchina.getCassaMassima());

                // Gestisci la restituzione del credito
                gestoreCassa.gestisciRestituzioneCredito();

                return gson.toJson(Map.of(
                        "success", true,
                        "message", "Credito restituito"
                ));
            });

            // Verifica stato macchina
            get("/stato", (req, res) -> {
                int macchinaId = Integer.parseInt(req.params(":id"));

                // Recupera la macchina
                MacchinaPrincipale macchina = macchineAttive.get(macchinaId);
                if (macchina == null) {
                    res.status(404);
                    return gson.toJson(Map.of("error", "Macchina non trovata"));
                }

                // Ottieni lo stato completo della macchina
                Map<String, Object> stato = new HashMap<>();
                stato.put("statoMacchina", ServiceRegistry.get(MacchinaRepository.class)
                        .findById(macchinaId));
                stato.put("statoCassa", macchina.gestoreCassa.ottieniStato());
                stato.put("statoBevande", macchina.gestoreBevande.ottieniStato());
                stato.put("statoCialde", macchina.gestoreCialde.ottieniStato());

                return gson.toJson(stato);
            });
        });
        
        // Operazioni admin
        path("/api/admin", () -> {
            before("/*", authMiddleware::autenticazione);
            
            // Gestione Utenti
            path("/utenti", () -> {
                get("", (req, res) -> ServiceRegistry.get(UtenteController.class).getAll(req, res)); //Recuperare tutti gli utenti
                get("/:id", (req, res) -> ServiceRegistry.get(UtenteController.class).getById(req, res)); // Recuperare un utente per ID
                get("/username/:username", (req, res) -> ServiceRegistry.get(UtenteController.class).getByUsername(req, res)); // Recuperare un utente per username
                get("/ruolo/:ruolo", (req, res) -> ServiceRegistry.get(UtenteController.class).getByRuolo(req, res)); //Recuperare utenti per ruolo
                post("", (req, res) -> ServiceRegistry.get(UtenteController.class).create(req, res)); // Creare un nuovo utente
                put("/:id", (req, res) -> ServiceRegistry.get(UtenteController.class).update(req, res)); // Aggiornare un utente
                delete("/:id", (req, res) -> ServiceRegistry.get(UtenteController.class).delete(req, res)); // Eliminare un utente
            });
            
            // Gestione istituti
            post("/istituti", (req, res) -> {
                //authMiddleware.autorizzazioneAdmin(req, res);
                return istitutoController.create(req, res);
            });
            put("/istituti/:id", (req, res) -> {
                authMiddleware.autorizzazioneAdmin(req, res);
                return istitutoController.update(req, res);
            });
            delete("/istituti/:id", (req, res) -> {
                authMiddleware.autorizzazioneAdmin(req, res);
                return istitutoController.delete(req, res);
            });

            // Gestione macchine
            post("/macchine", (req, res) -> {
                authMiddleware.autorizzazioneAdmin(req, res);
                return macchinaController.create(req, res);
            });
            put("/macchine/:id/bevande", (req, res) -> {
                return ServiceRegistry.get(MacchinaController.class).updateBevandeMacchina(req, res);
            });
            put("/macchine/:id/stato", macchinaController::updateStato);
            delete("/macchine/:id", (req, res) -> {
                authMiddleware.autorizzazioneAdmin(req, res);
                return macchinaController.delete(req, res);
            });

            // Gestione bevande
            path("/bevande", () -> {
                post("", (req, res) -> {
                    authMiddleware.autorizzazioneAdmin(req, res);
                    return bevandaController.create(req, res);
                });
                put("/:id", (req, res) -> {
                    authMiddleware.autorizzazioneAdmin(req, res);
                    return bevandaController.update(req, res);
                });
                delete("/:id", (req, res) -> {
                    authMiddleware.autorizzazioneAdmin(req, res);
                    return bevandaController.delete(req, res);
                });
                put("/:id/cialde", (req, res) -> {
                    authMiddleware.autorizzazioneAdmin(req, res);
                    return bevandaController.aggiungiCialda(req, res);
                });
                delete("/:id/cialde/:cialdaId", (req, res) -> {
                    authMiddleware.autorizzazioneAdmin(req, res);
                    return bevandaController.rimuoviCialda(req, res);
                });
            });
        });
        
        // Manutenzioni
        path("/api/manutenzione", () -> {
        	// Verifica autenticazione
        	before("/*", authMiddleware::autenticazione);

        	// Ottieni tutte le manutenzioni
        	get("", (req, res) -> {
        		return manutenzioneController.getManutenzioni(req, res);
        	});

        	// Ottieni manutenzioni per istituto
        	get("/istituto/:istitutoId", (req, res) -> {
        		try {
        			int istitutoId = Integer.parseInt(req.params(":istitutoId"));
        			List<Manutenzione> manutenzioni = (List<Manutenzione>) manutenzioneController.getManutenzioniIstituto(req, res);
        			res.type("application/json");
        			return gson.toJson(manutenzioni);
        		} catch (NumberFormatException e) {
        			res.status(400);
        			return gson.toJson(Map.of("error", "ID istituto non valido"));
        		} catch (Exception e) {
        			res.status(500);
        			return gson.toJson(Map.of("error", "Errore durante il recupero delle manutenzioni per istituto: " + e.getMessage()));
        		}
        	});
        	
        	// Ottieni manutenzioni per tecnico
        	get("/tecnico/:tecnicoId", (req, res) -> {
        		try {
        			int tecnicoId = Integer.parseInt(req.params(":tecnicoId"));
        			List<Manutenzione> manutenzioni = (List<Manutenzione>) manutenzioneController.getManutenzioniTecnico(req, res);
        			res.type("application/json");
        			return gson.toJson(manutenzioni);
        		} catch (NumberFormatException e) {
        			res.status(400);
        			return gson.toJson(Map.of("error", "ID tecnico non valido"));
        		} catch (Exception e) {
        			res.status(500);
        			return gson.toJson(Map.of("error", "Errore durante il recupero delle manutenzioni per tecnico: " + e.getMessage()));
        		}
        	});

        	// Inizia una nuova manutenzione
        	post("", (req, res) -> {
        		try {
        			Map<String, Object> body = gson.fromJson(req.body(), Map.class);
        			int macchinaId = Integer.parseInt(body.get("macchinaId").toString());
        			String tipoIntervento = (String) body.get("tipoIntervento");
        			String descrizione = (String) body.get("descrizione");
        			String urgenza = (String) body.get("urgenza");

        			Manutenzione manutenzione = (Manutenzione) manutenzioneController.iniziaManutenzione(req, res);
        			res.type("application/json");
        			return gson.toJson(manutenzione);
        		} catch (NumberFormatException e) {
        			res.status(400);
        			return gson.toJson(Map.of("error", "ID macchina non valido"));
        		} catch (Exception e) {
        			res.status(500);
        			return gson.toJson(Map.of("error", "Errore durante l'inizio della manutenzione: " + e.getMessage()));
        		}
        	});

        	// Completa una manutenzione esistente
        	put("/:id/completa", (req, res) -> {
        		try {
        			int manutenzioneId = Integer.parseInt(req.params(":id"));
        			Map<String, Object> body = gson.fromJson(req.body(), Map.class);
        			String note = (String) body.get("note");
        			String tecnico = (String) body.get("tecnico");

        			Manutenzione manutenzione = (Manutenzione) manutenzioneController.completaManutenzione(req, res);
        			res.type("application/json");
        			return gson.toJson(manutenzione);
        		} catch (NumberFormatException e) {
        			res.status(400);
        			return gson.toJson(Map.of("error", "ID manutenzione non valido"));
        		} catch (Exception e) {
        			res.status(500);
        			return gson.toJson(Map.of("error", "Errore durante il completamento della manutenzione: " + e.getMessage()));
        		}
        	});

        	// Imposta una manutenzione come fuori servizio
        	put("/:id/fuori-servizio", (req, res) -> {
        		try {
        			int manutenzioneId = Integer.parseInt(req.params(":id"));
        			Manutenzione manutenzione = (Manutenzione) manutenzioneController.setFuoriServizio(req, res);
        			res.type("application/json");
        			return gson.toJson(manutenzione);
        		} catch (NumberFormatException e) {
        			res.status(400);
        			return gson.toJson(Map.of("error", "ID manutenzione non valido"));
        		} catch (Exception e) {
        			res.status(500);
        			return gson.toJson(Map.of("error", "Errore durante l'impostazione della manutenzione come fuori servizio: " + e.getMessage()));
        		}
        	});
        });

        // Setup MQTT topics
        setupMQTTTopics();

        // Rotta per lo spegnimento controllato
        get("/spegni", (req, res) -> {
            logger.info("Richiesta di spegnimento ricevuta");
            new Thread(() -> {
                try {
                    Thread.sleep(1000);
                    shutdown();
                    System.exit(0);
                } catch (InterruptedException e) {
                    logger.error("Errore durante lo spegnimento: {}", e.getMessage());
                }
            }).start();
            res.type("application/json");
            return gson.toJson(Map.of("message", "Spegnimento del sistema in corso...", "status", "success"));
        });

        // Gestione errori
        exception(Exception.class, (e, req, res) -> {
            res.status(500);
            res.type("application/json");
            res.body("{\"errore\": \"" + e.getMessage() + "\"}");
            logMiddleware.logError(req, e);
        });

        notFound((req, res) -> {
            res.type("application/json");
            res.status(404);
            return "{\"errore\": \"Risorsa non trovata\"}";
        });

        internalServerError((req, res) -> {
            res.type("application/json");
            return "{\"errore\": \"Errore interno del server\"}";
        });
    }

    private static void setupMQTTTopics() throws MqttException {

        // Topic per lo stato delle macchine
        mqttClient.subscribe("macchine/+/stato", (topic, message) -> {
            logger.debug("Ricevuto messaggio stato: {} - {}", topic, message);
            ServiceRegistry.get(ManutenzioneService.class).processaMacchinaStato(topic, message);

            String[] parts = topic.split("/");
            if (parts.length >= 2) {
                try {
                    int macchinaId = Integer.parseInt(parts[1]);
                    MacchinaPrincipale macchina = macchineAttive.get(macchinaId);
                    if (macchina != null) {
                        macchina.pubblicaStatoMacchina();
                    }
                } catch (NumberFormatException e) {
                    logger.error("ID macchina non valido nel topic: {}", topic);
                }
            }
        });

        // Topic per le operazioni utente
        mqttClient.subscribe("macchine/+/cassa/#", (topic, message) -> {
            String[] parts = topic.split("/");
            //CHECK PER ZUCCHERO DA FARE
            if (parts.length >= 4) {
                try {
                    int macchinaId = Integer.parseInt(parts[1]);
                    String operazione = parts[3];
                    MacchinaPrincipale macchina = macchineAttive.get(macchinaId);

                    if (macchina != null) {
                        switch (operazione) {
                            case "inserimentoCredito":
                                double importo = Double.parseDouble(message);
                                boolean successo = macchina.gestoreCassa.gestisciInserimentoMoneta(importo);
                                if (successo) {
                                    logger.info("Credito inserito con successo nella macchina {}: {}", macchinaId, importo);
                                } else {
                                    logger.warn("Impossibile inserire credito nella macchina {}: {}", macchinaId, importo);
                                }
                                break;

                            case "richiestaBevanda":
                                int bevandaId = Integer.parseInt(message);
                                macchina.gestisciErogazioneBevanda(bevandaId, 0); // Livello zucchero default
                                logger.info("Richiesta bevanda {} nella macchina {}", bevandaId, macchinaId);
                                break;

                            case "richiestaResto":
                                macchina.gestoreCassa.gestisciRestituzioneCredito();
                                logger.info("Resto richiesto nella macchina {}", macchinaId);
                                break;

                            default:
                                logger.warn("Operazione non riconosciuta: {}", operazione);
                                break;
                        }
                    }
                } catch (Exception e) {
                    logger.error("Errore nell'elaborazione dell'operazione: {}", e.getMessage());
                }
            }
        });

        // Topic per le bevande
        mqttClient.subscribe("macchine/+/bevande/#", (topic, message) -> {
            logger.debug("Ricevuto messaggio bevande: {} - {}", topic, message);
            String[] parts = topic.split("/");
            if (parts.length >= 4) {
                try {
                    int macchinaId = Integer.parseInt(parts[1]);
                    int zucchero = Integer.parseInt(parts[2]);
                    String azione = parts[3];
                    MacchinaPrincipale macchina = macchineAttive.get(macchinaId);

                    if (macchina != null) {
                        switch (azione) {
                            case "aggiorna":
                                // Gestisci l'aggiornamento della bevanda
                                macchina.pubblicaStatoMacchina();
                                break;
                            default:
                                logger.warn("Azione bevanda non riconosciuta: {}", azione);
                                break;
                        }
                    }
                } catch (Exception e) {
                    logger.error("Errore nell'elaborazione della bevanda: {}", e.getMessage());
                }
            }
        });

        // Topic per le cialde
        mqttClient.subscribe("macchine/+/cialde/#", (topic, message) -> {
            logger.debug("Ricevuto messaggio cialde: {} - {}", topic, message);
            String[] parts = topic.split("/");
            if (parts.length >= 4) {
                try {
                    int macchinaId = Integer.parseInt(parts[1]);
                    String azione = parts[3];
                    MacchinaPrincipale macchina = macchineAttive.get(macchinaId);

                    if (macchina != null) {
                        switch (azione) {
                            case "ricarica":
                                // Gestisci la ricarica delle cialde
                                macchina.gestoreCialde.gestisciRicaricaCialde(new GestoreCialde.RichiestaCialde());
                                break;
                            case "verifica":
                                // Verifica lo stato delle cialde
                                macchina.gestoreCialde.verificaStatoCialde();
                                break;
                            default:
                                logger.warn("Azione cialde non riconosciuta: {}", azione);
                                break;
                        }
                    }
                } catch (Exception e) {
                    logger.error("Errore nell'elaborazione delle cialde: {}", e.getMessage());
                }
            }
        });

        // Topic per la manutenzione
        mqttClient.subscribe("macchine/+/manutenzione/#", (topic, message) -> {
            logger.debug("Ricevuto messaggio manutenzione: {} - {}", topic, message);
            String[] parts = topic.split("/");
            if (parts.length >= 4) {
                try {
                    int macchinaId = Integer.parseInt(parts[1]);
                    String azione = parts[3];
                    MacchinaPrincipale macchina = macchineAttive.get(macchinaId);

                    if (macchina != null) {
                        switch (azione) {
                            case "segnalazione":
                                // Gestisci la segnalazione di un problema
                                macchina.gestoreManutenzione.segnalaProblema("tipo_problema", "descrizione_problema", new HashMap<>());
                                break;
                            case "risoluzione":
                                // Gestisci la risoluzione di un problema
                                macchina.gestoreManutenzione.risolviProblema("id_problema", "descrizione_risoluzione", "tecnico");
                                break;
                            case "verifica":
                                // Verifica lo stato della manutenzione
                                macchina.gestoreManutenzione.verificaStato();
                                break;
                            default:
                                logger.warn("Azione manutenzione non riconosciuta: {}", azione);
                                break;
                        }
                    }
                } catch (Exception e) {
                    logger.error("Errore nell'elaborazione della manutenzione: {}", e.getMessage());
                }
            }
        });

        // Topic per gli eventi
        mqttClient.subscribe("macchine/+/eventi", (topic, message) -> {
            logger.debug("Ricevuto evento: {} - {}", topic, message);
            String[] parts = topic.split("/");
            if (parts.length >= 3) {
                try {
                    int macchinaId = Integer.parseInt(parts[1]);
                    MacchinaPrincipale macchina = macchineAttive.get(macchinaId);
                    if (macchina != null) {
                        // Gestisci l'evento
                        logger.debug("Ricevuto evento: {} - {}", topic, message);
                    }
                } catch (NumberFormatException e) {
                    logger.error("ID macchina non valido nel topic: {}", topic);
                }
            }
        });

    }

    private static void openDashboard(String port) {
        try {
            Thread.sleep(1500);
            String url = "http://localhost:" + port + "/index.html";
            String os = System.getProperty("os.name").toLowerCase();

            if (os.contains("win")) {
                Runtime.getRuntime().exec("rundll32 url.dll,FileProtocolHandler " + url);
            } else if (os.contains("mac")) {
                Runtime.getRuntime().exec("open " + url);
            } else if (os.contains("nix") || os.contains("nux")) {
                String[] browsers = {"google-chrome", "firefox", "mozilla", "epiphany",
                    "konqueror", "netscape", "opera", "links", "lynx"};

                StringBuffer cmd = new StringBuffer();
                for (int i = 0; i < browsers.length; i++) {
                    if (i == 0) {
                        cmd.append(String.format("%s \"%s\"", browsers[i], url));
                    } else {
                        cmd.append(String.format(" || %s \"%s\"", browsers[i], url));
                    }
                }

                Runtime.getRuntime().exec(new String[]{"sh", "-c", cmd.toString()});
            }

            logger.info("Dashboard aperta nel browser: {}", url);
        } catch (Exception e) {
            logger.error("Impossibile aprire il browser automaticamente", e);
            logger.info("Per accedere alla dashboard, apri manualmente: http://localhost:{}/index.html", port);
        }
    }

    private static class ErrorResponse {

        private final String message;

        public ErrorResponse(String message) {
            this.message = message;
        }
    }

    public static void shutdown() {
        logger.info("Avvio procedura di spegnimento...");

        macchineAttive.values().forEach(macchina -> {
            try {
                macchina.eseguiSpegnimento();
            } catch (Exception e) {
                logger.error("Errore durante lo spegnimento della macchina", e);
            }
        });

        macchineAttive.clear();

        try {
            if (mqttClient != null) {
                mqttClient.disconnect();
            }
        } catch (Exception e) {
            logger.error("Errore durante la disconnessione del client MQTT", e);
        }

        logger.info("Spegnimento completato");
    }
}

================
File: src/main/java/com/vending/security/auth/AuthenticationService.java
================
package com.vending.security.auth;

import com.vending.core.models.Utente;
import com.vending.security.jwt.JWTService;
import com.vending.core.repositories.UtenteRepository;

public class AuthenticationService {

    private final UtenteRepository utenteRepository;
    private final PasswordService passwordService;
    private final JWTService jwtService;

    public AuthenticationService(UtenteRepository utenteRepository, PasswordService passwordService, JWTService jwtService) {
        this.utenteRepository = utenteRepository;
        this.passwordService = passwordService;
        this.jwtService = jwtService;
    }

    /**
     * Autentica un utente in base a username e password.
     *
     * @param username Il nome utente.
     * @param password La password in chiaro.
     * @return Un token JWT se l'autenticazione ha successo, altrimenti null.
     */
    public String authenticate(String username, String password) {
        if (username == null || username.isEmpty() || password == null || password.isEmpty()) {
            System.out.println("Username o password non validi"); // Log per debug
            return null;
        }

        // Cerca l'utente nel repository
        Utente utente = utenteRepository.findByUsername(username);

        if (utente == null) {
            System.out.println("Utente non trovato"); // Log per debug
            return null;
        }

        // Verifica la password
        if (passwordService.verifyPassword(password, utente.getPasswordHash())) {
            // Genera un token JWT
            return jwtService.generaToken(utente);
        } else {
            System.out.println("Password non valida"); // Log per debug
            return null;
        }
    }

    /**
     * Verifica se un token JWT è valido.
     *
     * @param token Il token JWT da verificare.
     * @return True se il token è valido, altrimenti false.
     */
    public boolean validateToken(String token) {
        if (token == null || token.isEmpty()) {
            System.out.println("Token non valido: nullo o vuoto"); // Log per debug
            return false;
        }

        return jwtService.verificaToken(token);
    }
}

================
File: src/main/java/com/vending/security/auth/AuthorizationException.java
================
package com.vending.security.auth;


public class AuthorizationException extends RuntimeException {
    public AuthorizationException(String message) {
        super(message);
    }
 
    public AuthorizationException(String message, Throwable cause) {
        super(message, cause);
    }
 }

================
File: src/main/java/com/vending/security/auth/AuthorizationService.java
================
package com.vending.security.auth;

import com.vending.core.models.Utente;
import com.vending.security.jwt.JWTService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Servizio che gestisce le autorizzazioni degli utenti nel sistema.
 * Implementa la logica per il controllo dei permessi basati sui ruoli.
 */
public class AuthorizationService {
    private static final Logger logger = LoggerFactory.getLogger(AuthorizationService.class);
    private final JWTService jwtService;
    
    // Costanti per i claims del token
    private static final String ROLE_CLAIM = "role";
    
    // Mappa che associa ogni ruolo alle sue azioni permesse
    private static final Map<String, List<String>> ROLE_PERMISSIONS = new HashMap<>();
    
    static {
        // Permessi per amministratori
        ROLE_PERMISSIONS.put("ADMIN", Arrays.asList(
            "VIEW_SCHOOLS",
            "ADD_SCHOOL",
            "REMOVE_SCHOOL",
            "VIEW_MACHINES",
            "ADD_MACHINE",
            "REMOVE_MACHINE",
            "VIEW_MACHINE_STATUS",
            "SEND_TECHNICIAN",
            "VIEW_REVENUES",
            "MANAGE_USERS"
        ));
        
        // Permessi per impiegati
        ROLE_PERMISSIONS.put("EMPLOYEE", Arrays.asList(
            "VIEW_SCHOOLS",
            "VIEW_MACHINES",
            "VIEW_MACHINE_STATUS",
            "SEND_TECHNICIAN"
        ));
    }

    /**
     * Costruttore del servizio di autorizzazione.
     * 
     * @param jwtService servizio JWT per la validazione dei token
     */
    public AuthorizationService(JWTService jwtService) {
        this.jwtService = jwtService;
    }

    /**
     * Verifica se un utente ha il permesso di eseguire una determinata azione.
     * 
     * @param utente l'utente da verificare
     * @param permission il permesso richiesto
     * @return true se l'utente ha il permesso, false altrimenti
     */
    public boolean hasPermission(Utente utente, String permission) {
        if (utente == null || permission == null) {
            logger.warn("Tentativo di verifica permesso con utente o permesso null");
            return false;
        }

        String ruolo = utente.getRuolo().toUpperCase();
        List<String> permissions = ROLE_PERMISSIONS.get(ruolo);
        
        if (permissions == null) {
            logger.warn("Ruolo non trovato: {}", ruolo);
            return false;
        }

        boolean hasPermission = permissions.contains(permission);
        logger.debug("Verifica permesso '{}' per utente {}: {}", 
                    permission, utente.getUsername(), hasPermission);
        
        return hasPermission;
    }

    /**
     * Verifica se un token JWT è valido e se l'utente associato ha il permesso richiesto.
     * 
     * @param token il token JWT da verificare
     * @param permission il permesso richiesto
     * @return true se il token è valido e l'utente ha il permesso, false altrimenti
     */
    public boolean validateTokenAndPermission(String token, String permission) {
        try {
            if (!jwtService.verificaToken(token)) {
                logger.warn("Token JWT non valido");
                return false;
            }

            String ruolo = jwtService.getRuoloDaToken(token);
            List<String> permissions = ROLE_PERMISSIONS.get(ruolo);
            
            if (permissions == null) {
                logger.warn("Ruolo non trovato nel token: {}", ruolo);
                return false;
            }

            return permissions.contains(permission);
            
        } catch (Exception e) {
            logger.error("Errore durante la validazione del token e permesso", e);
            return false;
        }
    }

    /**
     * Verifica se l'utente ha il ruolo di amministratore.
     * 
     * @param utente l'utente da verificare
     * @return true se l'utente è amministratore, false altrimenti
     */
    public boolean isAdmin(Utente utente) {
        if (utente == null) {
            return false;
        }
        return "ADMIN".equalsIgnoreCase(utente.getRuolo());
    }

    /**
     * Verifica se l'utente ha il ruolo di impiegato.
     * 
     * @param utente l'utente da verificare
     * @return true se l'utente è impiegato, false altrimenti
     */
    public boolean isEmployee(Utente utente) {
        if (utente == null) {
            return false;
        }
        return "EMPLOYEE".equalsIgnoreCase(utente.getRuolo());
    }

    /**
     * Ottiene la lista dei permessi associati a un ruolo specifico.
     * 
     * @param ruolo il ruolo di cui ottenere i permessi
     * @return la lista dei permessi associati al ruolo, o null se il ruolo non esiste
     */
    public List<String> getPermissionsForRole(String ruolo) {
        if (ruolo == null) {
            return null;
        }
        return ROLE_PERMISSIONS.get(ruolo.toUpperCase());
    }

    /**
     * Estrae il ruolo da un token JWT.
     * 
     * @param token il token JWT da cui estrarre il ruolo
     * @return il ruolo dell'utente contenuto nel token
     * @throws Exception se il token non è valido o non contiene il claim del ruolo
     */
    public String getRoleFromToken(String token) throws Exception {
        if (token == null || token.isEmpty()) {
            logger.error("Token nullo o vuoto");
            throw new IllegalArgumentException("Token non può essere nullo o vuoto");
        }

        try {
            // Estraiamo il claim 'role' dal token tramite il JWTService
            String role = jwtService.getClaimFromToken(token, ROLE_CLAIM);
            
            if (role == null || role.isEmpty()) {
                logger.error("Ruolo non trovato nel token");
                throw new Exception("Ruolo non trovato nel token");
            }

            // Verifichiamo che il ruolo sia uno di quelli validi
            if (!ROLE_PERMISSIONS.containsKey(role.toUpperCase())) {
                logger.error("Ruolo non valido trovato nel token: {}", role);
                throw new Exception("Ruolo non valido nel token");
            }

            logger.debug("Ruolo estratto dal token: {}", role);
            return role.toUpperCase();

        } catch (Exception e) {
            logger.error("Errore nell'estrazione del ruolo dal token", e);
            throw new Exception("Errore nell'estrazione del ruolo dal token", e);
        }
    }
}

================
File: src/main/java/com/vending/security/auth/PasswordService.java
================
package com.vending.security.auth;

import org.mindrot.jbcrypt.BCrypt;
import java.util.Objects;

public class PasswordService {

    /**
     * Genera un hash della password utilizzando BCrypt.
     *
     * @param password La password in chiaro da hashare.
     * @return L'hash della password.
     * @throws IllegalArgumentException Se la password è nulla o vuota.
     */
    public String hashPassword(String password) {
        if (password == null || password.isEmpty()) {
            throw new IllegalArgumentException("Password cannot be null or empty");
        }
        // Genera un hash BCrypt con un salt automatico
        String hashedPassword = BCrypt.hashpw(password, BCrypt.gensalt());
        System.out.println("Password hashata: " + hashedPassword); // Log per debug
        return hashedPassword;
    }

    /**
     * Verifica se la password in chiaro corrisponde all'hash memorizzato.
     *
     * @param plainTextPassword La password in chiaro da verificare.
     * @param hashedPassword    L'hash memorizzato della password.
     * @return true se la password è corretta, false altrimenti.
     */
    public boolean verifyPassword(String plainTextPassword, String hashedPassword) {
        if (plainTextPassword == null || plainTextPassword.isEmpty() || hashedPassword == null) {
            System.out.println("Password o hash non validi"); // Log per debug
            return false;
        }

        // Log per debug
        System.out.println("Password in chiaro: " + plainTextPassword);
        System.out.println("Hash memorizzato: " + hashedPassword);

        // Verifica la password utilizzando BCrypt
        boolean isMatch = BCrypt.checkpw(plainTextPassword, hashedPassword);
        System.out.println("Risultato verifica: " + isMatch); // Log per debug

        return isMatch;
    }

    /**
     * Verifica se l'hash memorizzato è un hash BCrypt valido.
     *
     * @param hashedPassword L'hash memorizzato della password.
     * @return true se l'hash è valido, false altrimenti.
     */
    public boolean isHashValid(String hashedPassword) {
        if (hashedPassword == null || hashedPassword.isEmpty()) {
            System.out.println("Hash non valido: nullo o vuoto"); // Log per debug
            return false;
        }

        // Verifica se l'hash inizia con il prefisso di BCrypt ($2a$)
        boolean isValid = hashedPassword.startsWith("$2a$");
        System.out.println("Hash valido (BCrypt)? " + isValid); // Log per debug

        return isValid;
    }
}

================
File: src/main/java/com/vending/security/config/SecurityConfig.java
================
package com.vending.security.config;

public class SecurityConfig {
    // JWT Configuration
    public static final String JWT_SECRET = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJQcm9nZXR0byBQaXNzaXIiLCJuYW1lIjoiRWRvYXJkbyBHaW92YW5uaSBGcmFjY2hpYSIsIm1hdHJpY29sYSI6MjAwMTkzMDl9.V-9vaUbsee7Oc8gg7sdqfQEcqfhHxkRxW0QqopkLTlQ";
    public static final long JWT_EXPIRATION = 864_000_000; // 10 giorni
    
    // Password Configuration
    public static final int SALT_LENGTH = 16;
    public static final int HASH_ITERATIONS = 10000;
    public static final int KEY_LENGTH = 256;
    
    // MQTT Security
    public static final String MQTT_USERNAME = "20019309";
    public static final String MQTT_PASSWORD = "Pissir2024!";
    public static final boolean MQTT_REQUIRE_SSL = true;
    
    // API Security
    public static final String[] PUBLIC_ENDPOINTS = {
        // Pagine HTML pubbliche
        "/pages/client/machineSelection.html",
        "/pages/client/beverageInterface.html",
        
        // Endpoint API pubblici per le pagine client
        "/api/macchine",                    // GET - Lista di tutte le macchine
        "/api/macchine/*",                  // GET - Dettagli singola macchina
        "/api/macchine/*/stato",            // GET - Stato macchina
        "/api/macchine/istituto/*",         // GET - Macchine per istituto
        "/api/bevande",                     // GET - Lista bevande
        "/api/bevande/*",                   // GET - Dettagli bevanda
        "/api/istituti",                    // GET - Lista istituti
        "/api/istituti/*",                  // GET - Dettagli istituto
        
        // Endpoint per transazioni
        "/api/macchine/*/erogazione",       // POST - Erogazione bevanda
        "/api/macchine/*/credito",          // POST - Gestione credito
        
        // Endpoint di autenticazione
        "/api/auth/login",
        "/api/auth/register"
    };
    
    public static final String[] ADMIN_ENDPOINTS = {
        // Endpoint riservati agli amministratori
        "/api/admin/*",
        "/api/istituti/create",
        "/api/istituti/delete/*",
        "/api/macchine/create",
        "/api/macchine/delete/*",
        "/api/bevande/create",
        "/api/bevande/delete/*",
        "/api/manutenzione/*"
    };
}

================
File: src/main/java/com/vending/security/encryption/EncryptionService.java
================
package com.vending.security.encryption;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import java.security.SecureRandom;
import java.util.Base64;

public class EncryptionService {
    private final SecretKey chiave;
    private final SecureRandom random;

    public EncryptionService() throws Exception {
        KeyGenerator keyGen = KeyGenerator.getInstance("AES");
        keyGen.init(256);
        this.chiave = keyGen.generateKey();
        this.random = new SecureRandom();
    }

    public String cripta(String testo) {
        try {
            byte[] iv = generaIV();
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(Cipher.ENCRYPT_MODE, chiave, new IvParameterSpec(iv));
            
            byte[] testoEncoded = testo.getBytes();
            byte[] testoCifrato = cipher.doFinal(testoEncoded);
            
            byte[] risultato = new byte[iv.length + testoCifrato.length];
            System.arraycopy(iv, 0, risultato, 0, iv.length);
            System.arraycopy(testoCifrato, 0, risultato, iv.length, testoCifrato.length);
            
            return Base64.getEncoder().encodeToString(risultato);
        } catch (Exception e) {
            throw new RuntimeException("Errore durante la cifratura", e);
        }
    }

    public String decripta(String testoCifrato) {
        try {
            byte[] decodedData = Base64.getDecoder().decode(testoCifrato);
            
            byte[] iv = new byte[16];
            byte[] message = new byte[decodedData.length - 16];
            
            System.arraycopy(decodedData, 0, iv, 0, 16);
            System.arraycopy(decodedData, 16, message, 0, message.length);
            
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(Cipher.DECRYPT_MODE, chiave, new IvParameterSpec(iv));
            
            byte[] decrypted = cipher.doFinal(message);
            return new String(decrypted);
        } catch (Exception e) {
            throw new RuntimeException("Errore durante la decifratura", e);
        }
    }

    private byte[] generaIV() {
        byte[] iv = new byte[16];
        random.nextBytes(iv);
        return iv;
    }
}

================
File: src/main/java/com/vending/security/jwt/JWTService.java
================
package com.vending.security.jwt;

import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.vending.core.models.Utente;
import com.vending.security.config.SecurityConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.Date;
import java.util.Map;

/**
 * Servizio per la gestione dei token JWT (JSON Web Token).
 * Gestisce la creazione, verifica e decodifica dei token di autenticazione.
 */
public class JWTService {
    private static final Logger logger = LoggerFactory.getLogger(JWTService.class);
    private final Algorithm algorithm;
    private static final Algorithm algo = Algorithm.HMAC256("Pissir2025!");

    /**
     * Costruttore che inizializza l'algoritmo di firma JWT usando la chiave segreta configurata.
     */
    public JWTService() {
        this.algorithm = Algorithm.HMAC256(SecurityConfig.JWT_SECRET);
    }

    /**
     * Genera un nuovo token JWT per l'utente specificato.
     *
     * @param utente l'utente per cui generare il token
     * @return il token JWT generato
     */
    public String generaToken(Utente utente) {
        try {
            return JWT.create()
                    .withSubject(String.valueOf(utente.getId()))
                    .withClaim("username", utente.getUsername())
                    .withClaim("roleKey", utente.getRuolo())
                    .withIssuedAt(new Date())
                    .withExpiresAt(new Date(System.currentTimeMillis() + SecurityConfig.JWT_EXPIRATION))
                    .sign(algorithm);
        } catch (Exception e) {
            logger.error("Errore durante la generazione del token JWT", e);
            throw new RuntimeException("Impossibile generare il token JWT", e);
        }
    }
    
    public static String generateAnonymousToken(Map<String, Object> tokenData) {
    	int randomNum = (int) (200 * Math.random() * 1000); 
    	
        try {
            return JWT.create()
                .withSubject(Integer.toString(randomNum))
                .withClaim("username", "cliente_" + randomNum)
                .withClaim("roleKey", "anonymous")
                .withIssuedAt(new Date())
                .withExpiresAt(new Date(System.currentTimeMillis() + (24 * 60 * 60 * 1000))) // 24 hours
                .sign(algo);
        } catch (Exception e) {
            throw new RuntimeException("Error generating anonymous JWT token", e);
        }
    }

    /**
     * Verifica la validità di un token JWT.
     *
     * @param token il token da verificare
     * @return true se il token è valido, false altrimenti
     */
    public boolean verificaToken(String token) {
        if (token == null || token.isEmpty()) {
            return false;
        }
        
        try {
            JWT.require(algorithm)
               .build()
               .verify(token);
            return true;
        } catch (JWTVerificationException e) {
            logger.warn("Token JWT non valido: {}", e.getMessage());
            return false;
        }
    }

    /**
     * Estrae il ruolo dell'utente dal token JWT.
     *
     * @param token il token da cui estrarre il ruolo
     * @return il ruolo dell'utente
     * @throws JWTVerificationException se il token non è valido
     */
    public String getRuoloDaToken(String token) {
        try {
            DecodedJWT jwt = decodificaToken(token);
            return jwt.getClaim("roleKey").asString();
        } catch (Exception e) {
            logger.error("Errore nell'estrazione del ruolo dal token", e);
            throw new JWTVerificationException("Impossibile estrarre il ruolo dal token", e);
        }
    }

    /**
     * Estrae l'ID dell'utente dal token JWT.
     *
     * @param token il token da cui estrarre l'ID
     * @return l'ID dell'utente
     * @throws JWTVerificationException se il token non è valido
     */
    public int getUtenteIdDaToken(String token) {
        try {
            DecodedJWT jwt = decodificaToken(token);
            return Integer.parseInt(jwt.getSubject());
        } catch (Exception e) {
            logger.error("Errore nell'estrazione dell'ID utente dal token", e);
            throw new JWTVerificationException("Impossibile estrarre l'ID utente dal token", e);
        }
    }

    /**
     * Estrae l'username dell'utente dal token JWT.
     *
     * @param token il token da cui estrarre l'username
     * @return l'username dell'utente
     * @throws JWTVerificationException se il token non è valido
     */
    public String getUsernameDaToken(String token) {
        try {
            DecodedJWT jwt = decodificaToken(token);
            return jwt.getClaim("username").asString();
        } catch (Exception e) {
            logger.error("Errore nell'estrazione dell'username dal token", e);
            throw new JWTVerificationException("Impossibile estrarre l'username dal token", e);
        }
    }

    /**
     * Verifica se un token JWT è scaduto.
     *
     * @param token il token da verificare
     * @return true se il token è scaduto, false altrimenti
     */
    public boolean isTokenScaduto(String token) {
        try {
            DecodedJWT jwt = decodificaToken(token);
            return jwt.getExpiresAt().before(new Date());
        } catch (Exception e) {
            logger.error("Errore nella verifica della scadenza del token", e);
            return true;
        }
    }

    /**
     * Estrae un claim specifico dal token JWT.
     *
     * @param token il token da cui estrarre il claim
     * @param claimName il nome del claim da estrarre
     * @return il valore del claim come stringa
     * @throws JWTVerificationException se il token non è valido o il claim non esiste
     */
    public String getClaimFromToken(String token, String claimName) {
        try {
            DecodedJWT jwt = decodificaToken(token);
            String claim = jwt.getClaim(claimName).asString();
            if (claim == null) {
                throw new JWTVerificationException("Claim " + claimName + " non trovato nel token");
            }
            return claim;
        } catch (Exception e) {
            logger.error("Errore nell'estrazione del claim {} dal token", claimName, e);
            throw new JWTVerificationException("Impossibile estrarre il claim dal token", e);
        }
    }

    /**
     * Decodifica un token JWT.
     *
     * @param token il token da decodificare
     * @return il token decodificato
     * @throws JWTVerificationException se il token non è valido
     */
    private DecodedJWT decodificaToken(String token) {
        try {
            return JWT.require(algorithm)
                     .build()
                     .verify(token);
        } catch (Exception e) {
            logger.error("Errore nella decodifica del token JWT", e);
            throw new JWTVerificationException("Token non valido", e);
        }
    }
}

================
File: src/main/java/com/vending/security/JWTUtil.java
================
package com.vending.security;

import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.vending.core.models.Utente;
import java.util.Date;
import java.util.Map;

public class JWTUtil {
    private static final String SECRET = "Pissir2025!";
    private static final long EXPIRATION_TIME = 864_000_000; // 10 days
    private final Algorithm algorithm;
    private static final Algorithm algo = Algorithm.HMAC256(SECRET);

    public JWTUtil() {
        this.algorithm = Algorithm.HMAC256(SECRET);
    }

    public String generateToken(Utente utente) {
        return JWT.create()
                .withSubject(String.valueOf(utente.getId()))
                .withClaim("role", utente.getRuolo())
                .withIssuedAt(new Date())
                .withExpiresAt(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
                .sign(algorithm);
    }

    public boolean validateToken(String token) {
        try {
            JWT.require(algorithm).build().verify(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
    
   

    public String getRoleFromToken(String token) {
        DecodedJWT jwt = JWT.require(algorithm).build().verify(token);
        return jwt.getClaim("role").asString();
    }
}

================
File: src/main/java/com/vending/security/PasswordUtil.java
================
package com.vending.security;

import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.util.Base64;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;

import org.mindrot.jbcrypt.BCrypt;

public class PasswordUtil {
    public String hashPassword(String plainTextPassword) {
        return BCrypt.hashpw(plainTextPassword, BCrypt.gensalt());
    }

    public boolean verifyPassword(String plainTextPassword, String hashedPassword) {
        return BCrypt.checkpw(plainTextPassword, hashedPassword);
    }
    
     public boolean verificaPassword(String password, String passwordUtente) {
       try {
           String[] parts = passwordUtente.split(":");
           byte[] salt = Base64.getDecoder().decode(parts[0]);
           byte[] hashSalvato = Base64.getDecoder().decode(parts[1]);
           byte[] hashCalcolato = generaHash(password.toCharArray(), salt);
           
           return comparaHash(hashSalvato, hashCalcolato);
       } catch (Exception e) {
           throw new RuntimeException("Errore verifica password", e);
       }
   }

   private byte[] generaHash(char[] password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {
       PBEKeySpec spec = new PBEKeySpec(password, salt, 10000, 256);
       SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
       return factory.generateSecret(spec).getEncoded();
   }

   private boolean comparaHash(byte[] hash1, byte[] hash2) {
       if (hash1.length != hash2.length) return false;
       int diff = 0;
       for (int i = 0; i < hash1.length; i++) {
           diff |= hash1[i] ^ hash2[i];
       }
       return diff == 0;
   }
}

================
File: src/main/java/com/vending/ServiceRegistry.java
================
package com.vending;

import java.util.HashMap;
import java.util.Map;

/**
 * Registry per i servizi dell'applicazione
 */
public class ServiceRegistry {
    private static final Map<String, Object> services = new HashMap<>();

    public static void register(String name, Object service) {
        services.put(name, service);
    }

    public static <T> T get(Class<T> serviceClass) {
        return services.values().stream()
                .filter(service -> serviceClass.isInstance(service))
                .map(serviceClass::cast)
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Service not found: " + serviceClass.getName()));
    }

    public static Object get(String name) {
        return services.get(name);
    }
}

================
File: src/main/java/com/vending/utils/config/ConfigUtil.java
================
package com.vending.utils.config;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Utility class per la gestione della configurazione dell'applicazione.
 */
public class ConfigUtil {
    private static final Logger logger = LoggerFactory.getLogger(ConfigUtil.class);

    /**
     * Carica le proprietà da un file di configurazione.
     * Cerca prima nel classpath, poi nella directory corrente.
     *
     * @param filename il nome del file di configurazione
     * @return Properties oggetto contenente le proprietà caricate
     * @throws RuntimeException se il file non può essere caricato
     */
    public static Properties loadProperties(String filename) {
        Properties properties = new Properties();
        boolean loaded = false;

        // Prima prova a caricare dal classpath
        try (InputStream input = ConfigUtil.class.getClassLoader().getResourceAsStream(filename)) {
            if (input != null) {
                properties.load(input);
                loaded = true;
                logger.info("Configurazione caricata dal classpath: {}", filename);
            }
        } catch (IOException e) {
            logger.warn("Impossibile caricare la configurazione dal classpath: {}", e.getMessage());
        }

        // Se non trovato nel classpath, prova nella directory corrente
        if (!loaded) {
            try (FileInputStream input = new FileInputStream(filename)) {
                properties.load(input);
                logger.info("Configurazione caricata dal filesystem: {}", filename);
            } catch (IOException e) {
                logger.error("Impossibile caricare il file di configurazione: {}", filename, e);
                throw new RuntimeException("Impossibile caricare il file di configurazione: " + filename, e);
            }
        }

        // Logga le proprietà caricate (escludendo le password)
        logProperties(properties);

        return properties;
    }

    /**
     * Logga le proprietà caricate, mascherando le informazioni sensibili.
     *
     * @param properties le proprietà da loggare
     */
    private static void logProperties(Properties properties) {
        if (logger.isDebugEnabled()) {
            properties.stringPropertyNames().stream()
                .sorted()
                .forEach(key -> {
                    String value = properties.getProperty(key);
                    // Maschera le password e altre informazioni sensibili
                    if (key.toLowerCase().contains("password") || 
                        key.toLowerCase().contains("secret") ||
                        key.toLowerCase().contains("key")) {
                        value = "********";
                    }
                    logger.debug("{}={}", key, value);
                });
        }
    }

    /**
     * Ottiene una proprietà come stringa, con valore di default.
     *
     * @param properties le proprietà
     * @param key la chiave della proprietà
     * @param defaultValue il valore di default
     * @return il valore della proprietà o il default se non trovata
     */
    public static String getProperty(Properties properties, String key, String defaultValue) {
        String value = properties.getProperty(key);
        if (value == null) {
            logger.debug("Proprietà {} non trovata, uso il default: {}", key, defaultValue);
            return defaultValue;
        }
        return value;
    }

    /**
     * Ottiene una proprietà come intero, con valore di default.
     *
     * @param properties le proprietà
     * @param key la chiave della proprietà
     * @param defaultValue il valore di default
     * @return il valore della proprietà come intero o il default se non trovata/non valida
     */
    public static int getIntProperty(Properties properties, String key, int defaultValue) {
        String value = properties.getProperty(key);
        if (value == null) {
            logger.debug("Proprietà {} non trovata, uso il default: {}", key, defaultValue);
            return defaultValue;
        }
        try {
            return Integer.parseInt(value.trim());
        } catch (NumberFormatException e) {
            logger.warn("Valore non valido per {}: {}, uso il default: {}", key, value, defaultValue);
            return defaultValue;
        }
    }

    /**
     * Ottiene una proprietà come boolean, con valore di default.
     *
     * @param properties le proprietà
     * @param key la chiave della proprietà
     * @param defaultValue il valore di default
     * @return il valore della proprietà come boolean o il default se non trovata
     */
    public static boolean getBooleanProperty(Properties properties, String key, boolean defaultValue) {
        String value = properties.getProperty(key);
        if (value == null) {
            logger.debug("Proprietà {} non trovata, uso il default: {}", key, defaultValue);
            return defaultValue;
        }
        return Boolean.parseBoolean(value.trim());
    }
}

================
File: src/main/java/com/vending/utils/date/DateUtil.java
================
package com.vending.utils.date;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;
import java.util.Date;

public class DateUtil {
    public static final DateTimeFormatter FORMATTER = 
        DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    
    private static final ZoneId DEFAULT_ZONE = ZoneId.systemDefault();

    public static String formattaDateTime(LocalDateTime dateTime) {
        return dateTime.format(FORMATTER);
    }
    public static DateTimeFormatter getFormatter() {
        return FORMATTER;
    }
    public static LocalDateTime parseDateTime(String dateTime) {
        return LocalDateTime.parse(dateTime, FORMATTER);
    }

    public static Date localDateTimeToDate(LocalDateTime localDateTime) {
        return Date.from(localDateTime.atZone(DEFAULT_ZONE).toInstant());
    }

    public static LocalDateTime dateToLocalDateTime(Date date) {
        return LocalDateTime.ofInstant(date.toInstant(), DEFAULT_ZONE);
    }

    public static boolean isScaduto(LocalDateTime dateTime) {
        return dateTime.isBefore(LocalDateTime.now());
    }

    public static long getDifferenzaGiorni(LocalDateTime data1, LocalDateTime data2) {
        return ChronoUnit.DAYS.between(data1, data2);
    }

    public static LocalDateTime inizioGiornata(LocalDateTime dateTime) {
        return dateTime.toLocalDate().atStartOfDay();
    }

    public static LocalDateTime fineGiornata(LocalDateTime dateTime) {
        return dateTime.toLocalDate().atTime(23, 59, 59);
    }
}

================
File: src/main/java/com/vending/utils/date/LocalDateTimeTypeAdapter.java
================
package com.vending.utils.date;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class LocalDateTimeTypeAdapter extends TypeAdapter<LocalDateTime> {
    // Formato italiano: giorno/mese/anno ore:minuti:secondi
    private final DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss");

    @Override
    public void write(JsonWriter out, LocalDateTime value) throws IOException {
        if (value == null) {
            out.nullValue();
        } else {
            out.value(formatter.format(value)); 
        }
    }

    @Override
    public LocalDateTime read(JsonReader in) throws IOException {
        if (in.peek() == null) {
            return null;
        }
        String dateTimeString = in.nextString();
        return LocalDateTime.parse(dateTimeString, formatter); 
    }
}

================
File: src/main/java/com/vending/utils/log/LogUtil.java
================
package com.vending.utils.log;

import java.io.*;
import java.time.LocalDateTime;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

import com.vending.utils.date.DateUtil;

public class LogUtil {
    private static final String LOG_DIR = "logs";
    private static final BlockingQueue<LogEntry> logQueue = new LinkedBlockingQueue<>();
    private static final Thread loggerThread;
    private static volatile boolean isRunning = true;

    static {
        // Crea directory logs se non esiste
        new File(LOG_DIR).mkdirs();

        // Inizializza thread di logging
        loggerThread = new Thread(() -> {
            while (isRunning || !logQueue.isEmpty()) {
                try {
                    LogEntry entry = logQueue.poll(100, TimeUnit.MILLISECONDS);
                    if (entry != null) {
                        scriviLog(entry);
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        });
        loggerThread.setDaemon(true);
        loggerThread.start();
    }

    public static void info(String message) {
        aggiungiLog(new LogEntry(LogLevel.INFO, message));
    }

    public static void warning(String message) {
        aggiungiLog(new LogEntry(LogLevel.WARNING, message));
    }

    public static void error(String message, Throwable throwable) {
        StringBuilder sb = new StringBuilder();
        sb.append(message).append("\n");
        sb.append("Exception: ").append(throwable.getMessage()).append("\n");
        for (StackTraceElement element : throwable.getStackTrace()) {
            sb.append("\tat ").append(element.toString()).append("\n");
        }
        aggiungiLog(new LogEntry(LogLevel.ERROR, sb.toString()));
    }

    public static void debug(String message) {
        aggiungiLog(new LogEntry(LogLevel.DEBUG, message));
    }

    private static void aggiungiLog(LogEntry entry) {
        try {
            logQueue.put(entry);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    private static void scriviLog(LogEntry entry) {
        String nomeFile = LOG_DIR + File.separator + 
            LocalDateTime.now().toLocalDate() + ".log";
            
        try (PrintWriter writer = new PrintWriter(new FileWriter(nomeFile, true))) {
            writer.println(entry.toString());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void shutdown() {
        isRunning = false;
        loggerThread.interrupt();
        try {
            loggerThread.join(5000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    private static class LogEntry {
        private final LogLevel level;
        private final String message;
        private final LocalDateTime timestamp;

        public LogEntry(LogLevel level, String message) {
            this.level = level;
            this.message = message;
            this.timestamp = LocalDateTime.now();
        }

        @Override
        public String toString() {
            return String.format("[%s] %s - %s",
                timestamp.format(DateUtil.FORMATTER),
                level,
                message);
        }
    }

    private enum LogLevel {
        DEBUG, INFO, WARNING, ERROR
    }
}

================
File: src/main/java/com/vending/utils/money/MoneyUtil.java
================
package com.vending.utils.money;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.text.NumberFormat;
import java.util.Locale;
import java.util.Currency;

public class MoneyUtil {
    private static final Currency EUR = Currency.getInstance("EUR");
    private static final NumberFormat FORMATTER = NumberFormat.getCurrencyInstance(Locale.ITALY);
    private static final double[] MONETE_VALIDE = {0.05, 0.10, 0.20, 0.50, 1.00, 2.00};

    public static BigDecimal arrotondaDueDecimali(BigDecimal importo) {
        return importo.setScale(2, RoundingMode.HALF_UP);
    }

    public static String formattaValuta(BigDecimal importo) {
        return FORMATTER.format(importo);
    }

    public static BigDecimal parseImporto(String importo) {
        try {
            String cleaned = importo.replace(EUR.getSymbol(), "")
                                  .replace(".", "")
                                  .replace(",", ".");
            return new BigDecimal(cleaned).setScale(2, RoundingMode.HALF_UP);
        } catch (Exception e) {
            throw new IllegalArgumentException("Formato importo non valido");
        }
    }

    public static boolean isMonetaValida(double importo) {
        for (double moneta : MONETE_VALIDE) {
            if (Math.abs(importo - moneta) < 0.001) {
                return true;
            }
        }
        return false;
    }

    public static BigDecimal calcolaResto(BigDecimal importoPagato, BigDecimal importoDovuto) {
        if (importoPagato.compareTo(importoDovuto) < 0) {
            throw new IllegalArgumentException("Importo pagato insufficiente");
        }
        return arrotondaDueDecimali(importoPagato.subtract(importoDovuto));
    }
}

================
File: src/main/java/com/vending/utils/validation/ValidationUtil.java
================
package com.vending.utils.validation;

import java.util.regex.Pattern;
import java.math.BigDecimal;

public class ValidationUtil {
    private static final Pattern EMAIL_PATTERN = Pattern.compile(
        "^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,6}$", 
        Pattern.CASE_INSENSITIVE
    );
    
    private static final Pattern PHONE_PATTERN = Pattern.compile(
        "^\\+?[0-9]{10,13}$"
    );

    private static final Pattern PASSWORD_PATTERN = Pattern.compile(
        "^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&+=])(?=\\S+$).{8,}$"
    );

    public static boolean isValidEmail(String email) {
        return email != null && EMAIL_PATTERN.matcher(email).matches();
    }

    public static boolean isValidPhone(String phone) {
        return phone != null && PHONE_PATTERN.matcher(phone).matches();
    }

    public static boolean isValidPassword(String password) {
        return password != null && PASSWORD_PATTERN.matcher(password).matches();
    }

    public static boolean isValidImporto(BigDecimal importo) {
        return importo != null && importo.compareTo(BigDecimal.ZERO) > 0 
            && importo.scale() <= 2;
    }

    public static boolean isValidQuantita(int quantita) {
        return quantita >= 0;
    }

    public static boolean isValidPercentuale(double percentuale) {
        return percentuale >= 0 && percentuale <= 100;
    }

    public static String sanitizeInput(String input) {
        if (input == null) return null;
        // Rimuove caratteri pericolosi e XSS
        return input.replaceAll("[<>\"'%;()&+]", "");
    }

    public static String normalizeString(String input) {
        if (input == null) return null;
        return input.trim().toLowerCase();
    }
}

================
File: src/main/resources/config.properties
================
# Configurazioni Server
server.port=8080
server.host=0.0.0.0
server.context-path=/api
server.ssl.enabled=true
server.ssl.key-store=keystore.p12
server.ssl.key-store-password=Pissir2024Keystore!
server.ssl.key-store-type=PKCS12

# Database
db.url=jdbc:mysql://localhost:3306/pissir
db.username=root
db.password=Pissir2024!
db.driver=com.mysql.cj.jdbc.Driver
db.pool.initial=5
db.pool.min=5
db.pool.max=20

# MQTT Broker
mqtt.broker.url=tcp://localhost:8883
mqtt.client.username=20019309
mqtt.client.password=Pissir2024!
mqtt.client.clean.session=true
mqtt.client.connection.timeout=10
mqtt.client.keep-alive=60

# SSL Configuration
mqtt.ssl.enabled=true
mqtt.ssl.truststore="C:/mosquitto/certs/mosquitto.jks"
mqtt.ssl.password=mosquitto
mqtt.ssl.type=JKS

# JWT Security
jwt.secret=LGzxTfE1ANOl8OOQjKlJ6wNI1g7MxCwz
jwt.expiration=3600000
jwt.issuer=20019309

# Logging
logging.level.root=INFO
logging.level.com.vending=DEBUG
logging.file.path=/var/log/vending
logging.file.name=vending-service.log
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
logging.pattern.console=%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n

# Cache
cache.type=caffeine
cache.spec=maximumSize=500,expireAfterWrite=30m

# Gestione Macchine
macchine.cassa.max-default=1000.00
macchine.cialde.max-default=100
macchine.threshold.cassa=0.9
macchine.threshold.cialde=0.2

# # Email Notifications
# mail.smtp.host=smtp.gmail.com
# mail.smtp.port=587
# mail.username=your_email@gmail.com
# mail.password=your_email_password
# mail.from=noreply@vendingsystem.com
# mail.enable.ssl=true

# Monitoring
management.endpoints.web.exposure.include=health,metrics,prometheus
management.endpoint.health.show-details=always
management.metrics.tags.application=vending-service

# # Cross-Origin Resource Sharing (CORS)
# cors.allowed-origins=http://localhost:3000,https://your-domain.com
# cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
# cors.allowed-headers=Authorization,Content-Type
# cors.max-age=3600


# Async Executor
async.core-pool-size=2
async.max-pool-size=5
async.queue-capacity=10

================
File: src/main/resources/public/css/admin.css
================
/* admin.css - Stili per l'area amministrativa */

/* Layout admin */
.admin-container {
    display: grid;
    grid-template-columns: 280px 1fr;
    min-height: 100vh;
}

/* Sidebar */
.side-nav {
    background-color: var(--background);
    border-right: 1px solid var(--border-color);
    padding: var(--spacing-md);
    height: 100vh;
    position: fixed;
    width: 280px;
    overflow-y: auto;
    transition: transform 0.3s ease;
}

.nav-section {
    margin-bottom: var(--spacing-xl);
}

.nav-section h3 {
    font-size: 0.875rem;
    text-transform: uppercase;
    color: var(--text-light);
    margin: var(--spacing-md) 0 var(--spacing-sm);
    padding-left: var(--spacing-sm);
}

.nav-item {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    padding: var(--spacing-sm) var(--spacing-md);
    color: var(--text-secondary);
    border-radius: var(--radius-md);
    transition: all 0.2s;
    margin-bottom: var(--spacing-xs);
}

.nav-item:hover {
    background-color: var(--background-alt);
    color: var(--text-primary);
}

.nav-item.active {
    background-color: var(--primary-color);
    color: white;
}

/* Dashboard Stats */
.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    gap: var(--spacing-md);
    margin-bottom: var(--spacing-xl);
}
/* Stats Cards */
.stat-card {
    background-color: var(--background);
    border-radius: var(--radius-lg);
    padding: var(--spacing-lg);
    display: flex;
    align-items: center;
    gap: var(--spacing-lg);
    box-shadow: var(--shadow-sm);
    transition: transform 0.2s ease;
}

.stat-card:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
}

.stat-icon {
    width: 48px;
    height: 48px;
    border-radius: var(--radius-lg);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
}

.stat-icon.active {
    background-color: rgba(16, 185, 129, 0.1);
    color: var(--success-color);
}

.stat-icon.warning {
    background-color: rgba(245, 158, 11, 0.1);
    color: var(--warning-color);
}

.stat-icon.danger {
    background-color: rgba(239, 68, 68, 0.1);
    color: var(--danger-color);
}

.stat-icon.info {
    background-color: rgba(59, 130, 246, 0.1);
    color: var(--info-color);
}

.stat-info {
    flex: 1;
}

.stat-value {
    font-size: 1.5rem;
    font-weight: 600;
    line-height: 1;
    display: block;
    margin-bottom: 0.25rem;
}

.stat-label {
    font-size: 0.875rem;
    color: var(--text-secondary);
}

.stat-trend {
    font-size: 0.875rem;
    display: flex;
    align-items: center;
    gap: 0.25rem;
}

.stat-trend.positive {
    color: var(--success-color);
}

.stat-trend.negative {
    color: var(--danger-color);
}

/* Dashboard Grid */
.dashboard-grid {
    display: grid;
    grid-template-columns: 2fr 1fr;
    gap: var(--spacing-lg);
    margin-bottom: var(--spacing-xl);
}

.dashboard-card {
    background-color: var(--background);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-sm);
    height: 400px;
    display: flex;
    flex-direction: column;
}

.dashboard-card .card-header {
    padding: var(--spacing-lg);
    border-bottom: 1px solid var(--border-color);
}

.dashboard-card .card-body {
    flex: 1;
    padding: var(--spacing-lg);
    overflow: auto;
}

/* Machine Status List */
.status-list {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-sm);
}

.status-item {
    display: flex;
    align-items: center;
    padding: var(--spacing-md);
    background-color: var(--background-alt);
    border-radius: var(--radius-md);
    gap: var(--spacing-md);
}

.status-item-icon {
    width: 40px;
    height: 40px;
    border-radius: var(--radius-md);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.25rem;
}

.status-item-info {
    flex: 1;
}

.status-item-title {
    font-weight: 500;
    margin-bottom: 0.25rem;
}

.status-item-subtitle {
    font-size: 0.875rem;
    color: var(--text-secondary);
}

/* Alerts Section */
.alerts-section {
    background-color: var(--background);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-sm);
    padding: var(--spacing-lg);
}

.alerts-list {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-md);
}

.alert-item {
    display: flex;
    align-items: flex-start;
    gap: var(--spacing-md);
    padding: var(--spacing-md);
    background-color: var(--background-alt);
    border-radius: var(--radius-md);
}

.alert-icon {
    width: 32px;
    height: 32px;
    border-radius: var(--radius-full);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1rem;
    flex-shrink: 0;
}

.alert-info {
    flex: 1;
}

.alert-title {
    font-weight: 500;
    margin-bottom: 0.25rem;
}

.alert-message {
    color: var(--text-secondary);
    font-size: 0.875rem;
}

.alert-time {
    font-size: 0.75rem;
    color: var(--text-light);
}

/* User Menu */
.user-menu {
    position: relative;
}

.user-menu-btn {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    padding: var(--spacing-sm) var(--spacing-md);
    background: none;
    border: none;
    cursor: pointer;
    border-radius: var(--radius-md);
    transition: background-color 0.2s;
}

.user-menu-btn:hover {
    background-color: var(--background-alt);
}

.user-avatar {
    width: 32px;
    height: 32px;
    border-radius: var(--radius-full);
    object-fit: cover;
}

.user-dropdown {
    position: absolute;
    top: 100%;
    right: 0;
    width: 200px;
    background-color: var(--background);
    border-radius: var(--radius-md);
    box-shadow: var(--shadow-lg);
    padding: var(--spacing-sm);
    margin-top: var(--spacing-sm);
}

.dropdown-item {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    padding: var(--spacing-sm) var(--spacing-md);
    color: var(--text-primary);
    border-radius: var(--radius-sm);
}

.dropdown-item:hover {
    background-color: var(--background-alt);
}

/* Responsive Design */
@media (max-width: 1024px) {
    .admin-container {
        grid-template-columns: 1fr;
    }

    .side-nav {
        transform: translateX(-100%);
    }

    .side-nav.active {
        transform: translateX(0);
    }

    .dashboard-grid {
        grid-template-columns: 1fr;
    }
}

@media (max-width: 768px) {
    .stats-grid {
        grid-template-columns: 1fr;
    }

    .stat-card {
        padding: var(--spacing-md);
    }

    .alert-item {
        flex-direction: column;
    }

    .alert-icon {
        align-self: flex-start;
    }
}

/* Print Styles */
@media print {
    .side-nav,
    .top-nav {
        display: none;
    }

    .admin-container {
        grid-template-columns: 1fr;
    }

    .dashboard-card {
        break-inside: avoid;
    }
}

================
File: src/main/resources/public/css/client.css
================
/* client.css - Stili per l'interfaccia client */

/* Layout base */
.client-container {
    max-width: 1400px;
    margin: 0 auto;
    padding: var(--spacing-lg);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

/* Header */
.client-header {
    background-color: var(--background);
    border-radius: var(--radius-lg);
    padding: var(--spacing-lg);
    margin-bottom: var(--spacing-xl);
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: var(--shadow-sm);
}

.header-left {
    display: flex;
    align-items: center;
    gap: var(--spacing-md);
}



/* Stile per il testo dello stato */
.status-text {
    margin-top: 5px;
    font-size: 14px;
    color: #666;
}

/* Stile per le card degli istituti */
.institute-card {
    background-color: #fff;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 16px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    cursor: pointer;
}

.institute-card h3 {
    margin-top: 0;
}

.institute-card .address {
    color: #555;
}

.institute-card .machines-count {
    color: #333;
    font-weight: bold;
}

/* Bottone per tornare alle macchine */
#backToMachinesButton {
    display: none;
    margin-top: 20px;
    padding: 10px 20px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

#backToMachinesButton:hover {
    background-color: #0056b3;
}
.btn-back {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: var(--radius-md);
    background-color: var(--background-alt);
    color: var(--text-primary);
    transition: all 0.2s ease;
}

.btn-back:hover {
    background-color: var(--border-color);
    color: var(--primary-color);
}

/* Welcome Section */
.welcome-section {
    text-align: center;
    padding: var(--spacing-xl) 0;
}

.welcome-content {
    max-width: 800px;
    margin: 0 auto;
}

.welcome-subtitle {
    font-size: 1.25rem;
    color: var(--text-secondary);
    margin-bottom: var(--spacing-xl);
}

/* Action Cards */
.action-cards {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: var(--spacing-lg);
    margin-top: var(--spacing-xl);
}

.action-card {
    background-color: var(--background);
    border-radius: var(--radius-lg);
    padding: var(--spacing-xl);
    text-align: center;
    box-shadow: var(--shadow-sm);
    transition: transform 0.2s ease;
}

.action-card:hover {
    transform: translateY(-4px);
    box-shadow: var(--shadow-md);
}

.card-icon {
    width: 64px;
    height: 64px;
    background-color: var(--background-alt);
    border-radius: var(--radius-full);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    margin: 0 auto var(--spacing-lg);
    color: var(--primary-color);
}

/* Machine Selection */
.filters-section {
    display: flex;
    gap: var(--spacing-md);
    margin-bottom: var(--spacing-xl);
    flex-wrap: wrap;
}

.search-box {
    flex: 1;
    min-width: 300px;
    position: relative;
}

.search-box input {
    width: 100%;
    padding: var(--spacing-md) var(--spacing-md) var(--spacing-md) 3rem;
    border: 1px solid var(--border-color);
    border-radius: var(--radius-lg);
    font-size: 1rem;
    transition: all 0.2s ease;
}

.search-box input:focus {
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}

.search-box i {
    position: absolute;
    left: var(--spacing-md);
    top: 50%;
    transform: translateY(-50%);
    color: var(--text-light);
}

.filter-buttons {
    display: flex;
    gap: var(--spacing-sm);
    flex-wrap: wrap;
}

.filter-btn {
    padding: var(--spacing-md) var(--spacing-lg);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-lg);
    background-color: var(--background);
    color: var(--text-primary);
    cursor: pointer;
    transition: all 0.2s ease;
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
}

.filter-btn.active {
    background-color: var(--primary-color);
    border-color: var(--primary-color);
    color: white;
}

/* Map Section */
.map-section {
    border-radius: var(--radius-lg);
    overflow: hidden;
    margin-bottom: var(--spacing-xl);
    position: relative;
    height: 400px;
    box-shadow: var(--shadow-sm);
}

.machines-map {
    height: 100%;
}

.map-legend {
    position: absolute;
    bottom: var(--spacing-md);
    right: var(--spacing-md);
    background-color: var(--background);
    padding: var(--spacing-md);
    border-radius: var(--radius-md);
    box-shadow: var(--shadow-md);
}

.legend-item {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-xs);
    font-size: 0.875rem;
}

.legend-dot {
    width: 12px;
    height: 12px;
    border-radius: var(--radius-full);
}

/* Machine Cards */
.machines-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: var(--spacing-lg);
}

.machine-card {
    background-color: var(--background);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-sm);
    overflow: hidden;
    transition: transform 0.2s ease;
}

.machine-card:hover {
    transform: translateY(-4px);
    box-shadow: var(--shadow-md);
}

.card-header {
    padding: var(--spacing-lg);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.card-header h3 {
    margin: 0;
    font-size: 1.25rem;
}

.card-body {
    padding: var(--spacing-lg);
}

/* Continuazione client.css */

.location, .institute {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    color: var(--text-secondary);
    margin-bottom: var(--spacing-sm);
}

.machine-info {
    display: flex;
    gap: var(--spacing-lg);
    margin-top: var(--spacing-md);
    padding-top: var(--spacing-md);
    border-top: 1px solid var(--border-color);
}

.info-item {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    color: var(--text-primary);
    font-size: 0.875rem;
}

.card-footer {
    padding: var(--spacing-md);
    background-color: var(--background-alt);
    text-align: center;
}



.status-badge i {
    font-size: 0.75rem;
}

.status-badge.active {
    background-color: rgba(16, 185, 129, 0.1);
    color: var(--success-color);
}

.status-badge.maintenance {
    background-color: rgba(245, 158, 11, 0.1);
    color: var(--warning-color);
}

.status-badge.inactive {
    background-color: rgba(239, 68, 68, 0.1);
    color: var(--danger-color);
}

/* Beverage Interface */
.beverage-interface {
    display: grid;
    grid-template-columns: 2fr 1fr;
    gap: var(--spacing-xl);
    margin-top: var(--spacing-xl);
}

.categories-tabs {
    display: flex;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-lg);
    overflow-x: auto;
    padding-bottom: var(--spacing-sm);
}

.tab-button {
    padding: var(--spacing-md) var(--spacing-lg);
    border: none;
    border-radius: var(--radius-lg);
    background: var(--background-alt);
    color: var(--text-primary);
    cursor: pointer;
    white-space: nowrap;
    transition: all 0.2s;
}

.tab-button.active {
    background: var(--primary-color);
    color: white;
}

/* Beverages Grid */
.beverages-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: var(--spacing-md);
}

.beverage-card {
    background: var(--background);
    border-radius: var(--radius-lg);
    padding: var(--spacing-md);
    text-align: center;
    cursor: pointer;
    transition: all 0.2s;
    border: 2px solid transparent;
}

.beverage-card:hover:not(.unavailable) {
    border-color: var(--primary-color);
    transform: translateY(-2px);
}

.beverage-card.selected {
    border-color: var(--primary-color);
    background: var(--background-alt);
}

.beverage-card.unavailable {
    opacity: 0.6;
    cursor: not-allowed;
}

/* Payment Interface */
.payment-interface {
    background: var(--background);
    border-radius: var(--radius-lg);
    padding: var(--spacing-lg);
    position: sticky;
    top: var(--spacing-md);
    box-shadow: var(--shadow-sm);
}

.selected-product {
    margin-bottom: var(--spacing-lg);
    padding-bottom: var(--spacing-lg);
    border-bottom: 1px solid var(--border-color);
}

/* Sugar Control */
.sugar-control {
    margin-bottom: var(--spacing-lg);
}

.sugar-buttons {
    display: flex;
    gap: var(--spacing-sm);
    margin-top: var(--spacing-sm);
}

.sugar-button {
    width: 40px;
    height: 40px;
    border-radius: var(--radius-md);
    border: 1px solid var(--border-color);
    background: var(--background);
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
}

.sugar-button.active {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
}

/* Coin Grid */
.coin-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-lg);
}

.coin-button {
    padding: var(--spacing-md);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-lg);
    background: var(--background);
    cursor: pointer;
    transition: all 0.2s;
    font-weight: 500;
}

.coin-button:hover {
    background: var(--background-alt);
}

/* Credit Display */
.credit-display {
    background: var(--background-alt);
    padding: var(--spacing-lg);
    border-radius: var(--radius-lg);
    text-align: center;
    margin-bottom: var(--spacing-lg);
}

.credit-amount {
    font-size: 2rem;
    font-weight: 600;
    color: var(--primary-color);
}

.credit-label {
    color: var(--text-secondary);
    font-size: 0.875rem;
}

/* Dispensing Animation */
.dispensing-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    color: white;
}

.dispensing-animation {
    text-align: center;
}

/* Responsive */
@media (max-width: 1024px) {
    .beverage-interface {
        grid-template-columns: 1fr;
    }

    .payment-interface {
        position: static;
        margin-top: var(--spacing-lg);
    }
}

@media (max-width: 768px) {
    .client-container {
        padding: var(--spacing-md);
    }

    .client-header {
        flex-direction: column;
        text-align: center;
        gap: var(--spacing-md);
    }

    .filters-section {
        flex-direction: column;
    }

    .filter-buttons {
        justify-content: center;
    }

    .machines-grid {
        grid-template-columns: 1fr;
    }

    .beverages-grid {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    }

    .coin-grid {
        grid-template-columns: repeat(2, 1fr);
    }
}

/* Animations */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideIn {
    from { 
        transform: translateY(20px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

.fade-in {
    animation: fadeIn 0.3s ease-in;
}

.slide-in {
    animation: slideIn 0.3s ease-out;
}

/* Print */
@media print {
    .client-container {
        padding: 0;
    }

    .filters-section,
    .map-section,
    .action-buttons {
        display: none;
    }
}

================
File: src/main/resources/public/css/reports.css
================
.filters-container {
    display: flex;
    gap: 1rem;
    margin-bottom: 2rem;
    padding: 1rem;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.date-range, .institute-filter {
    flex: 1;
}

.date-picker {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid #e2e8f0;
    border-radius: 4px;
}

.charts-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.5rem;
    margin-bottom: 2rem;
}

.chart-container {
    background: white;
    padding: 1.5rem;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.chart-container h3 {
    margin-bottom: 1rem;
    color: #2d3748;
    font-size: 1.25rem;
}

.reports-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 1.5rem;
}

.report-card {
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    overflow: hidden;
}

.report-card .card-header {
    padding: 1rem;
    background: #f8fafc;
    border-bottom: 1px solid #e2e8f0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.report-card .card-header h3 {
    font-size: 1.25rem;
    color: #2d3748;
    margin: 0;
}

.report-date {
    color: #718096;
    font-size: 0.875rem;
}

.report-card .card-body {
    padding: 1rem;
}

.report-section {
    margin-bottom: 1rem;
}

.report-section:last-child {
    margin-bottom: 0;
}

.report-section h4 {
    color: #4a5568;
    font-size: 1rem;
    margin-bottom: 0.5rem;
}

.report-section ul {
    list-style: none;
    padding: 0;
    margin: 0;
}

.report-section li {
    padding: 0.25rem 0;
    display: flex;
    justify-content: space-between;
    color: #718096;
}

@media (max-width: 768px) {
    .filters-container {
        flex-direction: column;
    }

    .charts-grid {
        grid-template-columns: 1fr;
    }

    .reports-grid {
        grid-template-columns: 1fr;
    }
}

================
File: src/main/resources/public/css/style.css
================
/* styles.css - Stili base del sistema */

:root {
    /* Colori principali */
    --primary-color: #2563eb;
    --primary-dark: #1d4ed8;
    --primary-light: #3b82f6;

    /* Colori secondari */
    --success-color: #10b981;
    --warning-color: #f59e0b;
    --danger-color: #ef4444;
    --info-color: #3b82f6;

    /* Colori neutri */
    --text-primary: #111827;
    --text-secondary: #4b5563;
    --text-light: #9ca3af;
    --background: #ffffff;
    --background-alt: #f3f4f6;
    --border-color: #e5e7eb;

    /* Spaziature */
    --spacing-xs: 0.25rem;
    --spacing-sm: 0.5rem;
    --spacing-md: 1rem;
    --spacing-lg: 1.5rem;
    --spacing-xl: 2rem;

    /* Border radius */
    --radius-sm: 0.25rem;
    --radius-md: 0.375rem;
    --radius-lg: 0.5rem;
    --radius-full: 9999px;

    /* Shadows */
    --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
}

/* Reset e stili base */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html {
    font-size: 16px;
    height: 100%;
}

body {
    background-color: #e5e7eb;
    font-family: 'Inter', -apple-system, system-ui, sans-serif;
    line-height: 1.5;
    color: var(--text-primary);
    min-height: 100%;
    -webkit-font-smoothing: antialiased;
}

/* Tipografia */
h1,
h2,
h3,
h4,
h5,
h6 {
    font-family: 'Poppins', sans-serif;
    font-weight: 600;
    line-height: 1.2;
    margin-bottom: 1rem;
}

h1 {
    font-size: 2rem;
}

h2 {
    font-size: 1.75rem;
}

h3 {
    font-size: 1.5rem;
}

h4 {
    font-size: 1.25rem;
}

h5 {
    font-size: 1.125rem;
}

h6 {
    font-size: 1rem;
}

p {
    margin-bottom: 1rem;
}

a {
    color: var(--primary-color);
    text-decoration: none;
    transition: color 0.2s;
}

a:hover {
    color: var(--warning-color);
}

/* Container e layout */
.container {
    max-width: 1280px;
    margin: 0 auto;
    padding: 0 var(--spacing-md);
}

.main-container {
    display: flex;
    min-height: 100vh;
    padding-top: 64px;
    /* Altezza navbar */
}

/* Navbar */
.top-nav {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 64px;
    background: var(--background);
    border-bottom: 1px solid var(--border-color);
    z-index: 100;
}

.nav-content {
    display: flex;
    justify-content: space-between;
    align-items: center;
    height: 100%;
    padding: 0 var(--spacing-xl);
}

.nav-brand {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
}

.brand-logo {
    height: 32px;
    width: auto;
}

.brand-text {
    font-weight: 600;
    font-size: 1.25rem;
}

/* Buttons */
.btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.5rem 1rem;
    border-radius: var(--radius-md);
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    border: none;
    gap: 0.5rem;
}

.btn-primary {
    background-color: var(--primary-color);
    color: white;
}

.btn-primary:hover {
    background-color: var(--primary-dark);
}

.btn-secondary {
    background-color: var(--background-alt);
    color: var(--text-primary);
}

.btn-secondary:hover {
    background-color: var(--border-color);
}

.btn-danger {
    background-color: var(--danger-color);
    color: white;
}

.btn-danger:hover {
    opacity: 0.9;
}

.btn-icon {
    padding: 0.5rem;
    border-radius: var(--radius-md);
}

/* Forms */
.form-group {
    margin-bottom: var(--spacing-md);
}

.form-label {
    display: block;
    margin-bottom: var(--spacing-xs);
    font-weight: 500;
}

.form-input {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid var(--border-color);
    border-radius: var(--radius-md);
    background-color: var(--background);
    transition: border-color 0.2s;
}

.form-input:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}

/* Cards */
.card {
    background-color: var(--background);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-md);
    overflow: hidden;
}

.card-header {
    padding: var(--spacing-md);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.card-body {
    padding: var(--spacing-md);
}

/* Status Indicators */


.status-badge.success {
    background-color: rgba(16, 185, 129, 0.1);
    color: var(--success-color);
}

.status-badge.warning {
    background-color: rgba(245, 158, 11, 0.1);
    color: var(--warning-color);
}

.status-badge.danger {
    background-color: rgba(239, 68, 68, 0.1);
    color: var(--danger-color);
}

/* Stile per il pallino dello stato */
.status-badge {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 8px;
}

.status-available {
    background-color: green;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.status-maintenance {
    background-color: yellow;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.status-inactive {
    background-color: #fd0006;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.status-unknown {
    background-color: gray;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* Stile per il testo dello stato */
.status-text {
    margin-top: 5px;
    font-size: 14px;
    color: #666;
}

/* Stile per le card degli istituti */
.institute-card {
    background-color: #fff;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 16px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.institute-card h3 {
    margin-top: 0;
}

.institute-card .address {
    color: #555;
}

.institute-card .machines-count {
    color: #333;
    font-weight: bold;
}

/* Modals */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.modal-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.5);
}

.modal-content {
    position: relative;
    background-color: var(--background);
    border-radius: var(--radius-lg);
    padding: var(--spacing-xl);
    max-width: 500px;
    width: 90%;
    box-shadow: var(--shadow-lg);
}

/* Loading States */
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(255, 255, 255, 0.8);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.spinner {
    width: 40px;
    height: 40px;
    border: 3px solid var(--border-color);
    border-top-color: var(--primary-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}

/* Toasts */
.toast-container {
    position: fixed;
    bottom: var(--spacing-lg);
    right: var(--spacing-lg);
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: var(--spacing-sm);
}

.toast {
    padding: var(--spacing-md);
    border-radius: var(--radius-md);
    background-color: var(--background);
    box-shadow: var(--shadow-lg);
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    min-width: 300px;
    max-width: 500px;
    animation: slideIn 0.3s ease-out;
}

.btn-show-institutes {
    background-color: #4CAF50;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    margin-top: 10px;
}

.btn-select {
    background-color: #004080;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    margin-top: 10px;
}

.btn-show-institutes:hover {
    background-color: #45a049;
}

.institutes-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
    margin-top: 20px;
}

/* Stile per le card degli istituti */
.institute-card {
    background-color: #fff;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 16px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    cursor: pointer;
}

/* Effetto hover per le card degli istituti */
.institute-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

/* Stile per le card delle macchine */
.machine-card {
    background-color: #fff;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 16px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    cursor: pointer;
}

/* Effetto hover per le card delle macchine */
.machine-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.institute-card {
    background-color: #fff;
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.toast.success {
    border-left: 4px solid var(--success-color);
}

.toast.error {
    border-left: 4px solid var(--danger-color);
}

.toast.warning {
    border-left: 4px solid var(--warning-color);
}

.toast.info {
    border-left: 4px solid var(--info-color);
}

/* Aggiungere questi stili al tuo file CSS */
.machines-grid,
.institutes-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
    width: 100%;
    padding: 0 20px;
}

.machine-card,
.institute-card {
    width: 100%;
}

/* Modifica lo stile del container esistente */
.container {
    max-width: 100% !important;
    padding: 0 20px;
}

/* Aggiunta di utility classes */
.w-full {
    width: 100%;
}

.px-4 {
    padding-left: 1rem;
    padding-right: 1rem;
}

@keyframes slideIn {
    from {
        transform: translateX(100%);
        opacity: 0;
    }

    to {
        transform: translateX(0);
        opacity: 1;
    }
}

.custom-marker {
    position: relative;
}

.custom-marker:hover {
    transform: scale(1.1);
    transition: transform 0.2s;
}

/* Utilities */
.hidden {
    display: none !important;
}

.text-center {
    text-align: center;
}

.text-right {
    text-align: right;
}

.mt-1 {
    margin-top: var(--spacing-xs);
}

.mt-2 {
    margin-top: var(--spacing-sm);
}

.mt-3 {
    margin-top: var(--spacing-md);
}

.mt-4 {
    margin-top: var(--spacing-lg);
}

.mb-1 {
    margin-bottom: var(--spacing-xs);
}

.mb-2 {
    margin-bottom: var(--spacing-sm);
}

.mb-3 {
    margin-bottom: var(--spacing-md);
}

.mb-4 {
    margin-bottom: var(--spacing-lg);
}

/* Responsive */
@media (max-width: 1024px) {
    .container {
        padding: 0 var(--spacing-md);
    }
}

@media (max-width: 768px) {
    html {
        font-size: 14px;
    }

    .container {
        padding: 0 var(--spacing-sm);
    }

    .modal-content {
        width: 95%;
    }

    .toast {
        min-width: auto;
        max-width: 90%;
        margin: 0 var(--spacing-sm);
    }
}

@media (prefers-reduced-motion: reduce) {
    * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
    }
}

================
File: src/main/resources/public/homepage.html
================
<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Sistema di gestione distributori automatici di bevande - Accesso pubblico e area amministrativa">
    <meta name="theme-color" content="#2563eb">
    <title>Sistema Distributori Automatici</title>
    
    <!-- CSS -->
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/admin.css">
    <link rel="stylesheet" href="css/client.css">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <!-- Google Fonts - Preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Poppins:wght@500;600;700&display=swap" rel="stylesheet">
    
    <!-- Chart.js -->
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/chart.js/3.7.0/chart.min.js"></script>

    <!-- Scripts -->
    <script src="js/common/utils.js" type="module"></script>
    <script src="js/common/mqtt.js" type="module"></script>
    <script src="js/common/authentication.js" type="module"></script>
    <script src="js/admin/dashboard.js" type="module"></script>
</head>
<body>
    <!-- Skip Link -->
    <a href="#main-content" class="skip-link">Salta al contenuto principale</a>

    <!-- Header Navigation -->
    <header role="banner">
        <nav class="top-nav" role="navigation" aria-label="Navigazione principale">
            <div class="nav-content container">
                <div class="nav-brand">
                    <a href="/" aria-label="Home">
                        <svg class="brand-logo" width="32" height="32" viewBox="0 0 32 32" role="img" aria-hidden="true">
                            <title>Progetto Pissir- Edoardo Giovanni Fracchia</title>
                            <circle cx="16" cy="16" r="16" fill="#2563eb"/>
                            <path d="M10 16L14 20L22 12" stroke="white" stroke-width="2"/>
                        </svg>
                    </a>
                    <span class="brand-text">Sistema di macchinette - Progetto Pissir - Edoardo Giovanni Fracchia - matricola:20019309</span>
                </div>
                
                <div class="user-menu">
                    <button class="user-menu-btn" id="userMenuBtn" aria-haspopup="true" aria-expanded="false">
                        <i class="fas fa-user-circle" aria-hidden="true"></i>
                        <span class="user-name" id="userName">Ospite</span>
                        <i class="fas fa-chevron-down" aria-hidden="true"></i>
                    </button>
                    <div class="user-dropdown hidden" id="userDropdown" role="menu">
                        <a href="#" class="dropdown-item" id="loginBtn" role="menuitem">
                            <i class="fas fa-sign-in-alt" aria-hidden="true"></i>
                            <span>Accedi</span>
                        </a>
                        <a href="#" class="dropdown-item hidden" id="profileBtn" role="menuitem">
                            <i class="fas fa-user" aria-hidden="true"></i>
                            <span>Profilo</span>
                        </a>
                        <a href="#" class="dropdown-item hidden" id="logoutBtn" role="menuitem">
                            <i class="fas fa-sign-out-alt" aria-hidden="true"></i>
                            <span>Esci</span>
                        </a>
                    </div>
                </div>
            </div>
        </nav>
    </header>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Admin Sidebar -->
        <aside class="side-nav hidden" id="adminNav" role="navigation" aria-label="Menu amministrazione">
            <nav>
                <div class="nav-section">
                    <h2>Dashboard</h2>
                    <a href="pages/admin/dashboard.html" class="nav-item active" aria-current="page">
                        <i class="fas fa-home" aria-hidden="true"></i>
                        <span>Dashboard</span>
                    </a>
                    <a href="pages/admin/machines.html" class="nav-item">
                        <i class="fas fa-coffee" aria-hidden="true"></i>
                        <span>Distributori</span>
                    </a>
                    <a href="pages/admin/istitutes.html" class="nav-item">
                        <i class="fas fa-building" aria-hidden="true"></i>
                        <span>Istituti</span>
                    </a>
                </div>
                
                <div class="nav-section">
                    <h2>Gestione</h2>
                    <a href="pages/admin/maintenance.html" class="nav-item">
                        <i class="fas fa-tools" aria-hidden="true"></i>
                        <span>Manutenzione</span>
                    </a>
                    <a href="pages/admin/reports.html" class="nav-item">
                        <i class="fas fa-chart-line" aria-hidden="true"></i>
                        <span>Statistiche</span>
                    </a>
                    <a href="pages/admin/pods.html" class="nav-item">
                        <i class="fas fa-users" aria-hidden="true"></i>
                        <span>Cialde</span>
                    </a>
                </div>
            </nav>
        </aside>

        <!-- Main Content -->
        <main id="main-content" class="content-area container" role="main">
            <!-- Guest Welcome -->
            <section class="welcome-section" id="guestView" aria-labelledby="welcome-title">
                <div class="welcome-content">
                    <h1 id="welcome-title">Benvenuto nel Sistema</h1>
                    <p class="welcome-subtitle">Seleziona un'opzione per iniziare</p>
                    
                    <div class="action-cards" role="group" aria-label="Opzioni principali">
                        <article class="action-card">
                            <div class="card-icon" aria-hidden="true">
                                <i class="fas fa-coffee"></i>
                            </div>
                            <h2>Acquista Bevande</h2>
                            <p>Seleziona un distributore e acquista una bevanda</p>
                            <a href="pages/client/machineSelection.html" class="btn btn-primary">
                                Trova distributore
                                <span class="visually-hidden">più vicino</span>
                            </a>
                        </article>

                        <article class="action-card">
                            <div class="card-icon" aria-hidden="true">
                                <i class="fas fa-sign-in-alt"></i>
                            </div>
                            <h2>Area Amministrativa</h2>
                            <p>Accedi per gestire distributori e visualizzare statistiche</p>
                            <button class="btn btn-primary login-trigger" aria-haspopup="dialog">
                                Accedi come amministratore
                            </button>
                        </article>
                    </div>
                </div>
            </section>

            <!-- Admin Dashboard -->
            <section class="dashboard hidden" id="adminView" aria-labelledby="dashboard-title">
                <h1 id="dashboard-title" class="visually-hidden">Dashboard Amministrativa</h1>
                
                <div class="stats-grid" role="region" aria-label="Statistiche generali">
                    <!-- Statistiche verranno caricate dinamicamente -->
                </div>
                
                <div class="dashboard-grid" role="region" aria-label="Pannelli di controllo">
                    <!-- Pannelli verranno caricati dinamicamente -->
                </div>
            </section>
        </main>
    </div>

    <!-- Login Modal -->
    <div class="modal hidden" id="loginModal" role="dialog" aria-labelledby="login-title" aria-modal="true">
        <div class="modal-overlay" onclick="closeLoginModal()"></div>
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="login-title">Accesso Amministratore</h2>
                <button class="btn-close close-modal" aria-label="Chiudi">
                    <i class="fas fa-times" aria-hidden="true"></i>
                </button>
            </div>
            
            <form id="loginForm" class="login-form" novalidate>
                <div class="form-group">
                    <label for="username">Nome utente</label>
                    <div class="input-icon">
                        <i class="fas fa-user" aria-hidden="true"></i>
                        <input type="text" 
                               id="username" 
                               name="username" 
                               class="form-input" 
                               required 
                               autocomplete="username"
                               aria-required="true">
                    </div>
                </div>

                <div class="form-group">
                    <label for="password">Password</label>
                    <div class="input-icon">
                        <i class="fas fa-lock" aria-hidden="true"></i>
                        <input type="password" 
                               id="password" 
                               name="password" 
                               class="form-input" 
                               required
                               autocomplete="current-password"
                               aria-required="true">
                    </div>
                </div>

                <div class="form-actions">
                    <button type="submit" class="btn btn-primary btn-block">
                        Accedi
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay hidden" id="loadingOverlay" role="alert" aria-busy="true">
        <div class="spinner"></div>
        <p>Caricamento in corso...</p>
    </div>

    <!-- Toast Container -->
    <div id="toastContainer" class="toast-container" role="alert" aria-live="polite"></div>

    
</body>
</html>

================
File: src/main/resources/public/index.html
================
<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Sistema di gestione distributori automatici - Dashboard amministrativa e interfaccia client">
    <title>Sistema Gestione Distributori</title>
    
    <!-- CSS -->
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/client.css">

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chart.js/3.7.0/chart.min.js"></script>
    <script src="js/common/utils.js" type="module"></script>
    <script src="js/common/mqtt.js" type="module"></script>
    <script src="js/common/authentication.js" type="module"></script>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Poppins:wght@500;600;700&display=swap" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="top-nav">
        <div class="nav-content container">
            <div class="nav-brand">
                <span class="brand-text">Progetto d'esame - Edoardo Giovanni Fracchia</span>
            </div>
            
            <div class="user-menu">
                <span id="userInfo" class="user-info hidden">
                <span id="userName"></span>
                    <i class="fas fa-user"></i>
                    
                </span>
                
                <a class="btn btn-secondary"" id="logoutBtn">
                    Logout
                </a>
            </div>
        </div>
    </nav>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Main Content -->
        <main class="content-area container">
            <!-- Welcome Section -->
            <section class="welcome-section">
                <div class="welcome-content">
                    <h1>Benvenuto nel sistema di Gestione Macchine</h1>
                    <p class="welcome-subtitle">Seleziona un'opzione per iniziare</p>
                    <div class="action-cards" id="actionCards">
                        <!-- Card Erogazione (sempre visibile) -->
                        <div class="action-card">
                            <div class="card-icon">
                                <i class="fas fa-coffee"></i>
                            </div>
                            <h3>Acquista Bevande</h3>
                            <p>Seleziona un distributore e acquista le tue bevande preferite</p>
                            <a href="/pages/client/machineSelection.html" class="btn btn-primary">
                                Inizia
                            </a>
                        </div>

                        <!-- Card Dashboard Impiegato (visibile solo per employee) -->
                        <div class="action-card hidden" id="employeeDashboardCard">
                            <div class="card-icon">
                                <i class="fas fa-tasks"></i>
                            </div>
                            <h3>Dashboard Impiegato</h3>
                            <p>Gestisci le macchine e monitora lo stato del sistema</p>
                            <a href="/pages/admin/dash_impiegati.html" class="btn btn-primary">
                                Accedi
                            </a>
                        </div>

                        <!-- Card Dashboard Admin (visibile solo per admin) -->
                        <div class="action-card hidden" id="adminDashboardCard">
                            <div class="card-icon">
                                <i class="fas fa-cogs"></i>
                            </div>
                            <h3>Dashboard Amministratore</h3>
                            <p>Gestione completa del sistema e configurazione</p>
                            <a href="/pages/admin/dash_admin.html" class="btn btn-primary">
                                Accedi
                            </a>
                        </div>

                        <!-- Card Login (visibile solo per guest) -->
                        <div class="action-card" id="loginCard">
                            <div class="card-icon">
                                <i class="fas fa-sign-in-alt"></i>
                            </div>
                            <h3>Area Amministrativa</h3>
                            <p>Accedi per gestire distributori e visualizzare statistiche</p>
                            <a href="/pages/client/login.html" class="btn btn-primary">
                                Accesso admin
                            </a>
                        </div>

                        <!-- Card Registrazione (visibile solo per guest) -->
                        <div class="action-card" id="registerCard">
                            <div class="card-icon">
                                <i class="fas fa-user-plus"></i>
                            </div>
                            <h3>Registrazione</h3>
                            <p>Registrati come nuovo amministratore del sistema</p>
                            <a href="/pages/client/register.html" class="btn btn-primary">
                                Registrazione
                            </a>
                        </div>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <!-- Overlays -->
    <div class="loading-overlay hidden" id="loadingOverlay">
        <div class="spinner"></div>
        <p>Caricamento in corso...</p>
    </div>

    <!-- Toast Container -->
    <div id="toastContainer" class="toast-container"></div>

    <!-- Script per gestire l'accesso -->
    <script type="module">
        import auth from './js/common/authentication.js';

        function updateUI() {
            const userRole = auth.getUserRole();

            const isAuthenticated = auth.isAuthenticated();
            // Elementi UI
            const loginCard = document.getElementById('loginCard');
            const registerCard = document.getElementById('registerCard');
            const employeeDashboardCard = document.getElementById('employeeDashboardCard');
            const adminDashboardCard = document.getElementById('adminDashboardCard');
            const logoutBtn = document.getElementById('logoutBtn');
            const userInfo = document.getElementById('userInfo');
            const userNameSpan = document.getElementById('userName');

            // Nascondi/mostra elementi in base all'autenticazione
            if (isAuthenticated) {
                // Nascondi login e registrazione
                loginCard.classList.add('hidden');
                registerCard.classList.add('hidden');
                
                // Mostra logout e info utente
                logoutBtn.classList.remove('hidden');
                userInfo.classList.remove('hidden');
                userNameSpan.textContent = localStorage.getItem('user_name');

                // Mostra dashboard in base al ruolo
                if (auth.isEmployee()) {
                    employeeDashboardCard.classList.remove('hidden');
                    adminDashboardCard.classList.add('hidden');
                } else if (auth.isAdmin()) {
                    adminDashboardCard.classList.remove('hidden');
                    employeeDashboardCard.classList.add('hidden');
                }
            } else {
                // Mostra login e registrazione
                loginCard.classList.remove('hidden');
                registerCard.classList.remove('hidden');
                
                // Nascondi elementi autenticati
                logoutBtn.classList.add('hidden');
                userInfo.classList.add('hidden');
                employeeDashboardCard.classList.add('hidden');
                adminDashboardCard.classList.add('hidden');
            }
        }

        // Gestione logout
        document.getElementById('logoutBtn').addEventListener('click', (e) => {
            e.preventDefault();
            auth.logout();
        });

        // Verifica token all'avvio
        async function checkTokenAndUpdate() {
            if (auth.isAuthenticated()) {
                try {
                    await auth.refreshToken();
                } catch (error) {
                    console.error('Errore refresh token:', error);
                }
            }
            updateUI();
        }

        // Aggiorna UI al caricamento
        document.addEventListener('DOMContentLoaded', checkTokenAndUpdate);
    </script>
</body>
</html>

================
File: src/main/resources/public/js/admin/dashboard.js
================
/**
 * Gestione Dashboard Amministrativa
 * Gestisce l'interfaccia utente della dashboard e la comunicazione con il backend
 */
import mqttClient from '../common/mqtt.js';
import Utils from '../common/utils.js';
import AuthService from '../common/authentication.js';

class DashboardManager {
    constructor() {
        // Inizializza elementi DOM
        this.elements = {
            // Statistiche
            activeMachines: document.getElementById('activeMachines'),
            maintenanceCount: document.getElementById('maintenanceCount'),
            todayRevenue: document.getElementById('todayRevenue'),
            todayDispensed: document.getElementById('todayDispensed'),
            
            // Chart
            revenueChart: document.getElementById('revenueChart'),
            chartPeriod: document.getElementById('chartPeriod'),
            
            // Status
            machineStatusList: document.getElementById('machineStatusList'),
            alertsList: document.getElementById('alertsList'),
            
            // Viste
            adminView: document.getElementById('adminView'),
            guestView: document.getElementById('guestView'),
            
            // Sidebar
            adminNav: document.getElementById('adminNav')
        };

        // Stato dell'applicazione
        this.state = {
            stats: {
                activeMachines: 0,
                maintenanceCount: 0,
                todayRevenue: 0,
                todayDispensed: 0
            },
            chart: null,
            machines: new Map(),
            alerts: [],
            mqttSubscriptions: new Set() // Per gestire le sottoscrizioni MQTT
        };

        // Inizializza
        this.initialize();
    }

    /**
     * Inizializza la dashboard
     */
    async initialize() {
        try {
            // Verifica autenticazione
            if (!await AuthService.checkAuthentication()) {
                this.showGuestView();
                return;
            }

            // Mostra vista admin
            this.showAdminView();

            // Carica dati iniziali
            await this.loadInitialData();

            // Inizializza chart
            this.initializeChart();

            // Setup MQTT
            await this.initializeMQTTSubscriptions();

            // Event listeners
            this.initializeEventListeners();

            console.log('Dashboard inizializzata con successo');

        } catch (error) {
            console.error('Errore inizializzazione dashboard:', error);
            Utils.showToast('Errore durante il caricamento della dashboard', 'error');
        }
    }

    /**
     * Carica i dati iniziali (statistiche, macchine, avvisi)
     */
    async loadInitialData() {
        try {
            const [stats, machines, alerts] = await Promise.all([
                Utils.apiCall('/api/dashboard/stats'),
                Utils.apiCall('/macchine'),
                Utils.apiCall('/api/dashboard/alerts')
            ]);

            // Aggiorna stato
            this.state.stats = stats;
            this.state.machines.clear();
            machines.forEach(machine => {
                this.state.machines.set(machine.id, machine);
            });
            this.state.alerts = alerts;

            // Aggiorna UI
            this.updateStatsUI();
            this.updateMachinesUI();
            this.updateAlertsUI();

        } catch (error) {
            console.error('Errore caricamento dati iniziali:', error);
            throw error;
        }
    }

    /**
     * Inizializza il grafico
     */
    initializeChart() {
        const ctx = this.elements.revenueChart.getContext('2d');
        
        this.state.chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Ricavi',
                    data: [],
                    borderColor: '#3b82f6',
                    tension: 0.4,
                    fill: true,
                    backgroundColor: 'rgba(59, 130, 246, 0.1)'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            display: true,
                            drawBorder: false
                        }
                    },
                    x: {
                        grid: {
                            display: false
                        }
                    }
                }
            }
        });

        // Carica dati iniziali
        this.updateChartData();
    }

    /**
     * Inizializza sottoscrizioni MQTT
     */
    async initializeMQTTSubscriptions() {
        try {
            // Sottoscrivi a stati macchine
            if (!this.state.mqttSubscriptions.has('macchine/+/stato')) {
                await mqttClient.subscribe('macchine/+/stato', (topic, message) => {
                    const machineId = parseInt(topic.split('/')[1]);
                    this.handleMachineStatusUpdate(machineId, JSON.parse(message));
                });
                this.state.mqttSubscriptions.add('macchine/+/stato');
            }

            // Sottoscrivi ad avvisi
            if (!this.state.mqttSubscriptions.has('system/alerts')) {
                await mqttClient.subscribe('system/alerts', (topic, message) => {
                    this.handleNewAlert(JSON.parse(message));
                });
                this.state.mqttSubscriptions.add('system/alerts');
            }

        } catch (error) {
            console.error('Errore sottoscrizioni MQTT:', error);
            throw error;
        }
    }

    /**
     * Inizializza event listeners
     */
    initializeEventListeners() {
        // Periodo chart
        this.elements.chartPeriod?.addEventListener('change', () => {
            this.updateChartData();
        });

        // Refresh stato macchine
        document.querySelector('.btn-refresh')?.addEventListener('click', () => {
            this.loadInitialData();
        });
    }

    /**
     * Gestisce l'aggiornamento dello stato di una macchina
     */
    handleMachineStatusUpdate(machineId, status) {
        const machine = this.state.machines.get(machineId);
        if (!machine) return;

        // Aggiorna stato
        machine.stato = status.stato;

        // Aggiorna conteggi
        this.updateMachinesCounts();

        // Aggiorna UI
        this.updateMachineStatusUI(machine);
    }

    /**
     * Gestisce un nuovo avviso
     */
    handleNewAlert(alert) {
        // Aggiungi alla lista
        this.state.alerts.unshift(alert);
        
        // Mantieni solo gli ultimi 10 avvisi
        if (this.state.alerts.length > 10) {
            this.state.alerts.pop();
        }

        // Aggiorna UI
        this.updateAlertsUI();
    }

    /**
     * Aggiorna l'UI delle statistiche
     */
    updateStatsUI() {
        if (!this.elements.activeMachines) return;

        this.elements.activeMachines.textContent = this.state.stats.activeMachines;
        this.elements.maintenanceCount.textContent = this.state.stats.maintenanceCount;
        this.elements.todayRevenue.textContent = Utils.formatPrice(this.state.stats.todayRevenue);
        this.elements.todayDispensed.textContent = this.state.stats.todayDispensed;
    }

    /**
     * Aggiorna i dati del grafico
     */
    async updateChartData() {
        try {
            const period = this.elements.chartPeriod?.value || 'day';
            const data = await Utils.apiCall(`/api/dashboard/revenue?period=${period}`);

            this.state.chart.data.labels = data.labels;
            this.state.chart.data.datasets[0].data = data.values;
            this.state.chart.update();

        } catch (error) {
            console.error('Errore aggiornamento grafico:', error);
            Utils.showToast('Errore aggiornamento grafico', 'error');
        }
    }

    /**
     * Aggiorna l'UI delle macchine
     */
    updateMachinesUI() {
        if (!this.elements.machineStatusList) return;

        this.elements.machineStatusList.innerHTML = Array.from(this.state.machines.values())
            .map(machine => this.renderMachineStatus(machine))
            .join('');

        this.updateMachinesCounts();
    }

    /**
     * Aggiorna i conteggi delle macchine
     */
    updateMachinesCounts() {
        const machines = Array.from(this.state.machines.values());
        
        this.state.stats.activeMachines = machines.filter(m => m.stato === 'active').length;
        this.state.stats.maintenanceCount = machines.filter(m => m.stato === 'maintenance').length;

        this.updateStatsUI();
    }

    /**
     * Renderizza lo stato di una macchina
     */
    renderMachineStatus(machine) {
        const status = this.getMachineStatus(machine.stato);
        
        return `
            <div class="status-item">
                <div class="status-item-icon ${status.class}">
                    <i class="${status.icon}"></i>
                </div>
                <div class="status-item-info">
                    <h4 class="status-item-title">Distributore #${machine.id}</h4>
                    <p class="status-item-subtitle">
                        ${machine.ubicazione} - ${machine.istitutoNome}
                    </p>
                </div>
                <div class="status-badge ${status.class}">
                    ${status.text}
                </div>
            </div>
        `;
    }

    /**
     * Aggiorna l'UI degli avvisi
     */
    updateAlertsUI() {
        if (!this.elements.alertsList) return;

        this.elements.alertsList.innerHTML = this.state.alerts
            .map(alert => this.renderAlert(alert))
            .join('');
    }

    /**
     * Renderizza un avviso
     */
    renderAlert(alert) {
        return `
            <div class="alert-item alert-${alert.type}">
                <div class="alert-icon">
                    <i class="${this.getAlertIcon(alert.type)}"></i>
                </div>
                <div class="alert-info">
                    <h4 class="alert-title">${alert.title}</h4>
                    <p class="alert-message">${alert.message}</p>
                    <span class="alert-time">${Utils.formatDate(alert.timestamp)}</span>
                </div>
            </div>
        `;
    }

    /**
     * Ottiene i dettagli dello stato di una macchina
     */
    getMachineStatus(stato) {
        const statusMap = {
            'active': {
                class: 'success',
                text: 'Attiva',
                icon: 'fas fa-check-circle'
            },
            'maintenance': {
                class: 'warning',
                text: 'In Manutenzione',
                icon: 'fas fa-tools'
            },
            'inactive': {
                class: 'danger',
                text: 'Inattiva',
                icon: 'fas fa-times-circle'
            }
        };

        return statusMap[stato] || {
            class: 'default',
            text: 'Sconosciuto',
            icon: 'fas fa-question-circle'
        };
    }

    /**
     * Ottiene l'icona per un tipo di avviso
     */
    getAlertIcon(type) {
        const icons = {
            'success': 'fas fa-check-circle',
            'warning': 'fas fa-exclamation-triangle',
            'error': 'fas fa-times-circle',
            'info': 'fas fa-info-circle'
        };

        return icons[type] || icons.info;
    }

    /**
     * Mostra la vista amministratore
     */
    showAdminView() {
        if (this.elements.guestView) {
            this.elements.guestView.classList.add('hidden');
        }
        if (this.elements.adminView) {
            this.elements.adminView.classList.remove('hidden');
        }
        if (this.elements.adminNav) {
            this.elements.adminNav.classList.remove('hidden');
        }
    }

    /**
     * Mostra la vista ospite
     */
    showGuestView() {
        if (this.elements.adminView) {
            this.elements.adminView.classList.add('hidden');
        }
        if (this.elements.adminNav) {
            this.elements.adminNav.classList.add('hidden');
        }
        if (this.elements.guestView) {
            this.elements.guestView.classList.remove('hidden');
        }
    }

    /**
     * Pulisce le risorse
     */
    destroy() {
        // Rimuovi sottoscrizioni MQTT
        this.state.mqttSubscriptions.forEach(topic => {
            mqttClient.unsubscribe(topic);
        });
        this.state.mqttSubscriptions.clear();

        // Distruggi chart
        if (this.state.chart) {
            this.state.chart.destroy();
        }

        // Pulisci stato
        this.state.machines.clear();
        this.state.alerts = [];
    }
}

// Inizializzazione quando il DOM è pronto
document.addEventListener('DOMContentLoaded', () => {
    const dashboard = new DashboardManager();

    // Cleanup quando si lascia la pagina
    window.addEventListener('unload', () => {
        dashboard.destroy();
    });
});

export default DashboardManager;

================
File: src/main/resources/public/js/admin/institutes.js
================
/**
 * Gestione Istituti
 * Gestisce le operazioni CRUD per gli istituti e le relative macchine associate
 */

import Utils from '../common/utils.js';
import auth from '../common/authentication.js';

class InstituteManager {
    constructor() {
        // Verifica autenticazione
        auth.protectAdminRoute();

        this.initializeElements();
        this.initializeState();
        this.initialize();
    }

    /**
     * Inizializza gli elementi DOM
     */
    initializeElements() {
        this.elements = {
            institutesList: document.getElementById('institutesList'),
            addInstituteForm: document.getElementById('addInstituteForm'),
            editInstituteModal: document.getElementById('editInstituteModal'),
            searchInput: document.getElementById('searchInstitute'),
            pagination: document.getElementById('institutesPagination'),
            machinesSummary: document.getElementById('machinesSummary')
        };

        // Verifica elementi richiesti
        Object.entries(this.elements).forEach(([key, element]) => {
            if (!element) {
                throw new Error(`Elemento DOM non trovato: ${key}`);
            }
        });
    }

    /**
     * Inizializza lo stato dell'applicazione
     */
    initializeState() {
        this.state = {
            institutes: new Map(),
            machines: new Map(),
            currentPage: 1,
            itemsPerPage: 10,
            filters: {
                search: ''
            }
        };
    }

    /**
     * Inizializza il gestore
     */
    async initialize() {
        try {
            Utils.toggleLoading(true);
            await this.loadInitialData();
            this.setupEventListeners();
            this.renderUI();
            console.log('Gestore istituti inizializzato');
        } catch (error) {
            console.error('Errore inizializzazione:', error);
            Utils.showToast('Errore durante l\'inizializzazione', 'error');
        } finally {
            Utils.toggleLoading(false);
        }
    }

    /**
     * Carica i dati iniziali
     */
    async loadInitialData() {
        try {
            const [institutes, machines] = await Promise.all([
                Utils.apiCall('/api/istituti'),
                Utils.apiCall('/api/macchine')
            ]);

            institutes.forEach(institute => {
                this.state.institutes.set(institute.ID_Istituto, institute);
            });

            machines.forEach(summary => {
                this.state.machines.set(summary.ID_Istituto, summary);
            });

        } catch (error) {
            console.error('Errore caricamento dati:', error);
            throw error;
        }
    }

    /**
     * Configura i listener degli eventi
     */
    setupEventListeners() {
        // Form aggiunta istituto
        this.elements.addInstituteForm.addEventListener('submit', 
            this.handleAddInstitute.bind(this));

        // Ricerca
        this.elements.searchInput.addEventListener('input', 
            Utils.debounce(() => {
                this.state.filters.search = this.elements.searchInput.value;
                this.renderInstitutes();
            }, 300));

        // Gestione modali
        document.querySelectorAll('.modal-close').forEach(button => {
            button.addEventListener('click', () => this.closeModals());
        });

        // Prevenzione perdita modifiche
        window.addEventListener('beforeunload', (e) => {
            if (this.hasUnsavedChanges()) {
                e.preventDefault();
                e.returnValue = '';
            }
        });
    }

    /**
     * Gestisce l'aggiunta di un nuovo istituto
     */
    async handleAddInstitute(event) {
        event.preventDefault();
        const form = event.target;
        const formData = new FormData(form);

        try {
            Utils.toggleLoading(true, form);

            const instituteData = {
                id:formData.get('ID_Istituto'),
                nome: formData.get('Nome'),
                indirizzo: formData.get('Indirizzo')
            };

            this.validateInstituteData(instituteData);

            const newInstitute = await Utils.apiCall('/api/istituti', {
                method: 'POST',
                body: JSON.stringify(instituteData)
            });

            this.state.institutes.set(newInstitute.id, newInstitute);
            this.renderInstitutes();

            Utils.showToast('Istituto aggiunto con successo', 'success');
            form.reset();

        } catch (error) {
            console.error('Errore aggiunta istituto:', error);
            Utils.showToast(error.message || 'Errore durante l\'aggiunta', 'error');
        } finally {
            Utils.toggleLoading(false, form);
        }
    }

    /**
     * Gestisce la modifica di un istituto
     */
    async handleEditInstitute(instituteId, formData) {
        try {
            Utils.toggleLoading(true);

            const instituteData = {
                nome: formData.get('nome'),
                indirizzo: formData.get('indirizzo'),
                citta: formData.get('citta'),
                provincia: formData.get('provincia'),
                cap: formData.get('cap'),
                telefono: formData.get('telefono'),
                email: formData.get('email')
            };

            this.validateInstituteData(instituteData);

            const updatedInstitute = await Utils.apiCall(`/api/istituti/${instituteId}`, {
                method: 'PUT',
                body: JSON.stringify(instituteData)
            });

            this.state.institutes.set(instituteId, updatedInstitute);
            this.renderInstitutes();
            this.closeModals();

            Utils.showToast('Istituto aggiornato con successo', 'success');
        } catch (error) {
            console.error('Errore modifica istituto:', error);
            Utils.showToast(error.message || 'Errore durante la modifica', 'error');
        } finally {
            Utils.toggleLoading(false);
        }
    }

    /**
     * Gestisce l'eliminazione di un istituto
     */
    async handleDeleteInstitute(instituteId) {
        try {
            const institute = this.state.institutes.get(instituteId);
            if (!institute) {
                throw new Error('Istituto non trovato');
            }

            const machineSummary = this.state.machines.get(instituteId);
            if (machineSummary?.totalMachines > 0) {
                throw new Error('Impossibile eliminare un istituto con macchine associate');
            }

            if (!confirm(`Sei sicuro di voler eliminare l'istituto "${institute.nome}"?`)) {
                return;
            }

            await Utils.apiCall(`/api/istituti/${instituteId}`, {
                method: 'DELETE'
            });

            this.state.institutes.delete(instituteId);
            this.state.machines.delete(instituteId);
            this.renderInstitutes();

            Utils.showToast('Istituto eliminato con successo', 'success');
        } catch (error) {
            console.error('Errore eliminazione istituto:', error);
            Utils.showToast(error.message || 'Errore durante l\'eliminazione', 'error');
        }
    }

    /**
     * Valida i dati di un istituto
     */
    validateInstituteData(data) {
        const errors = [];

        const validations = {
            nome: {
                condition: val => val?.trim().length >= 3,
                message: 'Il nome deve essere di almeno 3 caratteri'
            },
            indirizzo: {
                condition: val => val?.trim().length >= 5,
                message: 'L\'indirizzo deve essere di almeno 5 caratteri'
            },
            citta: {
                condition: val => val?.trim().length >= 2,
                message: 'La città deve essere specificata'
            },
            provincia: {
                condition: val => val?.trim().length === 2,
                message: 'La provincia deve essere di 2 caratteri'
            },
            cap: {
                condition: val => /^\d{5}$/.test(val),
                message: 'Il CAP deve essere di 5 cifre'
            },
            telefono: {
                condition: val => !val || /^\+?[\d\s-]{10,}$/.test(val),
                message: 'Il formato del telefono non è valido'
            },
            email: {
                condition: val => !val || Utils.validateEmail(val),
                message: 'Il formato dell\'email non è valido'
            }
        };

        Object.entries(validations).forEach(([field, validation]) => {
            if (!validation.condition(data[field])) {
                errors.push(validation.message);
            }
        });

        if (errors.length > 0) {
            throw new Error(errors.join('\n'));
        }
    }

    /**
     * Renderizza l'interfaccia utente
     */
    renderUI() {
        this.renderInstitutes();
        this.renderMachinesSummary();
    }

    /**
     * Renderizza l'elenco degli istituti
     */
    renderInstitutes() {
        const filteredInstitutes = Array.from(this.state.institutes.values())
            .filter(this.filterInstitute.bind(this))
            .sort((a, b) => a.nome.localeCompare(b.nome));

        const start = (this.state.currentPage - 1) * this.state.itemsPerPage;
        const paginatedInstitutes = filteredInstitutes.slice(
            start, 
            start + this.state.itemsPerPage
        );

        this.elements.institutesList.innerHTML = paginatedInstitutes
            .map(institute => this.renderInstituteCard(institute))
            .join('');

        this.renderPagination(filteredInstitutes.length);
    }

    /**
     * Renderizza una card istituto
     */
    renderInstituteCard(institute) {
        const machines = this.state.machines.get(institute.id) || { 
            totalMachines: 0, 
            activeMachines: 0 
        };

        return `
            <div class="institute-card" data-id="${institute.id}">
                <div class="card-header">
                    <h3>${Utils.escapeHtml(institute.nome)}</h3>
                    <div class="machines-count" title="Macchine attive / totali">
                        <i class="fas fa-coffee"></i>
                        ${machines.activeMachines}/${machines.totalMachines}
                    </div>
                </div>
                <div class="card-body">
                    <p>
                        <i class="fas fa-map-marker-alt"></i>
                        ${Utils.escapeHtml(institute.indirizzo)}<br>
                        ${Utils.escapeHtml(institute.cap)} ${Utils.escapeHtml(institute.citta)} (${Utils.escapeHtml(institute.provincia)})
                    </p>
                    ${institute.telefono ? `
                        <p>
                            <i class="fas fa-phone"></i>
                            ${Utils.escapeHtml(institute.telefono)}
                        </p>
                    ` : ''}
                    ${institute.email ? `
                        <p>
                            <i class="fas fa-envelope"></i>
                            ${Utils.escapeHtml(institute.email)}
                        </p>
                    ` : ''}
                </div>
                <div class="card-actions">
                    <button class="btn btn-edit" 
                            onclick="instituteManager.openEditModal(${institute.id})"
                            title="Modifica istituto">
                        <i class="fas fa-edit"></i>
                    </button>
                    <button class="btn btn-danger" 
                            onclick="instituteManager.handleDeleteInstitute(${institute.id})"
                            title="Elimina istituto"
                            ${machines.totalMachines > 0 ? 'disabled' : ''}>
                        <i class="fas fa-trash"></i>
                    </button>
                    <a href="/admin/machines?institute=${institute.id}" 
                       class="btn btn-primary"
                       title="Gestisci macchine">
                        <i class="fas fa-cog"></i>
                    </a>
                </div>
            </div>
        `;
    }

    /**
     * Filtra gli istituti in base ai criteri
     */
    filterInstitute(institute) {
        if (!this.state.filters.search) return true;

        const searchTerm = this.state.filters.search.toLowerCase();
        return (
            institute.nome.toLowerCase().includes(searchTerm) ||
            institute.citta.toLowerCase().includes(searchTerm) ||
            institute.indirizzo.toLowerCase().includes(searchTerm) ||
            institute.provincia.toLowerCase().includes(searchTerm)
        );
    }

    /**
     * Renderizza il riepilogo delle macchine
     */
    renderMachinesSummary() {
        const summary = Array.from(this.state.machines.values()).reduce(
            (acc, curr) => ({
                totalMachines: acc.totalMachines + curr.totalMachines,
                activeMachines: acc.activeMachines + curr.activeMachines
            }),
            { totalMachines: 0, activeMachines: 0 }
        );

        const activePercentage = summary.totalMachines > 0
            ? Math.round((summary.activeMachines / summary.totalMachines) * 100)
            : 0;

        this.elements.machinesSummary.innerHTML = `
            <div class="summary-grid">
                <div class="summary-card">
                    <div class="summary-icon">
                        <i class="fas fa-coffee"></i>
                    <div class="summary-content">
                        <div class="summary-value">${summary.totalMachines}</div>
                        <div class="summary-label">Macchine Totali</div>
                    </div>
                </div>
                <div class="summary-card">
                    <div class="summary-icon">
                        <i class="fas fa-check-circle"></i>
                    </div>
                    <div class="summary-content">
                        <div class="summary-value">${summary.activeMachines}</div>
                        <div class="summary-label">Macchine Attive</div>
                    </div>
                </div>
                <div class="summary-card">
                    <div class="summary-icon">
                        <i class="fas fa-percentage"></i>
                    </div>
                    <div class="summary-content">
                        <div class="summary-value">${activePercentage}%</div>
                        <div class="summary-label">Percentuale Attive</div>
                    </div>
                </div>
            </div>
        `;
    }

    /**
     * Renderizza la paginazione
     */
    renderPagination(totalItems) {
        const totalPages = Math.ceil(totalItems / this.state.itemsPerPage);
        if (totalPages <= 1) {
            this.elements.pagination.innerHTML = '';
            return;
        }

        let paginationHTML = '';

        // Pulsante precedente
        paginationHTML += `
            <button class="btn btn-page" 
                    ${this.state.currentPage === 1 ? 'disabled' : ''}
                    onclick="instituteManager.changePage(${this.state.currentPage - 1})">
                <i class="fas fa-chevron-left"></i>
            </button>
        `;

        // Numeri pagina
        for (let i = 1; i <= totalPages; i++) {
            if (i === 1 || i === totalPages || 
                (i >= this.state.currentPage - 1 && i <= this.state.currentPage + 1)) {
                paginationHTML += `
                    <button class="btn btn-page ${i === this.state.currentPage ? 'active' : ''}"
                            onclick="instituteManager.changePage(${i})">
                        ${i}
                    </button>
                `;
            } else if (i === this.state.currentPage - 2 || i === this.state.currentPage + 2) {
                paginationHTML += '<span class="pagination-dots">...</span>';
            }
        }

        // Pulsante successivo
        paginationHTML += `
            <button class="btn btn-page" 
                    ${this.state.currentPage === totalPages ? 'disabled' : ''}
                    onclick="instituteManager.changePage(${this.state.currentPage + 1})">
                <i class="fas fa-chevron-right"></i>
            </button>
        `;

        this.elements.pagination.innerHTML = paginationHTML;
    }

    /**
     * Cambia pagina
     */
    changePage(page) {
        this.state.currentPage = page;
        this.renderInstitutes();
        // Scroll to top
        window.scrollTo({top: 0, behavior: 'smooth'});
    }

    /**
     * Apre il modale di modifica
     */
    openEditModal(instituteId) {
        const institute = this.state.institutes.get(instituteId);
        if (!institute) return;

        const modalContent = `
            <form id="editInstituteForm" class="institute-form">
                <input type="hidden" name="id" value="${institute.id}">
                
                <div class="form-group">
                    <label for="nome">Nome Istituto</label>
                    <input type="text" id="nome" name="nome" 
                           value="${Utils.escapeHtml(institute.nome)}" required
                           minlength="3" maxlength="100">
                </div>

                <div class="form-group">
                    <label for="indirizzo">Indirizzo</label>
                    <input type="text" id="indirizzo" name="indirizzo" 
                           value="${Utils.escapeHtml(institute.indirizzo)}" required
                           minlength="5" maxlength="200">
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="citta">Città</label>
                        <input type="text" id="citta" name="citta" 
                               value="${Utils.escapeHtml(institute.citta)}" required
                               minlength="2" maxlength="100">
                    </div>
                    
                    <div class="form-group">
                        <label for="provincia">Provincia</label>
                        <input type="text" id="provincia" name="provincia" 
                               value="${Utils.escapeHtml(institute.provincia)}" required
                               pattern="[A-Za-z]{2}" maxlength="2"
                               oninput="this.value = this.value.toUpperCase()">
                    </div>

                    <div class="form-group">
                        <label for="cap">CAP</label>
                        <input type="text" id="cap" name="cap" 
                               value="${institute.cap}" required
                               pattern="\\d{5}" maxlength="5">
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label for="telefono">Telefono</label>
                        <input type="tel" id="telefono" name="telefono" 
                               value="${Utils.escapeHtml(institute.telefono || '')}"
                               pattern="\\+?[\\d\\s-]{10,}">
                    </div>

                    <div class="form-group">
                        <label for="email">Email</label>
                        <input type="email" id="email" name="email" 
                               value="${Utils.escapeHtml(institute.email || '')}">
                    </div>
                </div>

                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" 
                            onclick="instituteManager.closeModals()">
                        Annulla
                    </button>
                    <button type="submit" class="btn btn-primary">
                        Salva Modifiche
                    </button>
                </div>
            </form>
        `;

        const modal = this.elements.editInstituteModal;
        modal.querySelector('.modal-content').innerHTML = modalContent;
        modal.querySelector('.modal-title').textContent = 'Modifica Istituto';
        modal.classList.remove('hidden');

        const form = document.getElementById('editInstituteForm');
        form.addEventListener('submit', (e) => {
            e.preventDefault();
            this.handleEditInstitute(instituteId, new FormData(e.target));
        });
    }

    /**
     * Chiude tutti i modali
     */
    closeModals() {
        document.querySelectorAll('.modal').forEach(modal => {
            modal.classList.add('hidden');
        });
    }

    /**
     * Verifica la presenza di modifiche non salvate
     */
    hasUnsavedChanges() {
        const forms = document.querySelectorAll('form');
        return Array.from(forms).some(form => {
            const data = new FormData(form);
            return Array.from(data.entries()).some(([name, value]) => {
                const input = form.querySelector(`[name="${name}"]`);
                return input && input.defaultValue !== value;
            });
        });
    }
}

// Inizializzazione
let instituteManager = null;

document.addEventListener('DOMContentLoaded', () => {
    instituteManager = new InstituteManager();
    // Esponi l'istanza globalmente per i listener inline
    window.instituteManager = instituteManager;
});

export default InstituteManager;

================
File: src/main/resources/public/js/admin/machines.js
================
/**
 * Gestione Macchine Distributrici
 * Gestisce le operazioni CRUD e il monitoraggio delle macchine distributrici
 */
import mqttClient from '../common/mqtt.js';
import Utils from '../common/utils.js';
import auth from '../common/authentication.js';

class MachineManager {
    constructor() {
        // Verifica autenticazione
        auth.protectAdminRoute();

        this.initializeElements();
        this.initializeState();
        this.initialize();
    }

    /**
     * Inizializza gli elementi DOM
     */
    initializeElements() {
        this.elements = {
            machinesList: document.getElementById('machinesList'),
            addMachineForm: document.getElementById('addMachineForm'),
            editMachineModal: document.getElementById('editMachineModal'),
            searchInput: document.getElementById('searchMachine'),
            filterInstitute: document.getElementById('filterInstitute'),
            filterStatus: document.getElementById('filterStatus'),
            pagination: document.getElementById('pagination'),
            summary: document.getElementById('machineSummary')
        };

        // Verifica elementi richiesti
        Object.entries(this.elements).forEach(([key, element]) => {
            if (!element) {
                throw new Error(`Elemento DOM non trovato: ${key}`);
            }
        });
    }

    /**
     * Inizializza lo stato dell'applicazione
     */
    initializeState() {
        this.state = {
            machines: new Map(),
            institutes: new Map(),
            currentPage: 1,
            itemsPerPage: 10,
            filters: {
                institute: '',
                status: '',
                search: ''
            }
        };
    }

    /**
     * Inizializza il componente
     */
    async initialize() {
        try {
            Utils.toggleLoading(true);
            
            // Carica dati iniziali
            await Promise.all([
                this.loadInstitutes(),
                this.loadMachines()
            ]);

            // Setup MQTT e listeners
            await this.initializeMQTTSubscriptions();
            this.setupEventListeners();
            
            // Inizializza UI
            this.populateFilters();
            this.renderUI();

            console.log('Gestore macchine inizializzato');
        } catch (error) {
            console.error('Errore inizializzazione:', error);
            Utils.showToast('Errore durante l\'inizializzazione', 'error');
        } finally {
            Utils.toggleLoading(false);
        }
    }

    /**
     * Carica le macchine dal backend
     */
    async loadMachines() {
        try {
            const machines = await Utils.apiCall('/api/macchine');
            machines.forEach(machine => {
                this.state.machines.set(machine.id, this.normalizeMachineData(machine));
            });
        } catch (error) {
            console.error('Errore caricamento macchine:', error);
            throw error;
        }
    }

    /**
     * Carica gli istituti dal backend
     */
    async loadInstitutes() {
        try {
            const institutes = await Utils.apiCall('/api/istituti');
            institutes.forEach(institute => {
                this.state.institutes.set(institute.id, institute);
            });
        } catch (error) {
            console.error('Errore caricamento istituti:', error);
            throw error;
        }
    }

    /**
     * Normalizza i dati della macchina
     */
    normalizeMachineData(machine) {
        return {
            id: machine.id,
            istitutoId: machine.istitutoId,
            stato: machine.statoId,
            cassaAttuale: machine.cassaAttuale || 0,
            cassaMassima: machine.cassaMassima,
            cialdaAttuale: machine.cialdaAttuale || 0,
            cialdaMassima: machine.cialdaMassima,
            manutenzione: machine.manutenzione || null,
            ultimaModifica: machine.ultimaModifica
        };
    }

    /**
     * Configura le sottoscrizioni MQTT
     */
    async initializeMQTTSubscriptions() {
        const topics = [
            {
                topic: 'macchine/+/stato',
                handler: (topic, message) => {
                    const machineId = parseInt(topic.split('/')[1]);
                    this.handleMachineStatusUpdate(machineId, JSON.parse(message));
                }
            },
            {
                topic: 'macchine/+/allarmi',
                handler: (topic, message) => {
                    const machineId = parseInt(topic.split('/')[1]);
                    this.handleMachineAlarm(machineId, JSON.parse(message));
                }
            },
            {
                topic: 'macchine/+/manutenzione',
                handler: (topic, message) => {
                    const machineId = parseInt(topic.split('/')[1]);
                    this.handleMaintenanceUpdate(machineId, JSON.parse(message));
                }
            }
        ];

        try {
            await Promise.all(
                topics.map(({ topic, handler }) => 
                    mqttClient.subscribe(topic, handler)
                )
            );
        } catch (error) {
            console.error('Errore sottoscrizione MQTT:', error);
            throw error;
        }
    }

    /**
     * Configura i listener degli eventi
     */
    setupEventListeners() {
        // Form aggiunta macchina
        this.elements.addMachineForm?.addEventListener('submit', 
            this.handleAddMachine.bind(this));

        // Filtri e ricerca
        this.elements.filterInstitute?.addEventListener('change', 
            () => this.updateFilters('institute'));
            
        this.elements.filterStatus?.addEventListener('change',
            () => this.updateFilters('status'));

        this.elements.searchInput?.addEventListener('input',
            Utils.debounce(() => this.updateFilters('search'), 300));

        // Gestione modali
        document.querySelectorAll('.modal-close').forEach(button => {
            button.addEventListener('click', () => this.closeModals());
        });

        // Handler globali per azioni macchina
        window.editMachine = (id) => this.openEditModal(id);
        window.deleteMachine = (id) => this.handleDeleteMachine(id);
    }

    /**
     * Aggiorna i filtri e rigenera la lista
     */
    updateFilters(filterType) {
        const newValue = filterType === 'search' 
            ? this.elements.searchInput.value
            : this.elements[`filter${filterType.charAt(0).toUpperCase() + filterType.slice(1)}`].value;

        this.state.filters[filterType] = newValue;
        this.state.currentPage = 1;
        this.renderMachines();
    }

    /**
     * Gestisce l'aggiunta di una nuova macchina
     */
    async handleAddMachine(event) {
        event.preventDefault();
        const form = event.target;
        const formData = new FormData(form);

        try {
            Utils.toggleLoading(true, form);

            const machineData = {
                istitutoId: parseInt(formData.get('istituto')),
                cassaMassima: parseFloat(formData.get('cassaMassima')),
                cialdaMassima: parseInt(formData.get('cialdaMassima'))
            };

            // Validazione
            this.validateMachineData(machineData);

            const newMachine = await Utils.apiCall('/api/macchine', {
                method: 'POST',
                body: JSON.stringify(machineData)
            });

            this.state.machines.set(newMachine.id, this.normalizeMachineData(newMachine));
            this.renderMachines();

            Utils.showToast('Macchina aggiunta con successo', 'success');
            form.reset();

        } catch (error) {
            console.error('Errore aggiunta macchina:', error);
            Utils.showToast(error.message || 'Errore durante l\'aggiunta', 'error');
        } finally {
            Utils.toggleLoading(false, form);
        }
    }

    /**
     * Gestisce la modifica di una macchina
     */
    async handleEditMachine(machineId, formData) {
        try {
            Utils.toggleLoading(true);

            const machineData = {
                cassaMassima: parseFloat(formData.get('cassaMassima')),
                cialdaMassima: parseInt(formData.get('cialdaMassima')),
                statoId: parseInt(formData.get('stato'))
            };

            this.validateMachineData(machineData);

            const updatedMachine = await Utils.apiCall(`/api/macchine/${machineId}`, {
                method: 'PUT',
                body: JSON.stringify(machineData)
            });

            this.state.machines.set(machineId, this.normalizeMachineData(updatedMachine));
            this.renderMachines();
            this.closeModals();

            Utils.showToast('Macchina aggiornata con successo', 'success');
        } catch (error) {
            console.error('Errore modifica macchina:', error);
            Utils.showToast(error.message || 'Errore durante la modifica', 'error');
        } finally {
            Utils.toggleLoading(false);
        }
    }

    /**
     * Gestisce l'eliminazione di una macchina
     */
    async handleDeleteMachine(machineId) {
        const machine = this.state.machines.get(machineId);
        if (!machine) return;

        const institute = this.state.institutes.get(machine.istitutoId);
        const confirmMessage = `Sei sicuro di voler eliminare la macchina #${machineId}${
            institute ? ` dall'istituto "${institute.nome}"` : ''
        }?`;

        if (!confirm(confirmMessage)) return;

        try {
            Utils.toggleLoading(true);

            await Utils.apiCall(`/api/macchine/${machineId}`, {
                method: 'DELETE'
            });

            this.state.machines.delete(machineId);
            this.renderMachines();

            Utils.showToast('Macchina eliminata con successo', 'success');
        } catch (error) {
            console.error('Errore eliminazione macchina:', error);
            Utils.showToast(error.message || 'Errore durante l\'eliminazione', 'error');
        } finally {
            Utils.toggleLoading(false);
        }
    }

    /**
     * Gestisce l'aggiornamento dello stato di una macchina via MQTT
     */
    handleMachineStatusUpdate(machineId, status) {
        const machine = this.state.machines.get(machineId);
        if (!machine) return;

        machine.stato = status.statoId;
        machine.ultimaModifica = new Date().toISOString();

        this.renderMachineCard(machine);
        this.updateMachineSummary();
    }

    /**
     * Gestisce gli allarmi di una macchina
     */
    handleMachineAlarm(machineId, alarm) {
        const machine = this.state.machines.get(machineId);
        if (!machine) return;

        const institute = this.state.institutes.get(machine.istitutoId);
        const location = institute ? ` presso ${institute.nome}` : '';
        
        Utils.showToast(
            `Allarme macchina #${machineId}${location}: ${alarm.messaggio}`,
            'warning'
        );

        this.renderMachineCard(machine);
    }

    /**
     * Gestisce gli aggiornamenti di manutenzione
     */
    handleMaintenanceUpdate(machineId, update) {
        const machine = this.state.machines.get(machineId);
        if (!machine) return;

        machine.manutenzione = update;
        machine.ultimaModifica = new Date().toISOString();

        this.renderMachineCard(machine);
        this.updateMachineSummary();
    }

    /**
     * Valida i dati di una macchina
     */
    validateMachineData(data) {
        const errors = [];

        // Valida istituto se presente
        if (data.istitutoId !== undefined) {
            if (!this.state.institutes.has(data.istitutoId)) {
                errors.push('Istituto non valido');
            }
        }

        // Valida cassa massima
        if (data.cassaMassima !== undefined) {
            if (isNaN(data.cassaMassima) || data.cassaMassima <= 0) {
                errors.push('La cassa massima deve essere un numero positivo');
            }
        }

        // Valida capacità cialde
        if (data.cialdaMassima !== undefined) {
            if (!Number.isInteger(data.cialdaMassima) || data.cialdaMassima <= 0) {
                errors.push('La capacità cialde deve essere un numero intero positivo');
            }
        }

        // Valida stato se presente
        if (data.statoId !== undefined) {
            if (![1, 2, 3].includes(data.statoId)) {
                errors.push('Stato non valido');
            }
        }

        if (errors.length > 0) {
            throw new Error(errors.join('\n'));
        }
    }

    /**
     * Renderizza l'interfaccia utente
     */
    renderUI() {
        this.renderMachines();
        this.updateMachineSummary();
    }

    /**
     * Renderizza l'elenco delle macchine
     */
    renderMachines() {
        const filteredMachines = Array.from(this.state.machines.values())
            .filter(this.filterMachine.bind(this))
            .sort((a, b) => b.ultimaModifica.localeCompare(a.ultimaModifica));

        const start = (this.state.currentPage - 1) * this.state.itemsPerPage;
        const paginatedMachines = filteredMachines.slice(
            start, 
            start + this.state.itemsPerPage);

            this.elements.machinesList.innerHTML = paginatedMachines
                .map(machine => this.renderMachineCard(machine))
                .join('');
    
            this.renderPagination(filteredMachines.length);
        }
    
        /**
         * Filtra le macchine in base ai criteri selezionati
         */
        filterMachine(machine) {
            const { institute, status, search } = this.state.filters;
    
            // Filtro istituto
            if (institute && machine.istitutoId !== parseInt(institute)) {
                return false;
            }
    
            // Filtro stato
            if (status && machine.stato !== parseInt(status)) {
                return false;
            }
    
            // Filtro ricerca
            if (search) {
                const searchTerm = search.toLowerCase();
                const institute = this.state.institutes.get(machine.istitutoId);
                return machine.id.toString().includes(searchTerm) ||
                       (institute && institute.nome.toLowerCase().includes(searchTerm));
            }
    
            return true;
        }
    
        /**
         * Renderizza una singola card macchina
         */
        renderMachineCard(machine) {
            const institute = this.state.institutes.get(machine.istitutoId);
            const status = this.getMachineStatus(machine.stato);
    
            return `
                <div class="machine-card" data-id="${machine.id}">
                    <div class="card-header">
                        <div class="header-title">
                            <h3>Distributore #${machine.id}</h3>
                            <span class="status-badge ${status.class}">
                                <i class="fas ${status.icon}"></i>
                                ${status.text}
                            </span>
                        </div>
                        ${institute ? `
                            <div class="header-subtitle">
                                <i class="fas fa-building"></i>
                                ${Utils.escapeHtml(institute.nome)}
                            </div>
                        ` : ''}
                    </div>
                    
                    <div class="card-body">
                        <div class="stats-grid">
                            <div class="stat-item">
                                <div class="stat-label">
                                    <i class="fas fa-euro-sign"></i> Cassa
                                </div>
                                <div class="stat-value">
                                    ${Utils.formatCurrency(machine.cassaAttuale)} / 
                                    ${Utils.formatCurrency(machine.cassaMassima)}
                                </div>
                                <div class="stat-bar">
                                    <div class="stat-progress" style="width: ${
                                        (machine.cassaAttuale / machine.cassaMassima * 100).toFixed(1)
                                    }%"></div>
                                </div>
                            </div>
                            
                            <div class="stat-item">
                                <div class="stat-label">
                                    <i class="fas fa-box"></i> Cialde
                                </div>
                                <div class="stat-value">
                                    ${machine.cialdaAttuale} / ${machine.cialdaMassima}
                                </div>
                                <div class="stat-bar">
                                    <div class="stat-progress" style="width: ${
                                        (machine.cialdaAttuale / machine.cialdaMassima * 100).toFixed(1)
                                    }%"></div>
                                </div>
                            </div>
                        </div>
    
                        ${machine.manutenzione ? `
                            <div class="maintenance-info">
                                <i class="fas fa-tools"></i>
                                Ultima manutenzione: ${Utils.formatDate(machine.manutenzione.data)}
                                <br>
                                <small>${Utils.escapeHtml(machine.manutenzione.note || '')}</small>
                            </div>
                        ` : ''}
                    </div>
    
                    <div class="card-actions">
                        <button class="btn btn-edit" 
                                onclick="machineManager.openEditModal(${machine.id})"
                                title="Modifica macchina">
                            <i class="fas fa-edit"></i>
                        </button>
    
                        <button class="btn btn-danger"
                                onclick="machineManager.handleDeleteMachine(${machine.id})"
                                title="Elimina macchina"
                                ${machine.stato !== 3 ? 'disabled' : ''}>
                            <i class="fas fa-trash"></i>
                        </button>
    
                        <button class="btn btn-secondary"
                                onclick="machineManager.handleMaintenanceRequest(${machine.id})"
                                title="Richiedi manutenzione"
                                ${machine.stato === 2 ? 'disabled' : ''}>
                            <i class="fas fa-tools"></i>
                        </button>
    
                        <a href="/admin/machines/${machine.id}/details" 
                           class="btn btn-primary"
                           title="Visualizza dettagli">
                            <i class="fas fa-info-circle"></i>
                        </a>
                    </div>
                </div>
            `;
        }
    
        /**
         * Ottiene lo stato formattato di una macchina
         */
        getMachineStatus(stato) {
            const statusMap = {
                1: { 
                    class: 'status-active',
                    icon: 'fa-check-circle',
                    text: 'Attiva'
                },
                2: {
                    class: 'status-maintenance',
                    icon: 'fa-tools',
                    text: 'In Manutenzione'
                },
                3: {
                    class: 'status-inactive',
                    icon: 'fa-times-circle',
                    text: 'Fuori Servizio'
                }
            };
    
            return statusMap[stato] || {
                class: 'status-unknown',
                icon: 'fa-question-circle',
                text: 'Stato Sconosciuto'
            };
        }
    
        /**
         * Aggiorna il riepilogo delle macchine
         */
        updateMachineSummary() {
            const summary = Array.from(this.state.machines.values()).reduce(
                (acc, machine) => {
                    acc.total++;
                    if (machine.stato === 1) acc.active++;
                    if (machine.stato === 2) acc.maintenance++;
                    if (machine.cassaAttuale >= machine.cassaMassima * 0.9) acc.cashAlert++;
                    if (machine.cialdaAttuale <= machine.cialdaMassima * 0.1) acc.podsAlert++;
                    return acc;
                },
                { total: 0, active: 0, maintenance: 0, cashAlert: 0, podsAlert: 0 }
            );
    
            this.elements.summary.innerHTML = `
                <div class="summary-grid">
                    <div class="summary-card">
                        <div class="summary-icon active">
                            <i class="fas fa-check-circle"></i>
                        </div>
                        <div class="summary-content">
                            <div class="summary-value">${summary.active}/${summary.total}</div>
                            <div class="summary-label">Macchine Attive</div>
                        </div>
                    </div>
    
                    <div class="summary-card">
                        <div class="summary-icon warning">
                            <i class="fas fa-tools"></i>
                        </div>
                        <div class="summary-content">
                            <div class="summary-value">${summary.maintenance}</div>
                            <div class="summary-label">In Manutenzione</div>
                        </div>
                    </div>
    
                    <div class="summary-card">
                        <div class="summary-icon ${summary.cashAlert > 0 ? 'danger' : 'success'}">
                            <i class="fas fa-euro-sign"></i>
                        </div>
                        <div class="summary-content">
                            <div class="summary-value">${summary.cashAlert}</div>
                            <div class="summary-label">Cassa da Svuotare</div>
                        </div>
                    </div>
    
                    <div class="summary-card">
                        <div class="summary-icon ${summary.podsAlert > 0 ? 'warning' : 'success'}">
                            <i class="fas fa-box"></i>
                        </div>
                        <div class="summary-content">
                            <div class="summary-value">${summary.podsAlert}</div>
                            <div class="summary-label">Cialde in Esaurimento</div>
                        </div>
                    </div>
                </div>
            `;
        }
    
        /**
         * Renderizza la paginazione
         */
        renderPagination(totalItems) {
            const totalPages = Math.ceil(totalItems / this.state.itemsPerPage);
            if (totalPages <= 1) {
                this.elements.pagination.innerHTML = '';
                return;
            }
    
            let paginationHTML = `
                <button class="btn btn-page" 
                        onclick="machineManager.changePage(${this.state.currentPage - 1})"
                        ${this.state.currentPage === 1 ? 'disabled' : ''}>
                    <i class="fas fa-chevron-left"></i>
                </button>
            `;
    
            for (let i = 1; i <= totalPages; i++) {
                if (i === 1 || i === totalPages || 
                    (i >= this.state.currentPage - 2 && i <= this.state.currentPage + 2)) {
                    paginationHTML += `
                        <button class="btn btn-page ${i === this.state.currentPage ? 'active' : ''}"
                                onclick="machineManager.changePage(${i})">
                            ${i}
                        </button>
                    `;
                } else if (i === this.state.currentPage - 3 || i === this.state.currentPage + 3) {
                    paginationHTML += '<span class="pagination-dots">...</span>';
                }
            }
    
            paginationHTML += `
                <button class="btn btn-page" 
                        onclick="machineManager.changePage(${this.state.currentPage + 1})"
                        ${this.state.currentPage === totalPages ? 'disabled' : ''}>
                    <i class="fas fa-chevron-right"></i>
                </button>
            `;
    
            this.elements.pagination.innerHTML = paginationHTML;
        }
    
        /**
         * Cambia pagina
         */
        changePage(page) {
            this.state.currentPage = page;
            this.renderMachines();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
    
        /**
         * Popola i filtri con i dati disponibili
         */
        populateFilters() {
            // Select istituti
            let instituteOptions = '<option value="">Tutti gli istituti</option>';
            Array.from(this.state.institutes.values())
                .sort((a, b) => a.nome.localeCompare(b.nome))
                .forEach(institute => {
                    instituteOptions += `
                        <option value="${institute.id}">
                            ${Utils.escapeHtml(institute.nome)}
                        </option>
                    `;
                });
            this.elements.filterInstitute.innerHTML = instituteOptions;
    
            // Select stati
            this.elements.filterStatus.innerHTML = `
                <option value="">Tutti gli stati</option>
                <option value="1">Attive</option>
                <option value="2">In Manutenzione</option>
                <option value="3">Fuori Servizio</option>
            `;
        }
    
        /**
         * Pulisce le risorse
         */
        destroy() {
            // Rimuovi sottoscrizioni MQTT
            const topics = [
                'macchine/+/stato',
                'macchine/+/allarmi',
                'macchine/+/manutenzione'
            ];
            
            topics.forEach(topic => mqttClient.unsubscribe(topic));
            
            // Rimuovi handler globali
            delete window.machineManager;
            delete window.editMachine;
            delete window.deleteMachine;
        }
    }
    
    // Inizializzazione
    let machineManager = null;
    
    document.addEventListener('DOMContentLoaded', () => {
        machineManager = new MachineManager();
        window.machineManager = machineManager;
    });
    
    export default MachineManager;

================
File: src/main/resources/public/js/admin/maintenance.js
================
/**
 * Gestione Manutenzioni
 * Gestisce le richieste di manutenzione e gli interventi tecnici
 */
import mqttClient from '../common/mqtt.js';
import Utils from '../common/utils.js';
import auth from '../common/authentication.js';

class MaintenanceManager {
    constructor() {
        // Verifica autenticazione
        auth.protectEmployeeRoute();

        this.initializeElements();
        this.initializeState();
        this.initialize();
    }

    /**
     * Inizializza gli elementi DOM
     */
    initializeElements() {
        this.elements = {
            maintenanceList: document.getElementById('maintenanceList'),
            completedList: document.getElementById('completedList'),
            filterStatus: document.getElementById('filterStatus'),
            filterTechnician: document.getElementById('filterTechnician'),
            filterPriority: document.getElementById('filterPriority'),
            searchInput: document.getElementById('searchMaintenance'),
            assignModal: document.getElementById('assignTechnicianModal'),
            completeModal: document.getElementById('completeMaintenanceModal'),
            pagination: document.getElementById('maintenancePagination'),
            summary: document.getElementById('maintenanceSummary')
        };

        // Verifica elementi richiesti
        Object.entries(this.elements).forEach(([key, element]) => {
            if (!element) {
                throw new Error(`Elemento DOM non trovato: ${key}`);
            }
        });
    }

    /**
     * Inizializza lo stato dell'applicazione
     */
    initializeState() {
        this.state = {
            activeRequests: new Map(),
            completedRequests: new Map(),
            technicians: new Map(),
            currentPage: 1,
            itemsPerPage: 10,
            filters: {
                status: '',
                technician: '',
                priority: '',
                search: ''
            }
        };
    }

    /**
     * Inizializza il componente
     */
    async initialize() {
        try {
            Utils.toggleLoading(true);

            // Carica dati iniziali
            await Promise.all([
                this.loadMaintenanceData(),
                this.initializeMQTTSubscriptions()
            ]);

            // Setup UI
            this.setupEventListeners();
            this.populateFilters();
            this.renderUI();

            console.log('Gestore manutenzioni inizializzato');
        } catch (error) {
            console.error('Errore inizializzazione:', error);
            Utils.showToast('Errore durante l\'inizializzazione', 'error');
        } finally {
            Utils.toggleLoading(false);
        }
    }

    /**
     * Carica i dati delle manutenzioni e dei tecnici
     */
    async loadMaintenanceData() {
        try {
            const [active, completed, technicians] = await Promise.all([
                Utils.apiCall('/api/manutenzione/attive'),
                Utils.apiCall('/api/manutenzione/completate'),
                Utils.apiCall('/api/tecnici')
            ]);

            // Manutenzioni attive
            active.forEach(request => {
                this.state.activeRequests.set(request.id, this.normalizeRequest(request));
            });

            // Manutenzioni completate
            completed.forEach(request => {
                this.state.completedRequests.set(request.id, this.normalizeRequest(request));
            });

            // Tecnici
            technicians.forEach(tech => {
                this.state.technicians.set(tech.id, tech);
            });

        } catch (error) {
            console.error('Errore caricamento dati:', error);
            throw error;
        }
    }

    /**
     * Normalizza i dati di una richiesta
     */
    normalizeRequest(request) {
        return {
            id: request.id,
            macchinaId: request.macchinaId,
            tecnicoId: request.tecnicoId,
            stato: request.statoId,
            priorita: request.priorita,
            descrizione: request.descrizione,
            dataRichiesta: request.dataRichiesta,
            dataCompletamento: request.dataCompletamento,
            note: request.note || '',
            partiSostituite: request.partiSostituite || []
        };
    }

    /**
     * Configura le sottoscrizioni MQTT
     */
    async initializeMQTTSubscriptions() {
        const topics = [
            {
                topic: 'manutenzione/richieste/nuova',
                handler: (topic, message) => {
                    const request = JSON.parse(message);
                    this.handleNewRequest(request);
                }
            },
            {
                topic: 'manutenzione/stato/+',
                handler: (topic, message) => {
                    const requestId = parseInt(topic.split('/').pop());
                    this.handleStatusUpdate(requestId, JSON.parse(message));
                }
            },
            {
                topic: 'manutenzione/completata/+',
                handler: (topic, message) => {
                    const requestId = parseInt(topic.split('/').pop());
                    this.handleCompletion(requestId, JSON.parse(message));
                }
            }
        ];

        try {
            await Promise.all(
                topics.map(({ topic, handler }) => 
                    mqttClient.subscribe(topic, handler)
                )
            );
        } catch (error) {
            console.error('Errore sottoscrizione MQTT:', error);
            throw error;
        }
    }

    /**
     * Configura i listener degli eventi
     */
    setupEventListeners() {
        // Filtri
        ['Status', 'Technician', 'Priority'].forEach(filter => {
            const element = this.elements[`filter${filter}`];
            element?.addEventListener('change', () => {
                this.updateFilters(filter.toLowerCase());
            });
        });

        // Ricerca
        this.elements.searchInput?.addEventListener('input',
            Utils.debounce(() => this.updateFilters('search'), 300)
        );

        // Modali
        document.querySelectorAll('.modal-close').forEach(button => {
            button.addEventListener('click', () => this.closeModals());
        });

        // Handler globali per azioni manutenzione
        window.maintenanceManager = this;
        window.assignTechnician = (id) => this.openAssignModal(id);
        window.completeMaintenance = (id) => this.openCompleteModal(id);
    }

    /**
     * Aggiorna i filtri e rigenera la lista
     */
    updateFilters(filterType) {
        const newValue = filterType === 'search'
            ? this.elements.searchInput.value
            : this.elements[`filter${filterType.charAt(0).toUpperCase() + filterType.slice(1)}`].value;

        this.state.filters[filterType] = newValue;
        this.state.currentPage = 1;
        this.renderMaintenance();
    }

    /**
     * Gestisce una nuova richiesta di manutenzione
     */
    handleNewRequest(request) {
        const normalizedRequest = this.normalizeRequest(request);
        this.state.activeRequests.set(request.id, normalizedRequest);
        
        this.renderMaintenance();
        this.updateSummary();

        Utils.showToast(`
            Nuova richiesta di manutenzione per la macchina #${request.macchinaId}
            ${request.priorita === 'alta' ? ' - PRIORITÀ ALTA' : ''}
        `, 'info');
    }

    /**
     * Gestisce l'aggiornamento di stato di una richiesta
     */
    handleStatusUpdate(requestId, status) {
        const request = this.state.activeRequests.get(requestId);
        if (!request) return;

        request.stato = status.statoId;
        request.ultimoAggiornamento = new Date().toISOString();

        this.renderRequestCard(request);
        this.updateSummary();
    }

    /**
     * Gestisce il completamento di una richiesta
     */
    handleCompletion(requestId, completion) {
        const request = this.state.activeRequests.get(requestId);
        if (!request) return;

        const completedRequest = {
            ...request,
            stato: 'completata',
            dataCompletamento: completion.dataCompletamento,
            note: completion.note,
            partiSostituite: completion.partiSostituite
        };

        this.state.activeRequests.delete(requestId);
        this.state.completedRequests.set(requestId, completedRequest);

        this.renderMaintenance();
        this.updateSummary();

        Utils.showToast(`
            Manutenzione #${requestId} completata con successo
        `, 'success');
    }

    /**
     * Assegna un tecnico a una richiesta
     */
    async assignTechnician(requestId, technicianId) {
        try {
            Utils.toggleLoading(true);

            const response = await Utils.apiCall(`/api/manutenzione/${requestId}/assegna`, {
                method: 'PUT',
                body: JSON.stringify({ tecnicoId: technicianId })
            });

            const request = this.state.activeRequests.get(requestId);
            if (request) {
                request.tecnicoId = technicianId;
                request.stato = 'assegnata';
                request.ultimoAggiornamento = new Date().toISOString();
            }

            this.renderRequestCard(request);
            this.updateSummary();
            this.closeModals();

            Utils.showToast('Tecnico assegnato con successo', 'success');
        } catch (error) {
            console.error('Errore assegnazione tecnico:', error);
            Utils.showToast(error.message || 'Errore durante l\'assegnazione', 'error');
        } finally {
            Utils.toggleLoading(false);
        }
    }

    /**
     * Completa una richiesta di manutenzione
     */
    async completeMaintenance(requestId, formData) {
        try {
            Utils.toggleLoading(true);

            const completionData = {
                note: formData.get('note'),
                partiSostituite: formData.get('partiSostituite')
                    .split(',')
                    .map(part => part.trim())
                    .filter(Boolean),
                dataCompletamento: new Date().toISOString()
            };

            await Utils.apiCall(`/api/manutenzione/${requestId}/completa`, {
                method: 'PUT',
                body: JSON.stringify(completionData)
            });

            // L'aggiornamento UI sarà gestito dal messaggio MQTT
            this.closeModals();
            
        } catch (error) {
            console.error('Errore completamento manutenzione:', error);
            Utils.showToast(error.message || 'Errore durante il completamento', 'error');
        } finally {
            Utils.toggleLoading(false);
        }
    }

    /**
     * Filtra le richieste in base ai criteri
     */
    filterRequests(request) {
        const { status, technician, priority, search } = this.state.filters;

        if (status && request.stato !== status) return false;
        if (technician && request.tecnicoId !== parseInt(technician)) return false;
        if (priority && request.priorita !== priority) return false;

        if (search) {
            const searchTerm = search.toLowerCase();
            return request.id.toString().includes(searchTerm) ||
                   request.macchinaId.toString().includes(searchTerm) ||
                   request.descrizione.toLowerCase().includes(searchTerm);
        }

        return true;
    }

    /**
     * Renderizza l'interfaccia utente
     */
    renderUI() {
        this.renderMaintenance();
        this.updateSummary();
    }

    /**
     * Renderizza l'elenco delle manutenzioni
     */
    renderMaintenance() {
        const filteredRequests = Array.from(this.state.activeRequests.values())
            .filter(this.filterRequests.bind(this))
            .sort((a, b) => {
                // Prima per priorità
                const priorityOrder = { alta: 0, media: 1, bassa: 2 };
                if (a.priorita !== b.priorita) {
                    return priorityOrder[a.priorita] - priorityOrder[b.priorita];
                }
                // Poi per data richiesta
                return new Date(b.dataRichiesta) - new Date(a.dataRichiesta);
            });

        const start = (this.state.currentPage - 1) * this.state.itemsPerPage;
        const paginatedRequests = filteredRequests.slice(
            start,
            start + this.state.itemsPerPage
        );

        this.elements.maintenanceList.innerHTML = paginatedRequests
            .map(request => this.renderRequestCard(request))
            .join('');

        this.renderPagination(filteredRequests.length);
        this.renderCompletedRequests();
    }

    /**
     * Renderizza una card di richiesta manutenzione
     */
    renderRequestCard(request) {
        const technician = this.state.technicians.get(request.tecnicoId);
        const status = this.getStatusDetails(request.stato);

        return `
            <div class="maintenance-card ${status.class}" data-id="${request.id}">
                <div class="card-header">
                    <div class="header-left">
                        <h3>Richiesta #${request.id}</h3>
                        <span class="priority-badge ${request.priorita}">
                            ${this.getPriorityText(request.priorita)}
                        </span>
                    </div>
                    <div class="status-badge ${status.class}">
                        <i class="fas ${status.icon}"></i>
                        ${status.text}
                    </div>
                </div>

                <div class="card-body">
                    <div class="info-grid">
                        <div class="info-item">
                            <i class="fas fa-coffee"></i>
                            <span>Macchina #${request.macchinaId}</span>
                            </div>
                        <div class="info-item">
                            <i class="fas fa-calendar"></i>
                            <span>Richiesto: ${Utils.formatDate(request.dataRichiesta)}</span>
                        </div>
                        <div class="info-item">
                            <i class="fas fa-user-cog"></i>
                            <span>Tecnico: ${technician ? Utils.escapeHtml(technician.nome) : 'Non assegnato'}</span>
                        </div>
                    </div>

                    <div class="description">
                        <p>${Utils.escapeHtml(request.descrizione)}</p>
                    </div>

                    ${request.note ? `
                        <div class="notes">
                            <strong>Note:</strong>
                            <p>${Utils.escapeHtml(request.note)}</p>
                        </div>
                    ` : ''}
                </div>

                <div class="card-actions">
                    ${this.renderRequestActions(request)}
                </div>
            </div>
        `;
    }

    /**
     * Renderizza le azioni disponibili per una richiesta
     */
    renderRequestActions(request) {
        const actions = [];

        // Assegnazione tecnico
        if (!request.tecnicoId) {
            actions.push(`
                <button class="btn btn-primary" 
                        onclick="maintenanceManager.openAssignModal(${request.id})"
                        title="Assegna un tecnico">
                    <i class="fas fa-user-plus"></i>
                    <span>Assegna</span>
                </button>
            `);
        }

        // Completamento
        if (request.stato === 'in_corso') {
            actions.push(`
                <button class="btn btn-success"
                        onclick="maintenanceManager.openCompleteModal(${request.id})"
                        title="Completa manutenzione">
                    <i class="fas fa-check"></i>
                    <span>Completa</span>
                </button>
            `);
        }

        // Visualizzazione dettagli
        actions.push(`
            <a href="/admin/manutenzione/${request.id}/dettagli" 
               class="btn btn-info"
               title="Visualizza dettagli">
                <i class="fas fa-info-circle"></i>
                <span>Dettagli</span>
            </a>
        `);

        return actions.join('');
    }

    /**
     * Renderizza le manutenzioni completate
     */
    renderCompletedRequests() {
        const completedRequests = Array.from(this.state.completedRequests.values())
            .sort((a, b) => new Date(b.dataCompletamento) - new Date(a.dataCompletamento))
            .slice(0, 5);

        this.elements.completedList.innerHTML = completedRequests
            .map(request => this.renderCompletedCard(request))
            .join('');
    }

    /**
     * Renderizza una card di manutenzione completata
     */
    renderCompletedCard(request) {
        const technician = this.state.technicians.get(request.tecnicoId);
        
        return `
            <div class="completed-card">
                <div class="card-header">
                    <div class="header-info">
                        <h4>Manutenzione #${request.id}</h4>
                        <span class="completion-date">
                            ${Utils.formatDate(request.dataCompletamento)}
                        </span>
                    </div>
                </div>

                <div class="card-body">
                    <div class="info-grid">
                        <div class="info-item">
                            <i class="fas fa-coffee"></i>
                            <span>Macchina #${request.macchinaId}</span>
                        </div>
                        <div class="info-item">
                            <i class="fas fa-user-check"></i>
                            <span>Tecnico: ${technician ? Utils.escapeHtml(technician.nome) : 'N/D'}</span>
                        </div>
                    </div>
                    
                    ${request.partiSostituite.length > 0 ? `
                        <div class="parts-replaced">
                            <strong>Parti sostituite:</strong>
                            <ul>
                                ${request.partiSostituite.map(part => 
                                    `<li>${Utils.escapeHtml(part)}</li>`
                                ).join('')}
                            </ul>
                        </div>
                    ` : ''}

                    ${request.note ? `
                        <div class="notes">
                            <strong>Note:</strong>
                            <p>${Utils.escapeHtml(request.note)}</p>
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
    }

    /**
     * Aggiorna il riepilogo delle manutenzioni
     */
    updateSummary() {
        const summary = Array.from(this.state.activeRequests.values()).reduce(
            (acc, request) => {
                acc.total++;
                acc[request.priorita]++;
                if (request.stato === 'in_corso') acc.inProgress++;
                if (!request.tecnicoId) acc.unassigned++;
                return acc;
            },
            { total: 0, alta: 0, media: 0, bassa: 0, inProgress: 0, unassigned: 0 }
        );

        this.elements.summary.innerHTML = `
            <div class="summary-grid">
                <div class="summary-card">
                    <div class="summary-icon total">
                        <i class="fas fa-tasks"></i>
                    </div>
                    <div class="summary-content">
                        <div class="summary-value">${summary.total}</div>
                        <div class="summary-label">Richieste Totali</div>
                    </div>
                </div>

                <div class="summary-card">
                    <div class="summary-icon ${summary.alta > 0 ? 'danger' : 'success'}">
                        <i class="fas fa-exclamation-triangle"></i>
                    </div>
                    <div class="summary-content">
                        <div class="summary-value">${summary.alta}</div>
                        <div class="summary-label">Priorità Alta</div>
                    </div>
                </div>

                <div class="summary-card">
                    <div class="summary-icon ${summary.unassigned > 0 ? 'warning' : 'success'}">
                        <i class="fas fa-user-clock"></i>
                    </div>
                    <div class="summary-content">
                        <div class="summary-value">${summary.unassigned}</div>
                        <div class="summary-label">Da Assegnare</div>
                    </div>
                </div>

                <div class="summary-card">
                    <div class="summary-icon progress">
                        <i class="fas fa-cogs"></i>
                    </div>
                    <div class="summary-content">
                        <div class="summary-value">${summary.inProgress}</div>
                        <div class="summary-label">In Corso</div>
                    </div>
                </div>
            </div>
        `;
    }

    /**
     * Ottiene i dettagli di uno stato
     */
    getStatusDetails(stato) {
        return {
            'in_attesa': {
                class: 'status-waiting',
                icon: 'fa-clock',
                text: 'In Attesa'
            },
            'assegnata': {
                class: 'status-assigned',
                icon: 'fa-user-check',
                text: 'Assegnata'
            },
            'in_corso': {
                class: 'status-progress',
                icon: 'fa-cogs',
                text: 'In Corso'
            },
            'completata': {
                class: 'status-completed',
                icon: 'fa-check-circle',
                text: 'Completata'
            }
        }[stato] || {
            class: 'status-unknown',
            icon: 'fa-question-circle',
            text: 'Sconosciuto'
        };
    }

    /**
     * Ottiene il testo della priorità
     */
    getPriorityText(priority) {
        return {
            'alta': 'Alta Priorità',
            'media': 'Media Priorità',
            'bassa': 'Bassa Priorità'
        }[priority] || 'Priorità N/D';
    }

    /**
     * Apre il modale di assegnazione tecnico
     */
    openAssignModal(requestId) {
        try {
            const request = this.state.activeRequests.get(requestId);
            if (!request) {
                throw new Error('Richiesta non trovata');
            }

            // Tecnici disponibili (non assegnati ad altre richieste in corso)
            const assignedTechnicians = new Set(
                Array.from(this.state.activeRequests.values())
                    .filter(r => r.stato === 'in_corso')
                    .map(r => r.tecnicoId)
            );

            const availableTechnicians = Array.from(this.state.technicians.values())
                .filter(tech => !assignedTechnicians.has(tech.id))
                .sort((a, b) => a.nome.localeCompare(b.nome));

            if (availableTechnicians.length === 0) {
                throw new Error('Nessun tecnico disponibile al momento');
            }

            const modalContent = `
                <div class="modal-header">
                    <h3>Assegna Tecnico</h3>
                    <button class="btn-close" onclick="maintenanceManager.closeModals()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                
                <div class="modal-body">
                    <div class="request-info">
                        <p><strong>Richiesta #${request.id}</strong></p>
                        <p>Macchina #${request.macchinaId}</p>
                        <p class="priority-tag ${request.priorita}">
                            ${this.getPriorityText(request.priorita)}
                        </p>
                    </div>

                    <form id="assignForm" class="assign-form">
                        <div class="form-group">
                            <label for="technicianId">Seleziona Tecnico:</label>
                            <select id="technicianId" name="technicianId" class="form-select" required>
                                <option value="">Seleziona...</option>
                                ${availableTechnicians.map(tech => `
                                    <option value="${tech.id}">
                                        ${Utils.escapeHtml(tech.nome)} 
                                        ${tech.specializzazione ? `(${tech.specializzazione})` : ''}
                                    </option>
                                `).join('')}
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="note">Note per il tecnico (opzionale):</label>
                            <textarea id="note" name="note" class="form-textarea" 
                                    rows="3" maxlength="500"></textarea>
                        </div>

                        <div class="modal-actions">
                            <button type="button" class="btn btn-secondary" 
                                    onclick="maintenanceManager.closeModals()">
                                Annulla
                            </button>
                            <button type="submit" class="btn btn-primary">
                                Assegna
                            </button>
                        </div>
                    </form>
                </div>
            `;

            this.elements.assignModal.innerHTML = modalContent;
            this.elements.assignModal.classList.remove('hidden');

            // Form handler
            document.getElementById('assignForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                const formData = new FormData(e.target);
                await this.assignTechnician(
                    requestId, 
                    parseInt(formData.get('technicianId')),
                    formData.get('note')
                );
            });

        } catch (error) {
            Utils.showToast(error.message, 'error');
        }
    }

    /**
     * Apre il modale di completamento manutenzione
     */
    openCompleteModal(requestId) {
        try {
            const request = this.state.activeRequests.get(requestId);
            if (!request) {
                throw new Error('Richiesta non trovata');
            }

            const modalContent = `
                <div class="modal-header">
                    <h3>Completa Manutenzione</h3>
                    <button class="btn-close" onclick="maintenanceManager.closeModals()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                
                <div class="modal-body">
                    <div class="request-info">
                        <p><strong>Richiesta #${request.id}</strong></p>
                        <p>Macchina #${request.macchinaId}</p>
                        <p>Tecnico: ${
                            this.state.technicians.get(request.tecnicoId)?.nome || 'N/D'
                        }</p>
                    </div>

                    <form id="completeForm" class="complete-form">
                        <div class="form-group">
                            <label for="esito">Esito Intervento:</label>
                            <select id="esito" name="esito" class="form-select" required>
                                <option value="risolto">Problema Risolto</option>
                                <option value="parziale">Risolto Parzialmente</option>
                                <option value="non_risolto">Non Risolvibile</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="note">Note Intervento:</label>
                            <textarea id="note" name="note" class="form-textarea" 
                                    rows="3" required maxlength="1000"></textarea>
                        </div>

                        <div class="form-group">
                            <label for="partiSostituite">Parti Sostituite:</label>
                            <input type="text" id="partiSostituite" name="partiSostituite" 
                                   class="form-input" placeholder="Separare con virgola">
                            <small class="form-help">
                                Inserire le parti sostituite separate da virgola
                            </small>
                        </div>

                        <div class="form-group">
                            <label>
                                <input type="checkbox" name="richiediVerifica" value="1">
                                Richiedi verifica supervisore
                            </label>
                        </div>

                        <div class="modal-actions">
                            <button type="button" class="btn btn-secondary" 
                                    onclick="maintenanceManager.closeModals()">
                                Annulla
                            </button>
                            <button type="submit" class="btn btn-primary">
                                Completa
                            </button>
                        </div>
                    </form>
                </div>
            `;

            this.elements.completeModal.innerHTML = modalContent;
            this.elements.completeModal.classList.remove('hidden');

            // Form handler
            document.getElementById('completeForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                await this.completeMaintenance(requestId, new FormData(e.target));
            });

        } catch (error) {
            Utils.showToast(error.message, 'error');
        }
    }

    /**
     * Chiude tutti i modali
     */
    closeModals() {
        document.querySelectorAll('.modal').forEach(modal => {
            modal.classList.add('hidden');
            modal.innerHTML = ''; // Pulizia contenuto
        });
    }

    /**
     * Renderizza la paginazione
     */
    renderPagination(totalItems) {
        const totalPages = Math.ceil(totalItems / this.state.itemsPerPage);
        
        if (totalPages <= 1) {
            this.elements.pagination.innerHTML = '';
            return;
        }

        let paginationHTML = `
            <div class="pagination">
                <button class="btn btn-icon" 
                        onclick="maintenanceManager.changePage(1)"
                        ${this.state.currentPage === 1 ? 'disabled' : ''}
                        title="Prima pagina">
                    <i class="fas fa-angle-double-left"></i>
                </button>

                <button class="btn btn-icon" 
                        onclick="maintenanceManager.changePage(${this.state.currentPage - 1})"
                        ${this.state.currentPage === 1 ? 'disabled' : ''}
                        title="Pagina precedente">
                    <i class="fas fa-angle-left"></i>
                </button>

                <div class="page-numbers">
        `;

        // Logica per mostrare i numeri di pagina
        for (let i = 1; i <= totalPages; i++) {
            // Mostra sempre prima e ultima pagina
            // Mostra 2 pagine prima e dopo quella corrente
            if (
                i === 1 || i === totalPages ||
                (i >= this.state.currentPage - 2 && i <= this.state.currentPage + 2)
            ) {
                paginationHTML += `
                    <button class="btn btn-page ${i === this.state.currentPage ? 'active' : ''}"
                            onclick="maintenanceManager.changePage(${i})">
                        ${i}
                    </button>
                `;
            } else if (i === this.state.currentPage - 3 || i === this.state.currentPage + 3) {
                paginationHTML += '<span class="pagination-dots">...</span>';
            }
        }

        paginationHTML += `
                </div>

                <button class="btn btn-icon" 
                        onclick="maintenanceManager.changePage(${this.state.currentPage + 1})"
                        ${this.state.currentPage === totalPages ? 'disabled' : ''}
                        title="Pagina successiva">
                    <i class="fas fa-angle-right"></i>
                </button>

                <button class="btn btn-icon" 
                        onclick="maintenanceManager.changePage(${totalPages})"
                        ${this.state.currentPage === totalPages ? 'disabled' : ''}
                        title="Ultima pagina">
                    <i class="fas fa-angle-double-right"></i>
                </button>
            </div>

            <div class="pagination-info">
                Pagina ${this.state.currentPage} di ${totalPages}
            </div>
        `;

        this.elements.pagination.innerHTML = paginationHTML;
    }

    /**
     * Cambia pagina
     */
    changePage(page) {
        this.state.currentPage = page;
        this.renderMaintenance();
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    /**
     * Pulisce le risorse
     */
    destroy() {
        // Rimuovi sottoscrizioni MQTT
        const topics = [
            'manutenzione/richieste/nuova',
            'manutenzione/stato/+',
            'manutenzione/completata/+'
        ];
        
        topics.forEach(topic => mqttClient.unsubscribe(topic));
        
        // Rimuovi handler globali
        delete window.maintenanceManager;
        delete window.assignTechnician;
        delete window.completeMaintenance;
    }
}

// Inizializzazione
let maintenanceManager = null;

document.addEventListener('DOMContentLoaded', () => {
    maintenanceManager = new MaintenanceManager();
});

export default MaintenanceManager;

================
File: src/main/resources/public/js/admin/pods.js
================
/**
 * Gestione Cialde e Prodotti
 * Gestisce l'inventario e la configurazione delle cialde e dei prodotti.
 */
import mqttClient from '../common/mqtt.js';
import Utils from '../common/utils.js';
import auth from '../common/authentication.js';

class PodManager {
    constructor() {
        // Verifica autenticazione
        auth.protectAdminRoute();

        this.initializeElements();
        this.initializeState();
        this.initialize();
    }

    /**
     * Inizializza gli elementi DOM
     */
    initializeElements() {
        this.elements = {
            // Cialde
            podsList: document.getElementById('podsList'),
            addPodForm: document.getElementById('addPodForm'),
            editPodModal: document.getElementById('editPodModal'),
            searchInput: document.getElementById('searchPod'),
            filterType: document.getElementById('filterType'),
            sortSelect: document.getElementById('sortSelect'),
            stockWarningLevel: document.getElementById('stockWarningLevel'),
            
            // Prodotti
            productsGrid: document.getElementById('productsGrid'),
            addProductForm: document.getElementById('addProductForm'),
            editProductModal: document.getElementById('editProductModal'),
            
            // Modali
            confirmModal: document.getElementById('confirmModal'),
            restockModal: document.getElementById('restockModal')
        };

        // Verifica elementi richiesti
        Object.entries(this.elements).forEach(([key, element]) => {
            if (!element) {
                throw new Error(`Elemento DOM non trovato: ${key}`);
            }
        });
    }

    /**
     * Inizializza lo stato dell'applicazione
     */
    initializeState() {
        this.state = {
            pods: new Map(),
            products: new Map(),
            filters: {
                type: 'all',
                search: '',
                sort: 'name-asc'
            },
            stockThreshold: 20,
            loading: false,
            initialized: false
        };
    }

    /**
     * Inizializza il componente
     */
    async initialize() {
        try {
            Utils.toggleLoading(true);
            this.state.loading = true;
            
            // Carica dati iniziali
            await Promise.all([
                this.loadPods()
            ]);

            // Setup MQTT e event listeners
            await this.initializeMQTTSubscriptions();
            this.setupEventListeners();

            // Renderizza UI
            this.renderUI();

            this.state.initialized = true;
            console.log('Gestore cialde inizializzato');

        } catch (error) {
            console.error('Errore inizializzazione:', error);
            Utils.showToast('Errore durante l\'inizializzazione', 'error');
        } finally {
            this.state.loading = false;
            Utils.toggleLoading(false);
        }
    }

    /**
     * Carica l'elenco delle cialde
     */
    async loadPods() {
        try {
            const response = await Utils.apiCall('/api/cialde');
            
            this.state.pods.clear();
            response.forEach(pod => {
                this.state.pods.set(pod.id, this.normalizePodData(pod));
            });
        } catch (error) {
            console.error('Errore caricamento cialde:', error);
            throw error;
        }
    }

    /**
     * Normalizza i dati di una cialda
     */
    normalizePodData(pod) {
        return {
            id: pod.id,
            nome: pod.nome,
            tipo: pod.tipoCialda,
            quantitaAttuale: pod.quantitaAttuale || 0,
            quantitaMassima: pod.quantitaMassima || 100,
            prezzo: pod.prezzo || 0
        };
    }

    /**
     * Configura le sottoscrizioni MQTT
     */
    async initializeMQTTSubscriptions() {
        try {
            const topics = [
                // Aggiornamenti stock
                {
                    topic: 'cialde/+/stock',
                    handler: (topic, message) => {
                        const podId = parseInt(topic.split('/')[1]);
                        this.handleStockUpdate(podId, JSON.parse(message));
                    }
                },
                // Allarmi scorte
                {
                    topic: 'cialde/allarmi/scorte',
                    handler: (topic, message) => {
                        this.handleStockAlert(JSON.parse(message));
                    }
                }
            ];

            await Promise.all(
                topics.map(({ topic, handler }) => 
                    mqttClient.subscribe(topic, handler)
                )
            );
        } catch (error) {
            console.error('Errore sottoscrizione MQTT:', error);
            throw error;
        }
    }

    /**
     * Configura i listener degli eventi
     */
    setupEventListeners() {
        // Form cialde
        this.elements.addPodForm?.addEventListener('submit', (event) => {
            event.preventDefault();
            this.handleAddPod(new FormData(event.target));
        });

        // Form prodotti
        this.elements.addProductForm?.addEventListener('submit', (event) => {
            event.preventDefault();
            this.handleAddProduct(new FormData(event.target));
        });

        // Filtri e ordinamento
        this.elements.filterType?.addEventListener('change', () => {
            this.updateFilters('type');
        });

        this.elements.sortSelect?.addEventListener('change', () => {
            this.updateFilters('sort');
        });

        // Ricerca
        this.elements.searchInput?.addEventListener('input',
            Utils.debounce(() => this.updateFilters('search'), 300)
        );

        // Soglia scorte
        this.elements.stockWarningLevel?.addEventListener('change',
            Utils.debounce((event) => {
                const value = parseInt(event.target.value);
                if (!isNaN(value)) {
                    this.updateStockThreshold(value);
                }
            }, 500)
        );

        // Gestione modali
        document.querySelectorAll('.modal-close').forEach(button => {
            button.addEventListener('click', () => this.closeModals());
        });

        // Handler globali
        window.podManager = this;
        window.editPod = (id) => this.openEditPodModal(id);
        window.deletePod = (id) => this.handleDeletePod(id);
        window.restockPod = (id) => this.openRestockModal(id);
        window.editProduct = (id) => this.openEditProductModal(id);
        window.deleteProduct = (id) => this.handleDeleteProduct(id);
    }

    /**
     * Aggiorna i filtri e rigenera la lista
     */
    updateFilters(filterType) {
        const element = this.elements[`filter${filterType.charAt(0).toUpperCase() + filterType.slice(1)}`];
        if (!element) return;

        this.state.filters[filterType] = element.value;
        this.renderPods();
    }

    /**
     * Renderizza l'interfaccia utente
     */
    renderUI() {
        this.renderPods();
        this.renderProducts();
        this.updateStockIndicators();
    }

    /**
     * Renderizza l'elenco delle cialde
     */
    renderPods() {
        const filteredPods = Array.from(this.state.pods.values())
            .filter(this.filterPod.bind(this))
            .sort(this.sortPods.bind(this));

        this.elements.podsList.innerHTML = filteredPods
            .map(pod => this.renderPodCard(pod))
            .join('');
    }

    /**
     * Renderizza una card cialda
     */
    renderPodCard(pod) {
        const stockStatus = this.getStockStatus(pod);
        const stockPercentage = (pod.quantitaAttuale / pod.quantitaMassima * 100).toFixed(1);
        
        return `
            <div class="pod-card ${stockStatus.class}" data-id="${pod.id}">
                <div class="card-header">
                    <div class="header-content">
                        <h3>${Utils.escapeHtml(pod.nome)}</h3>
                        <span class="pod-type">${Utils.escapeHtml(pod.tipo)}</span>
                    </div>
                    <div class="stock-badge">
                        <i class="fas ${stockStatus.icon}"></i>
                        ${stockStatus.text}
                    </div>
                </div>

                <div class="card-body">
                    <div class="stock-container">
                        <div class="stock-bar-container">
                            <div class="stock-bar" 
                                style="width: ${stockPercentage}%"
                                title="Livello scorte: ${stockPercentage}%">
                            </div>
                        </div>
                        <div class="stock-info">
                            <span class="current">${pod.quantitaAttuale}</span>
                            <span class="separator">/</span>
                            <span class="max">${pod.quantitaMassima}</span>
                        </div>
                    </div>

                    <div class="pod-details">
                        <div class="detail-item">
                            <i class="fas fa-euro-sign"></i>
                            <span>${Utils.formatCurrency(pod.prezzo)}</span>
                        </div>
                        <div class="detail-item">
                            <i class="fas fa-exclamation-triangle"></i>
                            <span>Attuale: ${pod.quantitaAttuale}</span>
                        </div>
                        <div class="detail-item">
                            <i class="fas fa-clock"></i>
                            <span>Ultimo agg.: ${Utils.formatDate(pod.ultimoAggiornamento)}</span>
                        </div>
                    </div>
                </div>

                <div class="card-actions">
                    <button class="btn btn-edit" 
                            onclick="podManager.openEditPodModal(${pod.id})"
                            title="Modifica cialda">
                        <i class="fas fa-edit"></i>
                    </button>

                    <button class="btn btn-restock"
                            onclick="podManager.openRestockModal(${pod.id})"
                            title="Rifornisci scorte"
                            ${pod.quantitaAttuale >= pod.quantitaMassima ? 'disabled' : ''}>
                        <i class="fas fa-box"></i>
                    </button>

                    <button class="btn btn-danger"
                            onclick="podManager.handleDeletePod(${pod.id})"
                            title="Elimina cialda"
                            ${this.isPodInUse(pod.id) ? 'disabled' : ''}>
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </div>
        `;
    }

    /**
     * Ottiene lo stato dello stock di una cialda
     */
    getStockStatus(pod) {
        const percentage = (pod.quantitaAttuale / pod.quantitaMassima) * 100;

        if (percentage <= 0.05) {
            return {
                class: 'stock-critical',
                icon: 'fa-exclamation-circle',
                text: 'Quasi esaurita'
            };
        }
        
        if (percentage <= this.state.stockThreshold) {
            return {
                class: 'stock-warning',
                icon: 'fa-exclamation-triangle',
                text: 'In esaurimento'
            };
        }

        return {
            class: 'stock-normal',
            icon: 'fa-check-circle',
            text: 'Disponibile'
        };
    }

    /**
     * Renderizza i prodotti
     */
    renderProducts() {
        const products = Array.from(this.state.products.values())
            .filter(product => product.attivo)
            .sort((a, b) => a.nome.localeCompare(b.nome));

        this.elements.productsGrid.innerHTML = products
            .map(product => this.renderProductCard(product))
            .join('');
    }

    /**
     * Renderizza una card prodotto
     */
    renderProductCard(product) {
        const podsInfo = product.cialde.map(pod => {
            const podData = this.state.pods.get(pod.id);
            return podData ? {
                nome: podData.nome,
                quantitaAttuale: pod.quantitaAttuale,
                disponibile: podData.quantitaAttuale >= pod.quantitaAttuale
            } : null;
        }).filter(Boolean);

        const isAvailable = podsInfo.every(pod => pod.disponibile);

        return `
            <div class="product-card ${isAvailable ? '' : 'unavailable'}" data-id="${product.id}">
                <div class="card-header">
                    <div class="header-content">
                        <h3>${Utils.escapeHtml(product.nome)}</h3>
                        <span class="price">${Utils.formatCurrency(product.prezzo)}</span>
                    </div>
                    <div class="availability-badge ${isAvailable ? 'available' : 'unavailable'}">
                        ${isAvailable ? 'Disponibile' : 'Non Disponibile'}
                    </div>
                </div>

                <div class="card-body">
                    <p class="description">
                        ${Utils.escapeHtml(product.descrizione)}
                    </p>
                    
                    <div class="pods-list">
                        <h4>Composizione:</h4>
                        <ul>
                            ${podsInfo.map(pod => `
                                <li class="${pod.disponibile ? 'available' : 'unavailable'}">
                                    <span class="pod-name">${Utils.escapeHtml(pod.nome)}</span>
                                    <span class="pod-quantity">x${pod.quantitaAttuale}</span>
                                </li>
                            `).join('')}
                        </ul>
                    </div>
                </div>

                <div class="card-actions">
                    <button class="btn btn-edit" 
                            onclick="podManager.openEditProductModal(${product.id})"
                            title="Modifica prodotto">
                        <i class="fas fa-edit"></i>
                    </button>

                    <button class="btn btn-danger"
                            onclick="podManager.handleDeleteProduct(${product.id})"
                            title="Elimina prodotto">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </div>
        `;
    }

    /**
     * Gestisce l'aggiunta di una nuova cialda
     */
    async handleAddPod(formData) {
        try {
            Utils.toggleLoading(true);

            const podData = {
                nome: formData.get('nome'),
                tipo: formData.get('tipoCialda'),
                quantitaAttuale: parseInt(formData.get('quantitaAttuale')),
                quantitaMassima: parseInt(formData.get('quantitaMassima')),
                prezzo: parseFloat(formData.get('prezzo'))
            };

            // Validazione
            this.validatePodData(podData);

            const response = await Utils.apiCall('/api/cialde', {
                method: 'POST',
                body: JSON.stringify(podData)
            });

            this.state.pods.set(response.id, this.normalizePodData(response));
            this.renderUI();

            Utils.showToast('Cialda aggiunta con successo', 'success');
            this.elements.addPodForm.reset();

        } catch (error) {
            console.error('Errore aggiunta cialda:', error);
            Utils.showToast(error.message || 'Errore durante l\'aggiunta', 'error');
        } finally {
            Utils.toggleLoading(false);
        }
    }

    /**
     * Gestisce l'aggiunta di un nuovo prodotto
     */
    async handleAddProduct(formData) {
        try {
            Utils.toggleLoading(true);

            const productData = {
                nome: formData.get('nome'),
                descrizione: formData.get('descrizione'),
                prezzo: parseFloat(formData.get('prezzo')),
                cialde: Array.from(formData.getAll('podIds')).map(podId => ({
                    id: parseInt(podId),
                    quantitaAttuale: parseInt(formData.get(`quantity_${podId}`))
                }))
            };

            // Validazione
            this.validateProductData(productData);

            const response = await Utils.apiCall('/api/prodotti', {
                method: 'POST',
                body: JSON.stringify(productData)
            });

            this.state.products.set(response.id, this.normalizeProductData(response));
            this.renderUI();

            Utils.showToast('Prodotto aggiunto con successo', 'success');
            this.elements.addProductForm.reset();

        } catch (error) {
            console.error('Errore aggiunta prodotto:', error);
            Utils.showToast(error.message || 'Errore durante l\'aggiunta', 'error');
        } finally {
            Utils.toggleLoading(false);
        }
    }

    /**
     * Verifica se una cialda è utilizzata in qualche prodotto
     */
    isPodInUse(podId) {
        return Array.from(this.state.products.values())
            .some(product => 
                product.attivo && 
                product.cialde.some(pod => pod.id === podId)
            );
    }

    // /**
    //  * Aggiorna gli indicatori di stock
    //  */
    // updateStockIndicators() {
    //     let lowStock = 0;
    //     let criticalStock = 0;

    //     this.state.pods.forEach(pod => {
    //         if (pod.quantita <= pod.quantitaMinima) {
    //             criticalStock++;
    //         } else if ((pod.quantita / pod.quantitaMassima * 100) <= this.state.stockThreshold) {
    //             lowStock++;
    //         }
    //     });
    // }

    /**
     * Filtra le cialde in base ai criteri selezionati
     */
    filterPod(pod) {
        const { type, search } = this.state.filters;

        // Filtro per tipo
        if (type !== 'all' && pod.tipo !== type) {
            return false;
        }

        // Filtro per ricerca
        if (search) {
            const searchTerm = search.toLowerCase();
            return pod.nome.toLowerCase().includes(searchTerm) ||
                   pod.tipo.toLowerCase().includes(searchTerm);
        }

        return true;
    }

    /**
     * Ordina le cialde in base al criterio selezionato
     */
    sortPods(a, b) {
        const [field, direction] = this.state.filters.sort.split('-');
        const multiplier = direction === 'asc' ? 1 : -1;

        switch (field) {
            case 'nome':
                return multiplier * a.nome.localeCompare(b.nome);
            case 'quantitaAttuale':
                return multiplier * (a.quantitaAttuale - b.quantitaAttuale);
            case 'prezzo':
                return multiplier * (a.prezzo - b.prezzo);
            default:
                return 0;
        }
    }
/**
     * Gestisce il rifornimento di una cialda
     */
async handleRestock(podId, quantity) {
    try {
        Utils.toggleLoading(true);

        const pod = this.state.pods.get(podId);
        if (!pod) throw new Error('Cialda non trovata');

        const response = await Utils.apiCall(`/api/cialde/${podId}/rifornimento`, {
            method: 'POST',
            body: JSON.stringify({ quantitaAttuale: quantity })
        });

        pod.quantitaAttuale = response.quantitaAttuale;
        pod.ultimoAggiornamento = new Date().toISOString();

        this.renderPodCard(pod);
        this.updateStockIndicators();
        this.closeModals();

        Utils.showToast('Rifornimento completato con successo', 'success');
    } catch (error) {
        console.error('Errore rifornimento:', error);
        Utils.showToast(error.message || 'Errore durante il rifornimento', 'error');
    } finally {
        Utils.toggleLoading(false);
    }
}

/**
 * Apre il modale di modifica cialda
 */
openEditPodModal(podId) {
    try {
        const pod = this.state.pods.get(podId);
        if (!pod) throw new Error('Cialda non trovata');

        const modalContent = `
            <div class="modal-header">
                <h3>Modifica Cialda</h3>
                <button class="btn-close" onclick="podManager.closeModals()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <form id="editPodForm" class="form">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="nome">Nome</label>
                            <input type="text" id="nome" name="nome" 
                                   value="${Utils.escapeHtml(pod.nome)}"
                                   required minlength="3">
                        </div>
                        <div class="form-group">
                            <label for="tipo">Tipo</label>
                            <select id="tipo" name="tipo" required>
                                <option value="caffe" ${pod.tipo === 'caffe' ? 'selected' : ''}>Caffè</option>
                                <option value="te" ${pod.tipo === 'te' ? 'selected' : ''}>Tè</option>
                                <option value="cioccolata" ${pod.tipo === 'cioccolata' ? 'selected' : ''}>Cioccolata</option>
                                <option value="latte" ${pod.tipo === 'latte' ? 'selected' : ''}>Latte</option>
                            </select>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="quantitaAttuale">Scorta attuale</label>
                            <input type="number" id="quantitaAttuale" name="quantitaAttuale"
                                   value="${pod.quantitaAttuale}"
                                   required min="1" max="${pod.quantitaMassima - 1}">
                        </div>
                        <div class="form-group">
                            <label for="quantitaMassima">Scorta massima</label>
                            <input type="number" id="quantitaMassima" name="quantitaMassima"
                                   value="${pod.quantitaMassima}"
                                   required min="1">
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="prezzo">Prezzo (€)</label>
                            <input type="number" id="prezzo" name="prezzo"
                                   value="${pod.prezzo}"
                                   required min="0.01" step="0.01">
                        </div>
                    </div>

                    <div class="form-actions">
                        <button type="button" class="btn btn-secondary" 
                                onclick="podManager.closeModals()">
                            Annulla
                        </button>
                        <button type="submit" class="btn btn-primary">
                            Salva Modifiche
                        </button>
                    </div>
                </form>
            </div>
        `;

        this.elements.editPodModal.innerHTML = modalContent;
        this.elements.editPodModal.classList.remove('hidden');

        // Form handler
        document.getElementById('editPodForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            await this.handleEditPod(podId, new FormData(e.target));
        });

    } catch (error) {
        Utils.showToast(error.message, 'error');
    }
}

/**
 * Apre il modale di modifica prodotto
 */
openEditProductModal(productId) {
    try {
        const product = this.state.products.get(productId);
        if (!product) throw new Error('Prodotto non trovato');

        const modalContent = `
            <div class="modal-header">
                <h3>Modifica Prodotto</h3>
                <button class="btn-close" onclick="podManager.closeModals()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <form id="editProductForm" class="form">
                    <div class="form-group">
                        <label for="nome">Nome</label>
                        <input type="text" id="nome" name="nome" 
                               value="${Utils.escapeHtml(product.nome)}"
                               required minlength="3">
                    </div>

                    <div class="form-group">
                        <label for="descrizione">Descrizione</label>
                        <textarea id="descrizione" name="descrizione" 
                                required rows="3">${Utils.escapeHtml(product.descrizione)}</textarea>
                    </div>

                    <div class="form-group">
                        <label for="prezzo">Prezzo (€)</label>
                        <input type="number" id="prezzo" name="prezzo"
                               value="${product.prezzo}"
                               required min="0.01" step="0.01">
                    </div>

                    <div class="form-group">
                        <label>Composizione</label>
                        <div class="pods-grid">
                            ${Array.from(this.state.pods.values()).map(pod => `
                                <div class="pod-item">
                                    <div class="pod-check">
                                        <input type="checkbox" 
                                               id="pod_${pod.id}" 
                                               name="podIds" 
                                               value="${pod.id}"
                                               ${product.cialde.some(p => p.id === pod.id) ? 'checked' : ''}>
                                        <label for="pod_${pod.id}">
                                            ${Utils.escapeHtml(pod.nome)}
                                        </label>
                                    </div>
                                    <div class="pod-quantity">
                                        <input type="number" 
                                               name="quantity_${pod.id}" 
                                               value="${product.cialde.find(p => p.id === pod.id)?.quantitaAttuale || 1}"
                                               min="1" 
                                               max="${pod.quantitaMassima}"
                                               ${product.cialde.some(p => p.id === pod.id) ? '' : 'disabled'}>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <div class="form-actions">
                        <button type="button" class="btn btn-secondary" 
                                onclick="podManager.closeModals()">
                            Annulla
                        </button>
                        <button type="submit" class="btn btn-primary">
                            Salva Modifiche
                        </button>
                    </div>
                </form>
            </div>
        `;

        this.elements.editProductModal.innerHTML = modalContent;
        this.elements.editProductModal.classList.remove('hidden');

        // Handle pod checkboxes
        document.querySelectorAll('input[name="podIds"]').forEach(checkbox => {
            checkbox.addEventListener('change', (e) => {
                const quantityInput = document.querySelector(`input[name="quantity_${e.target.value}"]`);
                quantityInput.disabled = !e.target.checked;
                if (e.target.checked) {
                    quantityInput.focus();
                }
            });
        });

        // Form handler
        document.getElementById('editProductForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            await this.handleEditProduct(productId, new FormData(e.target));
        });

    } catch (error) {
        Utils.showToast(error.message, 'error');
    }
}

/**
     * Apre il modale di rifornimento
     */
    openRestockModal(podId) {
        try {
            const pod = this.state.pods.get(podId);
            if (!pod) throw new Error('Cialda non trovata');

            const spazioDisponibile = pod.quantitaMassima - pod.quantitaAttuale;
            if (spazioDisponibile <= 0) {
                throw new Error('Scorta già al massimo');
            }

            const modalContent = `
                <div class="modal-header">
                    <h3>Rifornimento Cialda</h3>
                    <button class="btn-close" onclick="podManager.closeModals()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="pod-info">
                        <h4>${Utils.escapeHtml(pod.nome)}</h4>
                        <p>Scorta attuale: ${pod.quantitaAttuale} / ${pod.quantitaMassima}</p>
                        <p>Spazio disponibile: ${spazioDisponibile} unità</p>
                    </div>

                    <form id="restockForm" class="form">
                        <div class="form-group">
                            <label for="quantita">Quantità da aggiungere</label>
                            <input type="number" 
                                   id="quantita" 
                                   name="quantita"
                                   required
                                   min="1"
                                   max="${spazioDisponibile}"
                                   value="${Math.min(spazioDisponibile, 10)}">
                            <small class="form-help">
                                Massimo: ${spazioDisponibile} unità
                            </small>
                        </div>

                        <div class="form-actions">
                            <button type="button" class="btn btn-secondary" 
                                    onclick="podManager.closeModals()">
                                Annulla
                            </button>
                            <button type="submit" class="btn btn-primary">
                                Rifornisci
                            </button>
                        </div>
                    </form>
                </div>
            `;

            this.elements.restockModal.innerHTML = modalContent;
            this.elements.restockModal.classList.remove('hidden');

            // Form handler
            document.getElementById('restockForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                const quantity = parseInt(e.target.quantita.value);
                await this.handleRestock(podId, quantity);
            });

        } catch (error) {
            Utils.showToast(error.message, 'error');
        }
    }

    /**
     * Gestisce la conferma di eliminazione
     */
    async confirmDelete(type, id, message) {
        return new Promise((resolve) => {
            const modalContent = `
                <div class="modal-header">
                    <h3>Conferma Eliminazione</h3>
                    <button class="btn-close" onclick="podManager.closeModals()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="confirm-message">
                        <i class="fas fa-exclamation-triangle"></i>
                        <p>${message}</p>
                    </div>
                    <div class="modal-actions">
                        <button class="btn btn-secondary" 
                                onclick="podManager.closeModals()">
                            Annulla
                        </button>
                        <button class="btn btn-danger" id="confirmBtn">
                            Elimina
                        </button>
                    </div>
                </div>
            `;

            this.elements.confirmModal.innerHTML = modalContent;
            this.elements.confirmModal.classList.remove('hidden');

            // Handler conferma
            document.getElementById('confirmBtn').addEventListener('click', () => {
                resolve(true);
                this.closeModals();
            });
        });
    }

    /**
     * Valida i dati di una cialda
     */
    validatePodData(data) {
        const errors = [];

        // Nome
        if (!data.nome?.trim() || data.nome.trim().length < 3) {
            errors.push('Il nome deve essere di almeno 3 caratteri');
        }


        // Quantità
        if (!Number.isInteger(data.quantitaAttuale) || data.quantitaAttuale < 0) {
            errors.push('La quantità deve essere un numero intero positivo');
        }

        // Quantità massima
        if (!Number.isInteger(data.quantitaMassima)) {
            errors.push('La quantità massima deve essere un numero intero');
        }

        // Prezzo
        if (typeof data.prezzo !== 'number') {
            errors.push('Errore valore prezzo');
        }

        if (errors.length > 0) {
            throw new Error(errors.join('\n'));
        }
    }

    /**
     * Valida i dati di un prodotto
     */
    validateProductData(data) {
        const errors = [];

        // Nome
        if (!data.nome?.trim() || data.nome.trim().length < 3) {
            errors.push('Il nome deve essere di almeno 3 caratteri');
        }

        // Descrizione
        if (!data.descrizione?.trim()) {
            errors.push('La descrizione è obbligatoria');
        }

        // Prezzo
        if (typeof data.prezzo !== 'number' || data.prezzo <= 0) {
            errors.push('Il prezzo deve essere maggiore di zero');
        }

        // Cialde
        if (!Array.isArray(data.cialde) || data.cialde.length === 0) {
            errors.push('Devi specificare almeno una cialda');
        } else {
            data.cialde.forEach((cialda, index) => {
                if (!this.state.pods.has(cialda.id)) {
                    errors.push(`Cialda ${cialda.id} non valida`);
                }
                if (!Number.isInteger(cialda.quantitaAttuale) || cialda.quantitaAttuale < 1) {
                    errors.push(`Quantità non valida per la cialda ${index + 1}`);
                }
            });
        }

        if (errors.length > 0) {
            throw new Error(errors.join('\n'));
        }
    }

    /**
     * Gestisce gli aggiornamenti MQTT di stock
     */
    handleStockUpdate(podId, data) {
        const pod = this.state.pods.get(parseInt(podId));
        if (!pod) return;

        pod.quantitaAttuale = data.quantitaAttuale;
        pod.ultimoAggiornamento = new Date().toISOString();

        this.renderPodCard(pod);
        this.updateStockIndicators();

        // Verifica scorta minima
        if (pod.quantitaAttuale <= 1) {
            Utils.showToast(`
                Attenzione: ${pod.nome} esaurita!
            `, 'warning');
        }
    }

    /**
     * Gestisce gli allarmi scorte
     */
    handleStockAlert(alert) {
        const pod = this.state.pods.get(alert.cialdaId);
        if (!pod) return;

        Utils.showToast(`
            ${alert.livello === 'critico' ? '⚠️' : '⚠'} 
            ${alert.messaggio} - ${pod.nome}
        `, alert.livello === 'critico' ? 'error' : 'warning');

        // Aggiorna UI se necessario
        this.updateStockIndicators();
    }

    /**
     * Chiude tutti i modali
     */
    closeModals() {
        document.querySelectorAll('.modal').forEach(modal => {
            modal.classList.add('hidden');
            // Pulizia contenuto per evitare memory leaks
            setTimeout(() => {
                if (modal.classList.contains('hidden')) {
                    modal.innerHTML = '';
                }
            }, 300);
        });
    }

    /**
     * Pulisce le risorse
     */
    destroy() {
        // Rimuovi sottoscrizioni MQTT
        mqttClient.unsubscribe('cialde/+/stock');
        mqttClient.unsubscribe('cialde/allarmi/scorte');

        // Rimuovi handler globali
        delete window.podManager;
        delete window.editPod;
        delete window.deletePod;
        delete window.restockPod;
        delete window.editProduct;
        delete window.deleteProduct;

        // Pulisci lo stato
        this.state.pods.clear();
        this.state.products.clear();
    }
}

// Inizializzazione
let podManager = null;

document.addEventListener('DOMContentLoaded', () => {
    podManager = new PodManager();

    // Cleanup alla chiusura
    window.addEventListener('unload', () => {
        if (podManager) {
            podManager.destroy();
        }
    });
});

export default PodManager;

================
File: src/main/resources/public/js/admin/reports.js
================
/**
 * Gestione Report e Statistiche
 * Gestisce la generazione e visualizzazione di report e statistiche del sistema
 */
import Utils from '../common/utils.js';
import auth from '../common/authentication.js';

class ReportManager {
    constructor() {
        // Verifica autenticazione
        auth.protectEmployeeRoute();

        this.initializeElements();
        this.initializeState();
        this.initialize();
    }

    /**
     * Inizializza gli elementi DOM
     */
    initializeElements() {
        this.elements = {
            revenueChart: document.getElementById('revenueChart'),
            productChart: document.getElementById('productChart'),
            maintenanceChart: document.getElementById('maintenanceChart'),
            statsGrid: document.getElementById('statsGrid'),
            dateRangeStart: document.getElementById('dateRangeStart'),
            dateRangeEnd: document.getElementById('dateRangeEnd'),
            instituteFilter: document.getElementById('instituteFilter'),
            exportButton: document.getElementById('exportButton'),
            printButton: document.getElementById('printButton'),
            reportFilters: document.getElementById('reportFilters')
        };

        // Verifica presenza elementi richiesti
        Object.entries(this.elements).forEach(([key, element]) => {
            if (!element) {
                throw new Error(`Elemento DOM non trovato: ${key}`);
            }
        });
    }

    /**
     * Inizializza lo stato dell'applicazione
     */
    initializeState() {
        const currentDate = new Date();
        const firstDayOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);

        this.state = {
            dateRange: {
                start: firstDayOfMonth,
                end: currentDate
            },
            selectedInstitute: 'all',
            reports: {
                revenue: null,
                products: null,
                maintenance: null,
                stats: null
            },
            charts: new Map()
        };
    }

    /**
     * Inizializza il componente
     */
    async initialize() {
        try {
            Utils.toggleLoading(true);

            // Inizializzazioni parallele
            await Promise.all([
                this.initializeFilters(),
                this.loadReportData()
            ]);

            this.initializeCharts();
            this.setupEventListeners();
            this.renderUI();

            console.log('Gestore report inizializzato');
        } catch (error) {
            console.error('Errore inizializzazione:', error);
            Utils.showToast('Errore durante l\'inizializzazione dei report', 'error');
        } finally {
            Utils.toggleLoading(false);
        }
    }

    /**
     * Inizializza i filtri
     */
    async initializeFilters() {
        try {
            // Setup date picker
            flatpickr(this.elements.dateRangeStart, {
                defaultDate: this.state.dateRange.start,
                maxDate: 'today',
                locale: 'it',
                onChange: ([date]) => this.updateDateRange('start', date)
            });

            flatpickr(this.elements.dateRangeEnd, {
                defaultDate: this.state.dateRange.end,
                maxDate: 'today',
                locale: 'it',
                onChange: ([date]) => this.updateDateRange('end', date)
            });

            // Carica e popola select istituti
            const institutes = await Utils.apiCall('/api/istituti');

            this.elements.instituteFilter.innerHTML = `
                <option value="all">Tutti gli istituti</option>
                ${institutes.map(institute => `
                    <option value="${institute.id}">
                        ${Utils.escapeHtml(institute.nome)}
                    </option>
                `).join('')}
            `;

        } catch (error) {
            console.error('Errore inizializzazione filtri:', error);
            throw error;
        }
    }

    /**
     * Configura i listener degli eventi
     */
    setupEventListeners() {
        // Cambio istituto
        this.elements.instituteFilter.addEventListener('change', async (e) => {
            this.state.selectedInstitute = e.target.value;
            await this.refreshReports();
        });

        // Export
        this.elements.exportButton.addEventListener('click', () => {
            this.exportReports();
        });

        // Print
        this.elements.printButton.addEventListener('click', () => {
            this.printReports();
        });
    }

    /**
     * Aggiorna il range date
     */
    async updateDateRange(type, date) {
        if (!date) return;

        this.state.dateRange[type] = date;

        // Validazione range
        if (this.state.dateRange.start > this.state.dateRange.end) {
            if (type === 'start') {
                this.state.dateRange.end = new Date(date);
            } else {
                this.state.dateRange.start = new Date(date);
            }
        }

        await this.refreshReports();
    }

    /**
     * Carica i dati dei report
     */
    async loadReportData() {
        try {
            const [revenue, products, maintenance, stats] = await Promise.all([
                this.fetchRevenueData(),
                this.fetchProductData(),
                this.fetchMaintenanceData(),
                this.fetchStatisticsData()
            ]);

            this.state.reports = {
                revenue: this.normalizeRevenueData(revenue),
                products: this.normalizeProductData(products),
                maintenance: this.normalizeMaintenanceData(maintenance),
                stats: this.normalizeStatisticsData(stats)
            };

        } catch (error) {
            console.error('Errore caricamento dati report:', error);
            throw error;
        }
    }
    /**
     * Recupera i dati dei ricavi
     */
    async fetchRevenueData() {
        const params = new URLSearchParams({
            dataInizio: this.state.dateRange.start.toISOString(),
            dataFine: this.state.dateRange.end.toISOString(),
            istitutoId: this.state.selectedInstitute
        });

        return await Utils.apiCall(`/api/reports/ricavi?${params}`);
    }

    /**
     * Recupera i dati dei prodotti
     */
    async fetchProductData() {
        const params = new URLSearchParams({
            dataInizio: this.state.dateRange.start.toISOString(),
            dataFine: this.state.dateRange.end.toISOString(),
            istitutoId: this.state.selectedInstitute
        });

        return await Utils.apiCall(`/api/reports/prodotti?${params}`);
    }

    /**
     * Recupera i dati delle manutenzioni
     */
    async fetchMaintenanceData() {
        const params = new URLSearchParams({
            dataInizio: this.state.dateRange.start.toISOString(),
            dataFine: this.state.dateRange.end.toISOString(),
            istitutoId: this.state.selectedInstitute
        });

        return await Utils.apiCall(`/api/reports/manutenzioni?${params}`);
    }

    /**
     * Recupera i dati delle statistiche
     */
    async fetchStatisticsData() {
        const params = new URLSearchParams({
            dataInizio: this.state.dateRange.start.toISOString(),
            dataFine: this.state.dateRange.end.toISOString(),
            istitutoId: this.state.selectedInstitute
        });

        return await Utils.apiCall(`/api/reports/statistiche?${params}`);
    }

    /**
     * Normalizza i dati dei ricavi
     */
    normalizeRevenueData(data) {
        return {
            giornalieri: data.giornalieri.map(item => ({
                data: new Date(item.data),
                importo: parseFloat(item.importo),
                transazioni: parseInt(item.transazioni)
            })),
            totale: parseFloat(data.totale),
            mediaGiornaliera: parseFloat(data.mediaGiornaliera)
        };
    }

    /**
     * Normalizza i dati dei prodotti
     */
    normalizeProductData(data) {
        return {
            prodotti: data.prodotti.map(item => ({
                id: item.id,
                nome: item.nome,
                quantita: parseInt(item.quantita),
                ricavo: parseFloat(item.ricavo)
            })),
            totaleVendite: parseInt(data.totaleVendite),
            prodottoPiuVenduto: data.prodottoPiuVenduto,
            prodottoMenoVenduto: data.prodottoMenoVenduto
        };
    }

    /**
     * Normalizza i dati delle manutenzioni
     */
    normalizeMaintenanceData(data) {
        return {
            perTipo: {
                preventiva: parseInt(data.perTipo.preventiva),
                correttiva: parseInt(data.perTipo.correttiva),
                emergenza: parseInt(data.perTipo.emergenza)
            },
            perMacchina: Object.entries(data.perMacchina).reduce((acc, [id, info]) => {
                acc[id] = {
                    conteggio: parseInt(info.conteggio),
                    tempoMedio: parseFloat(info.tempoMedio)
                };
                return acc;
            }, {})
        };
    }

    /**
     * Normalizza i dati delle statistiche
     */
    normalizeStatisticsData(data) {
        return {
            ricaviTotali: parseFloat(data.ricaviTotali),
            totaleTransazioni: parseInt(data.totaleTransazioni),
            mediaTransazione: parseFloat(data.mediaTransazione),
            tassoManutenzione: parseFloat(data.tassoManutenzione),
            prodottoPiuVenduto: data.prodottoPiuVenduto,
            prodottoMenoVenduto: data.prodottoMenoVenduto,
            efficienza: parseFloat(data.efficienza)
        };
    }

    /**
     * Inizializza i grafici
     */
    initializeCharts() {
        // Distruggi grafici esistenti se presenti
        this.destroyCharts();

        // Configura e crea nuovi grafici
        this.initializeRevenueChart();
        this.initializeProductChart();
        this.initializeMaintenanceChart();
    }

    /**
     * Inizializza il grafico dei ricavi
     */
    initializeRevenueChart() {
        if (!this.elements.revenueChart) return;

        const ctx = this.elements.revenueChart.getContext('2d');
        const data = this.prepareRevenueChartData();

        this.state.charts.set('revenue', new Chart(ctx, {
            type: 'line',
            data: data,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Andamento Ricavi'
                    },
                    legend: {
                        position: 'bottom'
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: (context) => {
                                const value = context.raw;
                                return `Ricavi: ${Utils.formatCurrency(value)}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'day',
                            displayFormats: {
                                day: 'dd/MM'
                            }
                        },
                        title: {
                            display: true,
                            text: 'Data'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Ricavi (€)'
                        },
                        ticks: {
                            callback: value => Utils.formatCurrency(value)
                        }
                    }
                }
            }
        }));
    }

    /**
     * Inizializza il grafico dei prodotti
     */
    initializeProductChart() {
        if (!this.elements.productChart) return;

        const ctx = this.elements.productChart.getContext('2d');
        const data = this.prepareProductChartData();

        this.state.charts.set('products', new Chart(ctx, {
            type: 'bar',
            data: data,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Vendite per Prodotto'
                    },
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                const value = context.raw;
                                return `Vendite: ${value}`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Quantità Vendute'
                        },
                        ticks: {
                            stepSize: 1
                        }
                    }
                }
            }
        }));
    }
    /**
         * Inizializza il grafico delle manutenzioni
         */
    initializeMaintenanceChart() {
        if (!this.elements.maintenanceChart) return;

        const ctx = this.elements.maintenanceChart.getContext('2d');
        const data = this.prepareMaintenanceChartData();

        this.state.charts.set('maintenance', new Chart(ctx, {
            type: 'doughnut',
            data: data,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Manutenzioni per Tipo'
                    },
                    legend: {
                        position: 'bottom'
                    },
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                const value = context.raw;
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100).toFixed(1);
                                return `${context.label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        }));
    }

    /**
     * Prepara i dati per il grafico dei ricavi
     */
    prepareRevenueChartData() {
        const data = this.state.reports.revenue?.giornalieri || [];
        return {
            labels: data.map(d => d.data),
            datasets: [{
                label: 'Ricavi Giornalieri',
                data: data.map(d => d.importo),
                borderColor: '#2563eb',
                backgroundColor: 'rgba(37, 99, 235, 0.1)',
                borderWidth: 2,
                tension: 0.4,
                fill: true
            }]
        };
    }

    /**
     * Prepara i dati per il grafico dei prodotti
     */
    prepareProductChartData() {
        const data = this.state.reports.products?.prodotti || [];
        const sortedData = [...data].sort((a, b) => b.quantita - a.quantita);

        return {
            labels: sortedData.map(p => p.nome),
            datasets: [{
                data: sortedData.map(p => p.quantita),
                backgroundColor: '#10b981',
                borderColor: '#059669',
                borderWidth: 1,
                borderRadius: 4
            }]
        };
    }

    /**
     * Prepara i dati per il grafico delle manutenzioni
     */
    prepareMaintenanceChartData() {
        const data = this.state.reports.maintenance?.perTipo || {
            preventiva: 0,
            correttiva: 0,
            emergenza: 0
        };

        return {
            labels: ['Preventiva', 'Correttiva', 'Emergenza'],
            datasets: [{
                data: [
                    data.preventiva,
                    data.correttiva,
                    data.emergenza
                ],
                backgroundColor: [
                    '#10b981', // verde
                    '#f59e0b', // giallo
                    '#ef4444'  // rosso
                ],
                borderWidth: 1
            }]
        };
    }

    /**
     * Aggiorna tutti i report
     */
    async refreshReports() {
        try {
            Utils.toggleLoading(true);

            await this.loadReportData();
            this.updateCharts();
            this.updateStatistics();

        } catch (error) {
            console.error('Errore aggiornamento report:', error);
            Utils.showToast('Errore durante l\'aggiornamento dei report', 'error');
        } finally {
            Utils.toggleLoading(false);
        }
    }

    /**
     * Aggiorna i grafici con i nuovi dati
     */
    updateCharts() {
        this.state.charts.forEach((chart, type) => {
            switch (type) {
                case 'revenue':
                    chart.data = this.prepareRevenueChartData();
                    break;
                case 'products':
                    chart.data = this.prepareProductChartData();
                    break;
                case 'maintenance':
                    chart.data = this.prepareMaintenanceChartData();
                    break;
            }
            chart.update('none'); // aggiornamento senza animazione
        });
    }

    /**
     * Aggiorna il pannello statistiche
     */
    updateStatistics() {
        const stats = this.state.reports.stats || {
            ricaviTotali: 0,
            totaleTransazioni: 0,
            mediaTransazione: 0,
            tassoManutenzione: 0,
            efficienza: 0
        };

        this.elements.statsGrid.innerHTML = this.createStatisticsHTML(stats);
    }

    /**
     * Crea l'HTML per le statistiche
     */
    createStatisticsHTML(stats) {
        return `
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-icon revenue">
                    <i class="fas fa-euro-sign"></i>
                </div>
                <div class="stat-content">
                    <div class="stat-value">${Utils.formatCurrency(stats.ricaviTotali)}</div>
                    <div class="stat-label">Ricavi Totali</div>
                </div>
            </div>

            <div class="stat-card">
                <div class="stat-icon transactions">
                    <i class="fas fa-shopping-cart"></i>
                </div>
                <div class="stat-content">
                    <div class="stat-value">${stats.totaleTransazioni.toLocaleString()}</div>
                    <div class="stat-label">Transazioni</div>
                </div>
            </div>

            <div class="stat-card">
                <div class="stat-icon average">
                    <i class="fas fa-calculator"></i>
                </div>
                <div class="stat-content">
                    <div class="stat-value">${Utils.formatCurrency(stats.mediaTransazione)}</div>
                    <div class="stat-label">Media Transazione</div>
                </div>
            </div>

            <div class="stat-card">
                <div class="stat-icon maintenance">
                    <i class="fas fa-tools"></i>
                </div>
                <div class="stat-content">
                    <div class="stat-value">${stats.tassoManutenzione.toFixed(1)}%</div>
                    <div class="stat-label">Tasso Manutenzione</div>
                </div>
            </div>

            <div class="stat-card">
                <div class="stat-icon efficiency">
                    <i class="fas fa-chart-line"></i>
                </div>
                <div class="stat-content">
                    <div class="stat-value">${stats.efficienza.toFixed(1)}%</div>
                    <div class="stat-label">Efficienza</div>
                </div>
            </div>
        </div>
    `;
    }

    /**
     * Esporta i report in formato PDF
     */
    async exportReports() {
        try {
            Utils.toggleLoading(true, this.elements.exportButton);

            const response = await Utils.apiCall('/api/reports/export', {
                method: 'POST',
                body: JSON.stringify({
                    dateRange: this.state.dateRange,
                    istitutoId: this.state.selectedInstitute,
                    data: this.state.reports
                })
            });

            if (!response.url) throw new Error('URL download non valido');

            // Download del file
            const link = document.createElement('a');
            link.href = response.url;
            link.download = `report_${Utils.formatDateForFilename(new Date())}.pdf`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            Utils.showToast('Report esportato con successo', 'success');

        } catch (error) {
            console.error('Errore esportazione report:', error);
            Utils.showToast('Errore durante l\'esportazione del report', 'error');
        } finally {
            Utils.toggleLoading(false, this.elements.exportButton);
        }
    }
    /**
         * Stampa i report
         */
    printReports() {
        // Crea una nuova finestra per la stampa
        const printWindow = window.open('', '_blank');
        if (!printWindow) {
            Utils.showToast('Errore: Popup bloccati. Abilita i popup per stampare.', 'error');
            return;
        }

        const content = this.createPrintContent();

        printWindow.document.write(content);
        printWindow.document.close();

        // Attendi il caricamento dei contenuti
        printWindow.onload = () => {
            try {
                // Aggiorna i grafici nella finestra di stampa
                this.updatePrintCharts(printWindow);

                // Stampa dopo un breve ritardo per permettere il rendering dei grafici
                setTimeout(() => {
                    printWindow.print();
                    printWindow.onafterprint = () => printWindow.close();
                }, 500);

            } catch (error) {
                console.error('Errore durante la stampa:', error);
                printWindow.close();
                Utils.showToast('Errore durante la preparazione della stampa', 'error');
            }
        };
    }

    /**
     * Crea il contenuto HTML per la stampa
     */
    createPrintContent() {
        const dateRange = {
            start: this.state.dateRange.start.toLocaleDateString('it-IT'),
            end: this.state.dateRange.end.toLocaleDateString('it-IT')
        };

        const stats = this.state.reports.stats;
        const institute = this.elements.instituteFilter.options[
            this.elements.instituteFilter.selectedIndex
        ].text;

        return `
        <!DOCTYPE html>
        <html lang="it">
        <head>
            <meta charset="UTF-8">
            <title>Report Sistema Distributori</title>
            <style>
                ${this.getPrintStyles()}
            </style>
            <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        </head>
        <body>
            <div class="print-container">
                <div class="print-header">
                    <h1>Report Sistema Distributori</h1>
                    <div class="print-meta">
                        <p>Periodo: ${dateRange.start} - ${dateRange.end}</p>
                        <p>Istituto: ${Utils.escapeHtml(institute)}</p>
                        <p>Generato il: ${new Date().toLocaleString('it-IT')}</p>
                    </div>
                </div>

                <div class="print-section">
                    <h2>Riepilogo Statistiche</h2>
                    ${this.createPrintableStats(stats)}
                </div>

                <div class="print-section charts-grid">
                    <div class="chart-container">
                        <h3>Andamento Ricavi</h3>
                        <canvas id="printRevenueChart"></canvas>
                    </div>
                    
                    <div class="chart-container">
                        <h3>Vendite per Prodotto</h3>
                        <canvas id="printProductChart"></canvas>
                    </div>
                    
                    <div class="chart-container">
                        <h3>Manutenzioni per Tipo</h3>
                        <canvas id="printMaintenanceChart"></canvas>
                    </div>
                </div>

                <div class="print-section">
                    <h2>Dettaglio Manutenzioni</h2>
                    ${this.createPrintableMaintenanceDetails()}
                </div>
            </div>
        </body>
        </html>
    `;
    }

    /**
     * Crea statistiche stampabili
     */
    createPrintableStats(stats) {
        if (!stats) return '<p>Nessuna statistica disponibile</p>';

        return `
        <div class="stats-grid">
            <div class="stat-item">
                <div class="stat-label">Ricavi Totali</div>
                <div class="stat-value">${Utils.formatCurrency(stats.ricaviTotali)}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Transazioni</div>
                <div class="stat-value">${stats.totaleTransazioni.toLocaleString()}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Media Transazione</div>
                <div class="stat-value">${Utils.formatCurrency(stats.mediaTransazione)}</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Tasso Manutenzione</div>
                <div class="stat-value">${stats.tassoManutenzione.toFixed(1)}%</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Efficienza Sistema</div>
                <div class="stat-value">${stats.efficienza.toFixed(1)}%</div>
            </div>
        </div>
    `;
    }

    /**
     * Crea dettagli manutenzione stampabili
     */
    createPrintableMaintenanceDetails() {
        const maintenance = this.state.reports.maintenance;
        if (!maintenance) return '<p>Nessun dato sulle manutenzioni disponibile</p>';

        return `
        <div class="maintenance-details">
            <div class="maintenance-summary">
                <h3>Riepilogo per Tipo</h3>
                <table>
                    <tr>
                        <th>Tipo</th>
                        <th>Interventi</th>
                    </tr>
                    <tr>
                        <td>Preventiva</td>
                        <td>${maintenance.perTipo.preventiva}</td>
                    </tr>
                    <tr>
                        <td>Correttiva</td>
                        <td>${maintenance.perTipo.correttiva}</td>
                    </tr>
                    <tr>
                        <td>Emergenza</td>
                        <td>${maintenance.perTipo.emergenza}</td>
                    </tr>
                </table>
            </div>

            <div class="maintenance-machines">
                <h3>Dettaglio per Macchina</h3>
                <table>
                    <tr>
                        <th>Macchina</th>
                        <th>Interventi</th>
                        <th>Tempo Medio (ore)</th>
                    </tr>
                    ${Object.entries(maintenance.perMacchina)
                .map(([id, data]) => `
                            <tr>
                                <td>Macchina #${id}</td>
                                <td>${data.conteggio}</td>
                                <td>${data.tempoMedio.toFixed(1)}</td>
                            </tr>
                        `).join('')}
                </table>
            </div>
        </div>
    `;
    }

    /**
     * Stili CSS per la stampa
     */
    getPrintStyles() {
        return `
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 2cm;
        }

        .print-container {
            max-width: 100%;
            margin: 0 auto;
        }

        .print-header {
            text-align: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #eee;
        }

        .print-meta {
            color: #666;
            font-size: 0.9rem;
        }

        .print-section {
            margin-bottom: 2rem;
            page-break-inside: avoid;
        }

        h1, h2, h3 {
            color: #2563eb;
            margin-bottom: 1rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-item {
            padding: 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
        }

        .stat-label {
            font-weight: bold;
            color: #666;
            margin-bottom: 0.5rem;
        }

        .stat-value {
            font-size: 1.25rem;
            color: #2563eb;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
        }

        .chart-container {
            height: 300px;
            margin-bottom: 2rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        th, td {
            padding: 0.75rem;
            border: 1px solid #e5e7eb;
            text-align: left;
        }

        th {
            background-color: #f9fafb;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background-color: #f9fafb;
        }

        @media print {
            body {
                padding: 0;
            }

            .print-container {
                width: 100%;
            }

            .chart-container {
                page-break-inside: avoid;
            }
        }
    `;
    }

    /**
     * Aggiorna i grafici nella finestra di stampa
     */
    updatePrintCharts(printWindow) {
        // Revenue Chart
        const revenueCtx = printWindow.document.getElementById('printRevenueChart');
        new Chart(revenueCtx, {
            type: 'line',
            data: this.prepareRevenueChartData(),
            options: {
                ...this.state.charts.get('revenue').options,
                animation: false
            }
        });

        // Product Chart
        const productCtx = printWindow.document.getElementById('printProductChart');
        new Chart(productCtx, {
            type: 'bar',
            data: this.prepareProductChartData(),
            options: {
                ...this.state.charts.get('products').options,
                animation: false
            }
        });

        // Maintenance Chart
        const maintenanceCtx = printWindow.document.getElementById('printMaintenanceChart');
        new Chart(maintenanceCtx, {
            type: 'doughnut',
            data: this.prepareMaintenanceChartData(),
            options: {
                ...this.state.charts.get('maintenance').options,
                animation: false
            }
        });
    }

    /**
     * Distrugge i grafici esistenti
     */
    destroyCharts() {
        this.state.charts.forEach(chart => chart.destroy());
        this.state.charts.clear();
    }

    /**
     * Pulisce le risorse
     */
    destroy() {
        this.destroyCharts();

        // Rimuovi event listeners
        this.elements.exportButton?.removeEventListener('click', this.exportReports);
        this.elements.printButton?.removeEventListener('click', this.printReports);
        this.elements.instituteFilter?.removeEventListener('change', this.refreshReports);
    }
}

// Inizializzazione
let reportManager = null;

document.addEventListener('DOMContentLoaded', () => {
    reportManager = new ReportManager();

    // Cleanup quando si lascia la pagina
    window.addEventListener('unload', () => {
        reportManager?.destroy();
    });
});

export default ReportManager;

================
File: src/main/resources/public/js/client/beverageSelection.js
================
const API_BASE_URL = 'http://localhost:8080/api';
let currentMachineId = 1;
let currentCredit = 0;
let selectedBeverage = null;
let sugarLevel = 2;

const machineNumberElement = document.getElementById('machineNumber');
const statusIndicatorElement = document.getElementById('statusIndicator');
const beveragesListElement = document.getElementById('beveragesList');
const currentCreditElement = document.getElementById('currentCredit');
const dispenseButton = document.getElementById('dispenseButton');
const returnCreditButton = document.getElementById('returnCreditButton');
const dispensingOverlay = document.getElementById('dispensingOverlay');
const dispensingStatusElement = document.getElementById('dispensingStatus');

async function fetchMachineInfo(machineId) {
    try {
        const response = await axios.get(`${API_BASE_URL}/macchine/${machineId}`);
        const machine = response.data;
        machineNumberElement.textContent = `#${machine.id}`;
        updateMachineStatus(machine.statoId);
        fetchBeverages(machineId);
    } catch (error) {
        console.error('Errore nel recupero delle informazioni della macchina:', error);
        alert('Impossibile caricare le informazioni della macchina.');
    }
}

function updateMachineStatus(statusId) {
    const statusMap = {
        1: { text: 'Attiva', class: 'status-active' },
        2: { text: 'Manutenzione', class: 'status-maintenance' },
        3: { text: 'Fuori Servizio', class: 'status-error' },
        default: { text: 'Sconosciuto', class: 'status-unknown' }
    };

    const status = statusMap[statusId] || statusMap.default;
    statusIndicatorElement.className = `status-indicator ${status.class}`;
    statusIndicatorElement.querySelector('.status-text').textContent = status.text;
}

async function fetchBeverages(machineId) {
    try {
        const response = await axios.get(`${API_BASE_URL}/macchine/${machineId}/bevande`);
        const beverages = response.data;
        renderBeverages(beverages);
    } catch (error) {
        console.error('Errore nel recupero delle bevande:', error);
        alert('Impossibile caricare le bevande disponibili.');
    }
}

function renderBeverages(beverages) {
    beveragesListElement.innerHTML = beverages.map(beverage => `
        <div class="beverage-card ${beverage.disponibile ? '' : 'unavailable'}" 
             data-id="${beverage.id}" 
             data-price="${beverage.prezzo}" 
             onclick="selectBeverage(${beverage.id}, ${beverage.prezzo}, ${beverage.disponibile})">
            <h3 class="font-bold">${beverage.nome}</h3>
            <p class="text-gray-600">€${beverage.prezzo.toFixed(2)}</p>
            ${beverage.disponibile ? '' : '<p class="text-red-600">Esaurito</p>'}
        </div>
    `).join('');
}

function selectBeverage(beverageId, price, isAvailable) {
    if (!isAvailable) return;
    selectedBeverage = { id: beverageId, price };
    document.querySelectorAll('.beverage-card').forEach(card => {
        card.classList.remove('selected');
    });
    document.querySelector(`.beverage-card[data-id="${beverageId}"]`).classList.add('selected');
    dispenseButton.disabled = currentCredit < price;
}

document.querySelectorAll('.coin-btn').forEach(button => {
    button.addEventListener('click', () => {
        const value = parseFloat(button.getAttribute('data-value'));
        currentCredit += value;
        currentCreditElement.textContent = currentCredit.toFixed(2);
        if (selectedBeverage && currentCredit >= selectedBeverage.price) {
            dispenseButton.disabled = false;
        }
    });
});

dispenseButton.addEventListener('click', async () => {
    if (!selectedBeverage || currentCredit < selectedBeverage.price) return;
    dispensingOverlay.classList.remove('hidden');
    dispensingStatusElement.textContent = 'Preparazione bevanda...';
    const topic = `macchine/${currentMachineId}/bevande/richiesta`;
    const message = {
        bevandaId: selectedBeverage.id,
        importo: selectedBeverage.price,
        zucchero: sugarLevel,
        timestamp: Date.now()
    };
    try {
        await mqttClient.publish(topic, JSON.stringify(message));
        console.log('Richiesta di erogazione inviata:', message);
    } catch (error) {
        console.error('Errore durante l\'invio della richiesta di erogazione:', error);
        alert('Errore durante l\'invio della richiesta di erogazione.');
    }
});

mqttClient.subscribe(`macchine/${currentMachineId}/stato`, (topic, payload) => {
    const status = JSON.parse(payload);
    updateMachineStatus(status.statoId);
});

mqttClient.subscribe(`macchine/${currentMachineId}/bevande/erogazione`, (topic, payload) => {
    const result = JSON.parse(payload);
    if (result.success) {
        dispensingStatusElement.textContent = 'Bevanda erogata con successo!';
        currentCredit = 0;
        currentCreditElement.textContent = '0.00';
        selectedBeverage = null;
        setTimeout(() => dispensingOverlay.classList.add('hidden'), 2000);
    } else {
        dispensingStatusElement.textContent = 'Errore durante l\'erogazione.';
    }
});

returnCreditButton.addEventListener('click', async () => {
    const topic = `macchine/${currentMachineId}/cassa/restituzione`;
    try {
        await mqttClient.publish(topic, JSON.stringify({}));
        currentCredit = 0;
        currentCreditElement.textContent = '0.00';
        alert('Credito restituito con successo.');
    } catch (error) {
        console.error('Errore durante la restituzione del credito:', error);
        alert('Errore durante la restituzione del credito.');
    }
});

document.addEventListener('DOMContentLoaded', () => {
    fetchMachineInfo(currentMachineId);
    mqttClient.connect();
});

================
File: src/main/resources/public/js/client/machineSelection.js
================
import Utils from '../common/utils.js';

class MachineSelectionManager {
    constructor() {
        this.elements = {
            searchInput: document.getElementById('searchMachine'),
            filterButtons: document.querySelectorAll('.filter-btn'),
            machinesList: document.getElementById('machinesList'),
            statusIndicator: document.getElementById('statusIndicator'),
            institutesList: document.getElementById('institutesList')
        };

        this.state = {
            machines: new Map(),
            institutes: new Map(),
            currentFilter: 'all'
        };

        this.initialize();
    }

    async initialize() {
        try {
            Utils.toggleLoading(true);
            await this.ensureAuthToken();

            // Carica prima gli istituti, poi le macchine
            await this.loadInstitutes();
            await this.loadMachines();

            await this.initializeMQTTSubscriptions();
            

            // Renderizza le macchine e gli istituti
            this.renderMachines();
            this.renderInstitutes();
        } catch (error) {
            console.error('Initialization error:', error);
            Utils.showToast('Error during initialization. Please try again.', 'error');
        } finally {
            Utils.toggleLoading(false);
        }
    }

    async ensureAuthToken() {
        let token = localStorage.getItem('jwt_token');
        if (!token) {
            token = this.generateAnonymousToken();
            localStorage.setItem('jwt_token', token);
            localStorage.setItem('userRole', 'anonymous');
        }
        return token;
    }

    generateAnonymousToken() {
        const random = Math.random().toString(36).substring(2);
        const timestamp = Date.now().toString(36);
        return `anonymous_${random}_${timestamp}`;
    }

    async loadMachines() {
        try {
            const response = await fetch('/api/macchine', {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${await this.ensureAuthToken()}`
                }
            });
            
            if (!response.ok) {
                localStorage.removeItem('authToken');
                const newToken = await this.ensureAuthToken();
                
                const retryResponse = await fetch('/api/macchine', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${newToken}`
                    }
                });
                
                if (!retryResponse.ok) {
                    throw new Error(`HTTP error! status: ${retryResponse.status}`);
                }
                
                const machines = await retryResponse.json();
                machines.forEach(machine => {
                    this.state.machines.set(machine.id, machine);
                });
            } else {
                const machines = await response.json();
                machines.forEach(machine => {
                    this.state.machines.set(machine.id, machine);
                });
            }
            
        } catch (error) {
            console.error('Failed to load machines:', error);
            Utils.showToast('Error loading machines', 'error');
        }
    }

    async loadInstitutes() {
        try {
            const response = await fetch('/api/istituti', {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${await this.ensureAuthToken()}`
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const institutes = await response.json();
            institutes.forEach(institute => {
                this.state.institutes.set(institute.ID_istituto, institute);
            });

        } catch (error) {
            console.error('Failed to load institutes:', error);
            Utils.showToast('Error loading institutes', 'error');
        }
    }

    async initializeMQTTSubscriptions() {
        try {
            await mqttClient.subscribe('macchine/+/stato', (topic, message) => {
                const machineId = parseInt(topic.split('/')[1]);
                const status = JSON.parse(message);
                this.updateMachineStatus(machineId, status);
            });
        } catch (error) {
            console.error('Errore sottoscrizione MQTT:', error);
            throw error;
        }
    }

    updateMachineStatus(machineId, status) {
        const machine = this.state.machines.get(machineId);
        if (!machine) return;

        machine.statoDescrizione = status.statoDescrizione;
        this.updateMachineUI(machine);
    }

    updateMachineUI(machine) {
        const card = document.getElementById(`machine-${machine.id}`);
        if (!card) return;

        const status = this.getMachineStatus(machine.statoDescrizione);
        
        // Aggiorna il pallino dello stato
        card.querySelector('.status-badge')
            .className = `status-badge ${status.class}`;
        
        // Aggiorna il testo dello stato
        card.querySelector('.status-text').textContent = status.text;

        // Aggiorna il pulsante
        const button = card.querySelector('.btn-select');
        if (machine.statoDescrizione === 'Attiva') {
            button.removeAttribute('disabled');
            button.textContent = 'Seleziona';
        } else {
            button.setAttribute('disabled', 'disabled');
            button.textContent = 'Non disponibile';
        }
    }

    renderMachines(machines = Array.from(this.state.machines.values())) {
        if (!this.elements.machinesList) return;

        this.elements.machinesList.innerHTML = machines
            .map(machine => {
                const institute = this.getInstituteForMachine(machine);
                return this.renderMachineCard(machine, institute);
            })
            .join('');
    }

    renderMachineCard(machine, institute) {
        const status = this.getMachineStatus(machine.statoDescrizione);
        
        // Se l'istituto non è trovato, usa valori di default
        const instituteName = institute ? institute.nome : 'N/A';
        const instituteAddress = institute ? institute.indirizzo : 'N/A';

        return `
            <div id="machine-${machine.id}" class="machine-card">
                <div class="card-header">
                    <h3>Distributore #${machine.id}</h3>
                    <span class="status-badge ${status.class}"></span>
                </div>
                <div class="card-body">
                    <p class="institute"><i class="fas fa-building"></i> ${instituteName}</p>
                    <p class="status-text">${status.text}</p>
                    <p class="address"><i class="fa fa-map-marker" aria-hidden="true"></i> ${instituteAddress}</p>
                    ${machine.statoDescrizione === 'Attiva' ? `
                        <button class="btn-select" onclick="window.selectMachine(${machine.id})">
                            Seleziona
                        </button>
                    ` : `
                        <button disabled>
                            Non disponibile
                        </button>
                    `}
                </div>
            </div>
        `;
    }

    getInstituteForMachine(machine) {
        // Verifica che machine.istitutoId sia definito e sia una chiave valida nel Map degli istituti
        if (machine.istitutoId && this.state.institutes.has(machine.istitutoId)) {
            return this.state.institutes.get(machine.istitutoId);
        }
        return null; // Restituisci null se l'istituto non è trovato
    }

    renderInstitutes() {
        if (!this.elements.institutesList) {
            console.error('Elemento institutesList non trovato!');
            return;
        }

        this.elements.institutesList.innerHTML = Array.from(this.state.institutes.values())
            .map(institute => this.renderInstituteCard(institute))
            .join('');
    }

    renderInstituteCard(institute) {
        const machinesCount = Array.from(this.state.machines.values())
            .filter(machine => machine.istitutoId === institute.ID_istituto && machine.statoDescrizione === 'Attiva')
            .length;

        return `
            <div class="institute-card">
                <div class="card-header">
                    <h3>${institute.nome}</h3>
                </div>
                <div class="card-body">
                    <p class="address"><i class="fa fa-map-marker" aria-hidden="true"></i> ${institute.indirizzo}</p>
                    <p class="machines-count"><i class="fas fa-coffee"></i> Macchine disponibili: ${machinesCount}</p>
                </div>
            </div>
        `;
    }

    selectMachine(machineId) {
        const machine = this.state.machines.get(machineId);
        if (!machine || machine.statoDescrizione !== 'Attiva') return;

        sessionStorage.setItem('selectedMachine', machineId);
        window.location.href = `/pages/client/beverageInterface.html?machine=${machineId}`;
    }

    getMachineStatus(statoDescrizione) {
        const statusMap = {
            'Attiva': { 
                class: 'status-available',
                text: 'Disponibile'
            },
            'In manutenzione': {
                class: 'status-maintenance',
                text: 'In Manutenzione'
            },
            'Fuori servizio': {
                class: 'status-inactive',
                text: 'Fuori Servizio'
            }
        };

        return statusMap[statoDescrizione] || { 
            class: 'status-unknown',
            text: 'Stato Sconosciuto'
        };
    }

    destroy() {
        mqttClient.unsubscribe('macchine/+/stato');
        this.state.machines.clear();
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const manager = new MachineSelectionManager();

    window.addEventListener('unload', () => {
        manager.destroy();
    });

    window.selectMachine = (id) => manager.selectMachine(id);
});

export default MachineSelectionManager;

================
File: src/main/resources/public/js/client/payment.js
================
/**
 * Gestione Pagamenti
 * Gestisce l'interfaccia di pagamento e le transazioni
 */

import mqttClient from '../common/mqtt.js';
import Utils from '../common/utils.js';

class PaymentManager {
    constructor() {
        // Recupera ID macchina
        this.machineId = new URLSearchParams(window.location.search).get('machine');

        // Elementi DOM
        this.elements = {
            currentCredit: document.getElementById('currentCredit'),
            productPrice: document.getElementById('productPrice'),
            coinButtons: document.querySelectorAll('.coin-button'),
            dispenseButton: document.getElementById('dispenseButton'),
            returnCreditButton: document.getElementById('returnCreditButton')
        };

        // Stato
        this.state = {
            credit: 0,
            selectedProduct: null,
            customization: null,
            transactionInProgress: false
        };

        // Inizializzazione
        this.initialize();
    }

    /**
     * Inizializza il gestore pagamenti
     */
    async initialize() {
        try {
            // Sottoscrivi agli aggiornamenti MQTT
            await this.subscribeMQTTTopics();

            // Inizializza gli event listeners
            this.initializeEventListeners();

            console.log('Gestore pagamenti inizializzato');
        } catch (error) {
            console.error('Errore inizializzazione:', error);
            Utils.showToast('Errore durante l\'inizializzazione del pagamento', 'error');
        }
    }

    /**
     * Sottoscrivi ai topic MQTT
     */
    async subscribeMQTTTopics() {
        try {
            // Conferma inserimento monete
            await mqttClient.subscribe(`machines/${this.machineId}/payment/coin-accepted`, (topic, message) => {
                this.handleCoinAccepted(JSON.parse(message));
            });

            // Stato transazione
            await mqttClient.subscribe(`machines/${this.machineId}/payment/transaction-status`, (topic, message) => {
                this.handleTransactionStatus(JSON.parse(message));
            });

        } catch (error) {
            console.error('Errore sottoscrizione MQTT:', error);
            throw error;
        }
    }

    /**
     * Inizializza i listener degli eventi
     */
    initializeEventListeners() {
        // Pulsanti monete
        this.elements.coinButtons.forEach(button => {
            button.addEventListener('click', () => {
                if (this.state.transactionInProgress) return;
                const value = parseFloat(button.dataset.value);
                this.insertCoin(value);
            });
        });

        // Pulsante erogazione
        this.elements.dispenseButton.addEventListener('click', () => {
            if (this.canDispense()) {
                this.startTransaction();
            }
        });

        // Pulsante restituzione credito
        this.elements.returnCreditButton.addEventListener('click', () => {
            if (!this.state.transactionInProgress && this.state.credit > 0) {
                this.returnCredit();
            }
        });

        // Eventi selezione prodotto
        window.addEventListener('beverageSelected', (e) => {
            this.handleProductSelected(e.detail.beverage);
        });

        window.addEventListener('customizationChanged', (e) => {
            this.handleCustomizationChanged(e.detail);
        });

        window.addEventListener('selectionReset', () => {
            this.resetPayment();
        });
    }

    /**
     * Gestisce l'accettazione di una moneta
     */
    handleCoinAccepted(data) {
        if (data.accepted) {
            this.state.credit += data.value;
            this.updateCreditDisplay();
            Utils.showToast(`Moneta da €${data.value.toFixed(2)} accettata`, 'success');
        } else {
            Utils.showToast('Moneta non accettata', 'error');
        }
    }

    /**
     * Gestisce gli aggiornamenti di stato della transazione
     */
    handleTransactionStatus(status) {
        switch (status.state) {
            case 'completed':
                this.state.transactionInProgress = false;
                this.state.credit = 0;
                this.updateUI();
                break;

            case 'failed':
                this.state.transactionInProgress = false;
                Utils.showToast('Transazione fallita: ' + status.message, 'error');
                this.updateUI();
                break;

            case 'processing':
                // Aggiorna UI con stato processamento
                break;
        }
    }

    /**
     * Gestisce la selezione di un prodotto
     */
    handleProductSelected(product) {
        this.state.selectedProduct = product;
        this.updateUI();
    }

    /**
     * Gestisce il cambio delle personalizzazioni
     */
    handleCustomizationChanged(data) {
        this.state.selectedProduct = data.beverage;
        this.state.customization = data.customization;
        this.updateUI();
    }

    /**
     * Inserisce una moneta
     */
    async insertCoin(value) {
        try {
            await mqttClient.publish(
                `machines/${this.machineId}/payment/insert-coin`,
                JSON.stringify({ value })
            );
        } catch (error) {
            console.error('Errore inserimento moneta:', error);
            Utils.showToast('Errore durante l\'inserimento della moneta', 'error');
        }
    }

    /**
     * Avvia una transazione
     */
    async startTransaction() {
        try {
            this.state.transactionInProgress = true;
            this.updateUI();

            const transactionData = {
                productId: this.state.selectedProduct.id,
                customization: this.state.customization,
                amount: this.calculateTotal(),
                credit: this.state.credit
            };

            await mqttClient.publish(
                `machines/${this.machineId}/payment/start-transaction`,
                JSON.stringify(transactionData)
            );

            // Avvia l'erogazione
            window.startDispensing();

        } catch (error) {
            console.error('Errore avvio transazione:', error);
            Utils.showToast('Errore durante l\'avvio della transazione', 'error');
            this.state.transactionInProgress = false;
            this.updateUI();
        }
    }

    /**
     * Restituisce il credito residuo
     */
    async returnCredit() {
        try {
            await mqttClient.publish(
                `machines/${this.machineId}/payment/return-credit`,
                JSON.stringify({ amount: this.state.credit })
            );

            Utils.showToast(`Credito di €${this.state.credit.toFixed(2)} restituito`, 'success');
            this.state.credit = 0;
            this.updateUI();

        } catch (error) {
            console.error('Errore restituzione credito:', error);
            Utils.showToast('Errore durante la restituzione del credito', 'error');
        }
    }

    /**
     * Calcola il totale con extra
     */
    calculateTotal() {
        let total = this.state.selectedProduct.price;

        // Aggiungi prezzo extra
        if (this.state.customization && this.state.customization.extras) {
            this.state.customization.extras.forEach(extraId => {
                const extra = this.state.selectedProduct.extras.find(e => e.id === extraId);
                if (extra) {
                    total += extra.price;
                }
            });
        }

        return total;
    }

    /**
     * Verifica se è possibile erogare
     */
    canDispense() {
        return !this.state.transactionInProgress &&
               this.state.selectedProduct &&
               this.state.credit >= this.calculateTotal();
    }

    /**
     * Aggiorna la visualizzazione del credito
     */
    updateCreditDisplay() {
        this.elements.currentCredit.textContent = Utils.formatCurrency(this.state.credit);
    }

    /**
     * Aggiorna l'interfaccia utente
     */
    updateUI() {
        // Aggiorna display credito
        this.updateCreditDisplay();

        // Aggiorna prezzo prodotto
        if (this.state.selectedProduct) {
            const total = this.calculateTotal();
            this.elements.productPrice.textContent = total.toFixed(2);
        } else {
            this.elements.productPrice.textContent = '0.00';
        }

        // Aggiorna stato pulsanti
        this.elements.dispenseButton.disabled = !this.canDispense();
        this.elements.returnCreditButton.disabled = 
            this.state.transactionInProgress || this.state.credit <= 0;

        // Aggiorna stato monete
        this.elements.coinButtons.forEach(button => {
            button.disabled = this.state.transactionInProgress;
        });
    }

    /**
     * Resetta lo stato del pagamento
     */
    resetPayment() {
        if (this.state.credit > 0) {
            this.returnCredit();
        }

        this.state.selectedProduct = null;
        this.state.customization = null;
        this.updateUI();
    }

    /**
     * Pulisce e libera risorse
     */
    destroy() {
        // Cancella sottoscrizioni MQTT
        mqttClient.unsubscribe(`machines/${this.machineId}/payment/coin-accepted`);
        mqttClient.unsubscribe(`machines/${this.machineId}/payment/transaction-status`);
    }
}

// Inizializza il gestore quando il DOM è pronto
document.addEventListener('DOMContentLoaded', () => {
    const paymentManager = new PaymentManager();

    // Gestione pulizia quando si lascia la pagina
    window.addEventListener('unload', () => {
        paymentManager.destroy();
    });
});

export default PaymentManager;

================
File: src/main/resources/public/js/common/auth-utils.js
================
// auth-utils.js

export class AuthService {
    static isAuthenticated() {
        return !!localStorage.getItem('authToken');
    }

    static getToken() {
        return localStorage.getItem('authToken');
    }

    static getUserRole() {
        return localStorage.getItem('userRole');
    }

    static logout() {
        localStorage.removeItem('authToken');
        localStorage.removeItem('userRole');
        window.location.href = '/login.html';
    }

    static async refreshToken() {
        try {
            const response = await fetch('/api/auth/refresh', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${this.getToken()}`
                }
            });

            if (response.ok) {
                const { token } = await response.json();
                localStorage.setItem('authToken', token);
                return true;
            }
            return false;
        } catch (error) {
            return false;
        }
    }

    static async verifyAuth() {
        if (!this.isAuthenticated()) {
            window.location.href = '/login.html';
            return false;
        }

        try {
            const response = await fetch('/api/auth/verify', {
                headers: {
                    'Authorization': `Bearer ${this.getToken()}`
                }
            });

            if (!response.ok) {
                const refreshed = await this.refreshToken();
                if (!refreshed) {
                    this.logout();
                    return false;
                }
            }
            return true;
        } catch (error) {
            this.logout();
            return false;
        }
    }
}

================
File: src/main/resources/public/js/common/authentication.js
================
/**
 * Authentication module for the vending machine management system
 */
import Utils from './utils.js';

class AuthenticationService {
    constructor() {
        this.baseUrl = '/auth';
        this.tokenKey = 'jwt_token';
        this.roleKey = 'user_role';
        this.userNameKey = 'user_name';
    }

    /**
     * Performs login
     * @param {string} username 
     * @param {string} password 
     * @returns {Promise<boolean>}
     */
    async login(username, password) {
        try {
            const response = await Utils.apiCall(`${this.baseUrl}/login`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ username, password })
            });

            if (response && response.token) {
				console.log(response);
                localStorage.setItem(this.tokenKey, response.token);
                localStorage.setItem(this.roleKey, response.ruolo);
                localStorage.setItem(this.userNameKey, username);
                return true;
            }
            return false;
        } catch (error) {
            console.error('Login error:', error);
            throw new Error('Username o password non validi');
        }
    }

    /**
     * Performs logout
     */
    logout() {
        localStorage.removeItem(this.tokenKey);
        localStorage.removeItem(this.roleKey);
        localStorage.removeItem(this.userNameKey);
        window.location.href = '/index.html';
    }

    /**
     * Gets the stored username
     * @returns {string|null}
     */
    getUserName() {
        return localStorage.getItem(this.userNameKey);
    }

    /**
     * Verifies if user is authenticated
     * @returns {boolean}
     */
    isAuthenticated() {
        const token = this.getToken();
        if (!token) return false;
        
        try {
            // Verifica semplice della scadenza del token JWT
            const payload = JSON.parse(atob(token.split('.')[1]));
            const expirationTime = payload.exp * 1000; // Converti in millisecondi
            return Date.now() < expirationTime;
        } catch (e) {
            console.error('Token validation error:', e);
            return false;
        }
    }

    /**
     * Gets user role
     * @returns {string|null}
     */
    getUserRole() {
        const role = localStorage.getItem(this.roleKey);
        return role ? role.toLowerCase() : null;
    }

    /**
     * Verifies if user has admin role
     * @returns {boolean}
     */
    isAdmin() {
        const role = this.getUserRole();
        return role === 'amministratore' || role === 'admin';
    }

    /**
     * Verifies if user has employee role
     * @returns {boolean}
     */
    isEmployee() {
        const role = this.getUserRole();
        return role === 'operatore' || role === 'employee' || role === 'impiegato';
    }

    /**
     * Gets authentication token
     * @returns {string|null}
     */
    getToken() {
        return localStorage.getItem(this.tokenKey);
    }

    /**
     * Refreshes authentication token
     * @returns {Promise<boolean>}
     */
    async refreshToken() {
        try {
            const currentToken = this.getToken();
            if (!currentToken) {
                throw new Error('No token to refresh');
            }

            const response = await Utils.apiCall(`${this.baseUrl}/refresh`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${currentToken}`
                }
            });

            if (response && response.token) {
                localStorage.setItem(this.tokenKey, response.token);
                return true;
            }
            return false;
        } catch (error) {
            console.error('Token refresh error:', error);
            this.logout();
            throw error;
        }
    }

    /**
     * Protects a route requiring authentication
     * @param {Function} roleCheck Optional role verification function
     */
    static protectRoute(roleCheck = null) {
        const auth = new AuthenticationService();
        
        if (!auth.isAuthenticated()) {
            auth.logout(); // Pulisce lo storage e reindirizza
            return;
        }

        if (roleCheck && !roleCheck(auth)) {
            Utils.showToast('Accesso non autorizzato', 'error');
            window.location.href = '/index.html';
            return;
        }
    }

    /**
     * Protects an admin route
     */
    static protectAdminRoute() {
        AuthenticationService.protectRoute(auth => auth.isAdmin());
    }

    /**
     * Protects an employee route
     */
    static protectEmployeeRoute() {
        AuthenticationService.protectRoute(auth => auth.isAdmin() || auth.isEmployee());
    }
}

// Create a singleton instance
const auth = new AuthenticationService();

// Export both class and singleton
export { AuthenticationService, auth as default };

================
File: src/main/resources/public/js/common/mqtt.js
================
/**
 * Modulo per la gestione delle comunicazioni MQTT del sistema
 * Utilizza Paho MQTT Client per la comunicazione
 */

class MQTTManager {
    constructor(config = {}) {
        // Configurazione di default
        this.config = {
            host: config.host || 'localhost',
            port: config.port || 8883,
            path: config.path || '/mqtt',
            clientId: config.clientId || 'client_' + Math.random().toString(16).substr(2, 8),
            username: config.username || '20019309',
            password: config.password || 'Pissir2024!',
            useSSL: config.useSSL !== undefined ? config.useSSL : true,
            keepaliveInterval: config.keepaliveInterval || 30,
            connectTimeout: config.connectTimeout || 10,
            reconnectDelay: config.reconnectDelay || 5000,
            maxReconnectAttempts: config.maxReconnectAttempts || 5
        };

        // Stato della connessione
        this.connected = false;
        this.reconnectCount = 0;
        this.client = null;

        // Gestione topic e callback
        this.subscriptions = new Map();
        this.messageHandlers = new Map();
        this.errorHandlers = new Set();
        this.connectionHandlers = new Set();

        // Buffer messaggi offline
        this.offlineMessageQueue = [];

        // Bind dei metodi
        this._handleConnect = this._handleConnect.bind(this);
        this._handleLostConnection = this._handleLostConnection.bind(this);
        this._handleMessage = this._handleMessage.bind(this);
        this._handleError = this._handleError.bind(this);
    }

    /**
     * Inizializza la connessione MQTT
     * @returns {Promise} Promise che si risolve quando la connessione è stabilita
     */
    async connect() {
        return new Promise((resolve, reject) => {
            try {
                // Crea un nuovo client MQTT
                this.client = new Paho.MQTT.Client(
                    this.config.host,
                    this.config.port,
                    this.config.path,
                    this.config.clientId
                );

                // Configura i callback
                this.client.onConnectionLost = this._handleLostConnection;
                this.client.onMessageArrived = this._handleMessage;

                // Opzioni di connessione
                const options = {
                    useSSL: this.config.useSSL,
                    userName: this.config.username,
                    password: this.config.password,
                    keepAliveInterval: this.config.keepaliveInterval,
                    connectTimeout: this.config.connectTimeout,
                    onSuccess: () => {
                        this._handleConnect();
                        resolve();
                    },
                    onFailure: (error) => {
                        this._handleError(error);
                        reject(error);
                    }
                };

                // Connetti al broker
                this.client.connect(options);

            } catch (error) {
                reject(error);
            }
        });
    }

    /**
     * Gestisce la connessione stabilita
     * @private
     */
    _handleConnect() {
        this.connected = true;
        this.reconnectCount = 0;
        console.log('Connessione MQTT stabilita');

        // Ripristina le sottoscrizioni
        this.subscriptions.forEach((qos, topic) => {
            this._resubscribe(topic, qos);
        });

        // Invia i messaggi in coda
        while (this.offlineMessageQueue.length > 0) {
            const { topic, message, options } = this.offlineMessageQueue.shift();
            this.publish(topic, message, options);
        }

        // Notifica i listener
        this.connectionHandlers.forEach(handler => {
            handler({ connected: true });
        });
    }

    /**
     * Gestisce la perdita di connessione
     * @private
     * @param {Object} responseObject Oggetto di risposta con i dettagli della disconnessione
     */
    _handleLostConnection(responseObject) {
        this.connected = false;
        console.warn('Connessione MQTT persa:', responseObject.errorMessage);

        // Notifica i listener
        this.connectionHandlers.forEach(handler => {
            handler({ connected: false, error: responseObject });
        });

        // Tenta la riconnessione se non è una disconnessione volontaria
        if (responseObject.errorCode !== 0) {
            this._attemptReconnect();
        }
    }

    /**
     * Tenta la riconnessione al broker
     * @private
     */
    async _attemptReconnect() {
        if (this.reconnectCount >= this.config.maxReconnectAttempts) {
            console.error('Numero massimo di tentativi di riconnessione raggiunto');
            return;
        }

        this.reconnectCount++;
        console.log(`Tentativo di riconnessione ${this.reconnectCount}/${this.config.maxReconnectAttempts}`);

        try {
            await new Promise(resolve => setTimeout(resolve, this.config.reconnectDelay));
            await this.connect();
        } catch (error) {
            console.error('Tentativo di riconnessione fallito:', error);
            this._attemptReconnect();
        }
    }

    /**
     * Gestisce i messaggi in arrivo
     * @private
     * @param {Paho.MQTT.Message} message Messaggio MQTT ricevuto
     */
    _handleMessage(message) {
        const topic = message.destinationName;
        const payload = message.payloadString;

        // Cerca handler specifici per il topic
        this.messageHandlers.forEach((handler, pattern) => {
            if (this._matchTopic(topic, pattern)) {
                try {
                    handler(topic, payload);
                } catch (error) {
                    console.error(`Errore nell'handler del topic ${topic}:`, error);
                }
            }
        });
    }

    /**
     * Verifica se un topic corrisponde a un pattern
     * @private
     * @param {string} topic Topic da verificare
     * @param {string} pattern Pattern con cui confrontare
     * @returns {boolean} true se il topic corrisponde al pattern
     */
    _matchTopic(topic, pattern) {
        const topicParts = topic.split('/');
        const patternParts = pattern.split('/');

        if (topicParts.length !== patternParts.length) {
            return false;
        }

        return patternParts.every((part, i) => {
            return part === '+' || part === '#' || part === topicParts[i];
        });
    }

    /**
     * Gestisce gli errori
     * @private
     * @param {Error} error Errore da gestire
     */
    _handleError(error) {
        console.error('Errore MQTT:', error);
        this.errorHandlers.forEach(handler => {
            handler(error);
        });
    }

    /**
     * Sottoscrive a un topic
     * @param {string} topic Topic da sottoscrivere
     * @param {Function} handler Handler per i messaggi
     * @param {Object} options Opzioni di sottoscrizione
     * @returns {Promise} Promise che si risolve alla sottoscrizione completata
     */
    async subscribe(topic, handler, options = { qos: 0 }) {
        return new Promise((resolve, reject) => {
            try {
                this.subscriptions.set(topic, options.qos);
                this.messageHandlers.set(topic, handler);

                if (this.connected) {
                    this.client.subscribe(topic, {
                        qos: options.qos,
                        onSuccess: () => {
                            console.log(`Sottoscritto al topic: ${topic}`);
                            resolve();
                        },
                        onFailure: (error) => {
                            console.error(`Errore sottoscrizione al topic ${topic}:`, error);
                            reject(error);
                        }
                    });
                } else {
                    resolve(); // Verrà sottoscritto alla riconnessione
                }
            } catch (error) {
                reject(error);
            }
        });
    }

    /**
     * Ripristina una sottoscrizione
     * @private
     * @param {string} topic Topic da risottoscrivere
     * @param {number} qos QoS della sottoscrizione
     */
    _resubscribe(topic, qos) {
        this.client.subscribe(topic, {
            qos,
            onSuccess: () => console.log(`Risottoscritto al topic: ${topic}`),
            onFailure: (error) => console.error(`Errore risottoscrizione al topic ${topic}:`, error)
        });
    }

    /**
     * Pubblica un messaggio
     * @param {string} topic Topic su cui pubblicare
     * @param {string|Object} message Messaggio da pubblicare
     * @param {Object} options Opzioni di pubblicazione
     * @returns {Promise} Promise che si risolve alla pubblicazione completata
     */
    async publish(topic, message, options = { qos: 0, retained: false }) {
        return new Promise((resolve, reject) => {
            try {
                const payload = typeof message === 'string' ? message : JSON.stringify(message);
                const mqttMessage = new Paho.MQTT.Message(payload);
                mqttMessage.destinationName = topic;
                mqttMessage.qos = options.qos;
                mqttMessage.retained = options.retained;

                if (this.connected) {
                    this.client.send(mqttMessage);
                    resolve();
                } else {
                    // Salva il messaggio per l'invio alla riconnessione
                    this.offlineMessageQueue.push({ topic, message: payload, options });
                    resolve();
                }
            } catch (error) {
                reject(error);
            }
        });
    }

    /**
     * Cancella la sottoscrizione a un topic
     * @param {string} topic Topic da cui cancellare la sottoscrizione
     * @returns {Promise} Promise che si risolve alla cancellazione completata
     */
    async unsubscribe(topic) {
        return new Promise((resolve, reject) => {
            try {
                if (this.connected) {
                    this.client.unsubscribe(topic, {
                        onSuccess: () => {
                            this.subscriptions.delete(topic);
                            this.messageHandlers.delete(topic);
                            console.log(`Sottoscrizione cancellata per il topic: ${topic}`);
                            resolve();
                        },
                        onFailure: reject
                    });
                } else {
                    this.subscriptions.delete(topic);
                    this.messageHandlers.delete(topic);
                    resolve();
                }
            } catch (error) {
                reject(error);
            }
        });
    }

    /**
     * Aggiunge un handler per gli eventi di connessione
     * @param {Function} handler Handler da aggiungere
     */
    onConnection(handler) {
        this.connectionHandlers.add(handler);
    }

    /**
     * Rimuove un handler per gli eventi di connessione
     * @param {Function} handler Handler da rimuovere
     */
    offConnection(handler) {
        this.connectionHandlers.delete(handler);
    }

    /**
     * Aggiunge un handler per gli errori
     * @param {Function} handler Handler da aggiungere
     */
    onError(handler) {
        this.errorHandlers.add(handler);
    }

    /**
     * Rimuove un handler per gli errori
     * @param {Function} handler Handler da rimuovere
     */
    offError(handler) {
        this.errorHandlers.delete(handler);
    }

    /**
     * Disconnette dal broker MQTT
     */
    disconnect() {
        if (this.connected) {
            this.client.disconnect();
            this.connected = false;
        }
    }
}

// Crea un'istanza del gestore MQTT per l'uso comune
const mqttClient = new MQTTManager({
    host: 'localhost',
    port: 8883,
    useSSL: true,
    username: '20019309',
    password: 'Pissir2024!'
});

// Esporta sia la classe che l'istanza singleton
export { MQTTManager, mqttClient };

================
File: src/main/resources/public/js/common/utils.js
================
/**
 * Modulo delle funzioni di utilità per l'applicazione.
 * Fornisce funzionalità comuni come chiamate API, gestione token,
 * formattazione e validazione.
 */

class Utils {
    // Configurazione base
    static API_BASE_URL = '/api';
    static TOKEN_KEY = 'auth_token';
    static REFRESH_TOKEN_KEY = 'refresh_token';

    /**
     * Esegue una chiamata API
     * @param {string} endpoint - Endpoint API
     * @param {Object} options - Opzioni della richiesta
     * @returns {Promise<any>} Response data
     */
    static async apiCall(endpoint, options = {}) {
        try {
            // Prepara l'URL
            const url = `${this.API_BASE_URL}${endpoint}`;
            

            // Configura le opzioni di default
            const defaultOptions = {
                headers: {
                    'Content-Type': 'application/json',
                },
                credentials: 'same-origin'
            };

            // Aggiunge il token di autenticazione se presente
            const token = this.getToken();
            console.log(token);
            if (token) {
                defaultOptions.headers['Authorization'] = `Bearer ${token}`;
            }

            // Unisce le opzioni
            const fetchOptions = {
                ...defaultOptions,
                ...options,
                headers: {
                    ...defaultOptions.headers,
                    ...options.headers
                }
            };

            // Esegue la richiesta
            const response = await fetch(url, fetchOptions);
/*
            // Gestisce errori HTTP
            if (!response.ok) {
                // Gestisce token scaduto
                if (response.status === 401) {
                    const refreshed = await this.refreshToken();
                    if (refreshed) {
                        // Riprova la chiamata con il nuovo token
                        return this.apiCall(endpoint, options);
                    }
                    // Se il refresh fallisce, logout
                    throw new Error('Sessione richiesta');
                }
                
                const error = await response.json();
                throw new Error(error.message || 'Errore nella richiesta');
            }
*/
            // Gestisce risposte vuote
            if (response.status === 204) {
                return null;
            }

            // Restituisce i dati
            return await response.json();

        } catch (error) {
            console.error('API call error:', error);
            throw error;
        }
    }
    
    static async apiCall2(endpoint, options = {}) {
        try {
            // Prepara l'URL
            const url = `${endpoint}`;
            

            // Configura le opzioni di default
            const defaultOptions = {
                headers: {
                    'Content-Type': 'application/json',
                },
                credentials: 'same-origin'
            };

            // Aggiunge il token di autenticazione se presente
            const token = this.getToken();
            console.log(token);
            if (token) {
                defaultOptions.headers['Authorization'] = `Bearer ${token}`;
            }

            // Unisce le opzioni
            const fetchOptions = {
                ...defaultOptions,
                ...options,
                headers: {
                    ...defaultOptions.headers,
                    ...options.headers
                }
            };

            // Esegue la richiesta
            const response = await fetch(url, fetchOptions);
/*
            // Gestisce errori HTTP
            if (!response.ok) {
                // Gestisce token scaduto
                if (response.status === 401) {
                    const refreshed = await this.refreshToken();
                    if (refreshed) {
                        // Riprova la chiamata con il nuovo token
                        return this.apiCall(endpoint, options);
                    }
                    // Se il refresh fallisce, logout
                    throw new Error('Sessione richiesta');
                }
                
                const error = await response.json();
                throw new Error(error.message || 'Errore nella richiesta');
            }
*/
            // Gestisce risposte vuote
            if (response.status === 204) {
                return null;
            }

            // Restituisce i dati
            return await response.json();

        } catch (error) {
            console.error('API call error:', error);
            throw error;
        }
    }
    /**
     * Creates a debounced version of a function that delays its execution
     * until after `delay` milliseconds have elapsed since the last time it was called.
     * 
     * @param {Function} func - The function to debounce
     * @param {number} delay - The delay in milliseconds
     * @returns {Function} - The debounced function
     */
    static debounce(func, delay = 300) {
        let timeoutId;
        
        return function (...args) {
            // Clear any existing timeout
            if (timeoutId) {
                clearTimeout(timeoutId);
            }
            
            // Set up new timeout
            timeoutId = setTimeout(() => {
                func.apply(this, args);
            }, delay);
        };
    }
    /**
     * Esegue il refresh del token
     * @returns {Promise<boolean>} Success status
     */
    static async refreshToken() {
        try {
            const refreshToken = this.getRefreshToken();
            if (!refreshToken) {
                return false;
            }

            const response = await fetch(`${this.API_BASE_URL}/auth/refresh`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${refreshToken}`
                }
            });

            if (!response.ok) {
                return false;
            }

            const { token, refreshToken: newRefreshToken } = await response.json();
            
            this.setToken(token);
            this.setRefreshToken(newRefreshToken);
            
            return true;

        } catch (error) {
            console.error('Token refresh error:', error);
            return false;
        }
    }

    /**
     * Gestisce il token di autenticazione
     */
    static getToken() {
        return localStorage.getItem(this.TOKEN_KEY);
    }

    static setToken(token) {
        localStorage.setItem(this.TOKEN_KEY, token);
    }

    static getRefreshToken() {
        return localStorage.getItem(this.REFRESH_TOKEN_KEY);
    }

    static setRefreshToken(token) {
        localStorage.setItem(this.REFRESH_TOKEN_KEY, token);
    }

    static clearTokens() {
        localStorage.removeItem(this.TOKEN_KEY);
        localStorage.removeItem(this.REFRESH_TOKEN_KEY);
    }

    /**
     * Gestione logout
     */
    /*static logout() {
        this.clearTokens();
        window.location.href = '/index.html';
    }*/

    /**
     * Mostra un messaggio toast
     * @param {string} message - Messaggio da mostrare
     * @param {string} type - Tipo di toast (success, error, warning, info)
     * @param {number} duration - Durata in ms
     */
    static showToast(message, type = 'info', duration = 3000) {
        const container = document.getElementById('toastContainer') || 
            this.createToastContainer();

        const toast = document.createElement('div');
        toast.className = `toast toast-${type} fade-in`;
        
        const icon = this.getToastIcon(type);
        
        toast.innerHTML = `
            <i class="${icon}"></i>
            <span class="toast-message">${message}</span>
        `;

        container.appendChild(toast);

        // Animazione di entrata
        setTimeout(() => toast.classList.add('show'), 100);

        // Rimozione automatica
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 300);
        }, duration);
    }

    /**
     * Crea il container per i toast se non esiste
     */
    static createToastContainer() {
        const container = document.createElement('div');
        container.id = 'toastContainer';
        container.className = 'toast-container';
        document.body.appendChild(container);
        return container;
    }

    /**
     * Restituisce l'icona per il tipo di toast
     */
    static getToastIcon(type) {
        const icons = {
            success: 'fas fa-check-circle',
            error: 'fas fa-exclamation-circle',
            warning: 'fas fa-exclamation-triangle',
            info: 'fas fa-info-circle'
        };
        return icons[type] || icons.info;
    }

    /**
     * Formatta un prezzo in Euro
     */
    static formatPrice(amount) {
        return new Intl.NumberFormat('it-IT', {
            style: 'currency',
            currency: 'EUR'
        }).format(amount);
    }

    /**
     * Formatta una data in formato italiano
     */
    static formatDate(date) {
        return new Intl.DateTimeFormat('it-IT', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
        }).format(new Date(date));
    }

    /**
     * Mostra/Nasconde l'overlay di caricamento
     */
    static toggleLoading(show) {
        const overlay = document.getElementById('loadingOverlay');
        if (overlay) {
            overlay.classList.toggle('hidden', !show);
        }
    }

    /**
     * Valida una email
     */
    static validateEmail(email) {
        const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return re.test(email);
    }

    /**
     * Valida una password
     */
    static validatePassword(password) {
        // Almeno 8 caratteri, una maiuscola, una minuscola, un numero
        const re = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,}$/;
        return re.test(password);
    }

    /**
     * Sanifica input HTML
     */
    static sanitizeHTML(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }
}

export default Utils;

================
File: src/main/resources/public/pages/admin/dash_admin.html
================
<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Amministratore - Sistema Distributori</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
</head>
<body class="bg-gray-100">
    <!-- Navigation -->
    <nav class="bg-blue-600 text-white p-4" style="background-color:grey">
        <div class="container mx-auto flex justify-between items-center">
            <h1 class="text-2xl font-bold" >Dashboard Amministratore</h1> 
            <div>
                <span id="userInfo" class="mr-3"></span>
                <button onclick="window.location.href = '/index.html'" class="bg-blue-500 px-3 py-2 rounded hover:bg-blue-600">
                    Home
                </button>
               </div>
               <div>
                <span id="userInfo" class="user-info">
                <span id="userName"></span>
                    <i class="fas fa-user"></i>
                </span>
                <button onclick="logout()" class="bg-red-500 px-3 py-2 rounded hover:bg-red-600">
                    Logout
                </button>
            </div>
        </div>
    </nav>
    
    

    <!-- Main Content -->
    <div class="container mx-auto p-4">
        <!-- Navigation Tabs -->
        <div class="mb-4 border-b border-gray-200">
            <ul class="flex flex-wrap -mb-px" id="myTab">
                <li class="mr-2">
                    <button onclick="showTab('istituti')" class="tab-btn inline-block p-4" data-tab="istituti">
                        <i class="fas fa-building mr-2"></i>Istituti
                    </button>
                </li>
                <li class="mr-2">
                    <button onclick="showTab('macchine')" class="tab-btn inline-block p-4" data-tab="macchine">
                        <i class="fas fa-coffee mr-2"></i>Macchine
                    </button>
                </li>
                <li class="mr-2">
                    <button onclick="showTab('magazzino')" class="tab-btn inline-block p-4" data-tab="magazzino">
                        <i class="fas fa-warehouse mr-2"></i>Magazzino
                    </button>
                </li>
                <li class="mr-2">
                    <button onclick="showTab('finanze')" class="tab-btn inline-block p-4" data-tab="finanze">
                        <i class="fas fa-chart-line mr-2"></i>Finanze
                    </button>
                </li>
                <li class="mr-2">
                    <button onclick="showTab('utenti')" class="tab-btn inline-block p-4" data-tab="utenti">
                        <i class="fas fa-users mr-2"></i>Utenti
                    </button>
                </li>
                <li class="mr-2">
                    <button onclick="showTab('monitoraggio')" class="tab-btn inline-block p-4" data-tab="monitoraggio">
                        <i class="fas fa-desktop mr-2"></i>Monitoraggio
                    </button>
                </li>
            </ul>
        </div>

        <!-- Tab Contents -->
        <div id="tabContents">
            <!-- Istituti Tab -->
            <div id="istituti" class="tab-content hidden">
                <div class="flex justify-between mb-4">
                    <h2 class="text-xl font-bold">Gestione Istituti</h2>
                    <button onclick="showModal('addIstitutoModal')" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600">
                        <i class="fas fa-plus mr-2"></i>Nuovo Istituto
                    </button>
                </div>
                <div class="bg-white rounded-lg shadow p-4">
                    <table class="min-w-full">
                        <thead>
                            <tr>
                                <th class="text-left py-2">Nome</th>
                                <th class="text-left py-2">Indirizzo</th>
                                <th class="text-left py-2">Macchine</th>
                                <th class="text-left py-2">Azioni</th>
                            </tr>
                        </thead>
                        <tbody id="istitutiList">
                            <!-- Populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Macchine Tab -->
            <div id="macchine" class="tab-content hidden">
                <div class="flex justify-between mb-4">
                    <h2 class="text-xl font-bold">Gestione Macchine</h2>
                    <button onclick="showModal('addMacchinaModal')" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600">
                        <i class="fas fa-plus mr-2"></i>Nuova Macchina
                    </button>
                </div>
                <div class="bg-white rounded-lg shadow p-4">
                    <table class="min-w-full">
                        <thead>
                            <tr>
                                <th class="text-left py-2">ID</th>
                                <th class="text-left py-2">Istituto</th>
                                <th class="text-left py-2">Stato</th>
                                <th class="text-left py-2">Incasso</th>
                                <th class="text-left py-2">Azioni</th>
                            </tr>
                        </thead>
                        <tbody id="macchineList">
                            <!-- Populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Magazzino Tab -->
            <div id="magazzino" class="tab-content hidden">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="bg-white rounded-lg shadow p-4">
                        <h3 class="text-lg font-bold mb-4">Scorte Cialde</h3>
                        <div id="scorteCialde"></div>
                    </div>
                    <div class="bg-white rounded-lg shadow p-4">
                        <h3 class="text-lg font-bold mb-4">Rifornimenti Necessari</h3>
                        <div id="rifornimentiList"></div>
                    </div>
                </div>
            </div>

            <!-- Finanze Tab -->
            <div id="finanze" class="tab-content hidden">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="bg-white rounded-lg shadow p-4">
                        <h3 class="text-lg font-bold mb-4">Ricavi Totali</h3>
                        <canvas id="ricaviChart"></canvas>
                    </div>
                    <div class="bg-white rounded-lg shadow p-4">
                        <h3 class="text-lg font-bold mb-4">Transazioni Recenti</h3>
                        <div id="transazioniList"></div>
                    </div>
                </div>
            </div>

            <!-- Utenti Tab -->
            <div id="utenti" class="tab-content hidden">
                <div class="flex justify-between mb-4">
                    <h2 class="text-xl font-bold">Gestione Utenti</h2>
                    <button onclick="showModal('addUserModal')" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600">
                        <i class="fas fa-plus mr-2"></i>Nuovo Utente
                    </button>
                </div>
                <div class="bg-white rounded-lg shadow p-4">
                    <table class="min-w-full">
                        <thead>
                            <tr>
                                <th class="text-left py-2">Nome</th>
                                <th class="text-left py-2">Ruolo</th>
                                <th class="text-left py-2">Ultimo Accesso</th>
                                <th class="text-left py-2">Azioni</th>
                            </tr>
                        </thead>
                        <tbody id="utentiList">
                            <!-- Populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Monitoraggio Tab -->
            <div id="monitoraggio" class="tab-content hidden">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div class="bg-white rounded-lg shadow p-4">
                        <h3 class="text-lg font-bold mb-4">Stato Sistema</h3>
                        <div id="statoSistema"></div>
                    </div>
                    <div class="bg-white rounded-lg shadow p-4">
                        <h3 class="text-lg font-bold mb-4">Allarmi Attivi</h3>
                        <div id="allarmiList"></div>
                    </div>
                    <div class="bg-white rounded-lg shadow p-4">
                        <h3 class="text-lg font-bold mb-4">Performance</h3>
                        <canvas id="performanceChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <!-- Add Istituto Modal -->
    <div id="addIstitutoModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden">
        <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
            <div class="mt-3 text-center">
                <h3 class="text-lg leading-6 font-medium text-gray-900">Aggiungi Nuovo Istituto</h3>
                <div class="mt-2 px-7 py-3">
                    <input type="text" id="nomeIstituto" placeholder="Nome Istituto" class="mb-3 px-3 py-2 border rounded w-full">
                    <input type="text" id="indirizzoIstituto" placeholder="Indirizzo" class="mb-3 px-3 py-2 border rounded w-full">
                </div>
                <div class="items-center px-4 py-3">
                    <button id="saveIstitutoBtn" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
                        Salva
                    </button>
                    <button onclick="hideModal('addIstitutoModal')" class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">
                        Annulla
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Macchina Modal -->
    <div id="addMacchinaModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden">
        <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
            <div class="mt-3 text-center">
                <h3 class="text-lg leading-6 font-medium text-gray-900">Aggiungi Nuova Macchina</h3>
                <div class="mt-2 px-7 py-3">
                    <select id="istitutoSelect" class="mb-3 px-3 py-2 border rounded w-full">
                        <!-- Populated by JavaScript -->
                    </select>
                    <input type="number" id="cassaMassima" placeholder="Capacità Cassa" class="mb-3 px-3 py-2 border rounded w-full">
                </div>
                <div class="items-center px-4 py-3">
                    <button id="saveMacchinaBtn" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
                        Salva
                    </button>
                    <button onclick="hideModal('addMacchinaModal')" class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">
                        Annulla
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add User Modal -->
    <div id="addUserModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden">
        <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
            <div class="mt-3 text-center">
                <h3 class="text-lg leading-6 font-medium text-gray-900">Aggiungi Nuovo Utente</h3>
                <div class="mt-2 px-7 py-3">
                    <input type="text" id="nomeUtente" placeholder="Nome" class="mb-3 px-3 py-2 border rounded w-full">
                    <input type="text" id="username" placeholder="Username" class="mb-3 px-3 py-2 border rounded w-full">
                    <input type="password" id="password" placeholder="Password" class="mb-3 px-3 py-2 border rounded w-full">
                    <select id="ruoloSelect" class="mb-3 px-3 py-2 border rounded w-full">
                        <option value="Amministratore">Amministratore</option>
                        <option value="Tecnico">Tecnico</option>
                        <option value="Operatore">Operatore</option>
                    </select>
                </div>
                <div class="items-center px-4 py-3">
                    <button id="saveUserBtn" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
                        Salva
                    </button>
                    <button onclick="hideModal('addUserModal')" class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">
                        Annulla
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
    const userInfo = document.getElementById('userInfo');
    const userNameSpan = document.getElementById('userName');
    userNameSpan.textContent = localStorage.getItem('user_name');
        // API Configuration
        const API_BASE_URL = 'http://localhost:8080/api';
        let currentUser = null;
        let currentTab = 'istituti';

        // Check Authentication
        function checkAuth() {
            const token = localStorage.getItem('jwt_token');
            if (!token) {
                window.location.href = '/index.html';
                return;
            }
            
            // Set authorization header for all requests
            axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
            
        }

        // Logout Function
        function logout() {
            localStorage.removeItem('jwt_token');
            window.location.href = '/index.html';
        }

        // Tab Management
        function showTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.add('hidden');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('text-blue-600', 'border-blue-600', 'border-b-2');
            });
            
            // Show selected tab
            document.getElementById(tabName).classList.remove('hidden');
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('text-blue-600', 'border-blue-600', 'border-b-2');
            
            currentTab = tabName;
            loadTabData(tabName);
        }

        // Modal Management
        function showModal(modalId) {
            document.getElementById(modalId).classList.remove('hidden');
        }

        function hideModal(modalId) {
            document.getElementById(modalId).classList.add('hidden');
        }

        // Load Tab Data
        function loadTabData(tabName) {
            switch(tabName) {
                case 'istituti':
                    loadIstituti();
                    break;
                case 'macchine':
                    loadMacchine();
                    break;
                case 'magazzino':
                    loadMagazzino();
                    break;
                case 'finanze':
                    loadFinanze();
                    break;
                case 'utenti':
                    loadUtenti();
                    break;
                case 'monitoraggio':
                    loadMonitoraggio();
                    break;
            }
        }

        // Istituti Management
        function loadIstituti() {
            axios.get(`${API_BASE_URL}/istituti`)
                .then(response => {
                    const istituti = response.data;
                    const tbody = document.getElementById('istitutiList');
                    tbody.innerHTML = '';
                    
                    istituti.forEach(istituto => {
                    	const macchine = istituto.macchine ? istituto.macchine.length : 0;
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td class="py-2">${istituto.nome}</td>
                            <td class="py-2">${istituto.indirizzo}</td>
                            <td class="py-2">${macchine}</td>
                            <td class="py-2">
                                <button onclick="editIstituto(${istituto.id})" class="text-blue-500 hover:text-blue-700 mr-2">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button onclick="deleteIstituto(${istituto.id})" class="text-red-500 hover:text-red-700">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </td>
                        `;
                        tbody.appendChild(row);
                    });
                })
                .catch(error => {
                    console.error('Error loading istituti:', error);
                    alert('Errore nel caricamento degli istituti');
                });
        }

        // Save Istituto
        document.getElementById('saveIstitutoBtn').addEventListener('click', () => {
            const nome = document.getElementById('nomeIstituto').value;
            const indirizzo = document.getElementById('indirizzoIstituto').value;
            if (!nome || !indirizzo) {
                alert('Compilare tutti i campi');
                return;
            }
            
            axios.post(`${API_BASE_URL}/admin/istituti`, { nome, indirizzo })
                .then(() => {
                    hideModal('addIstitutoModal');
                    loadIstituti();
                })
                .catch(error => {
                    console.error('Error saving istituto:', error);
                    alert('Errore nel salvataggio dell\'istituto');
                });
        });

        // Machine Management
        function loadMacchine() {
            axios.get(`${API_BASE_URL}/macchine`)
                .then(response => {
                    const macchine = response.data;
                    const tbody = document.getElementById('macchineList');
                    tbody.innerHTML = '';
                    
                    macchine.forEach(macchina => {
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td class="py-2">${macchina.id}</td>
                            <td class="py-2">${macchina.nomeIstituto}</td>
                            <td class="py-2">
                                <span class="px-2 py-1 rounded ${getStatoClass(macchina.statoId)}">
                                    ${macchina.statoDescrizione}
                                </span>
                            </td>
                            <td class="py-2">€${macchina.cassaAttuale.toFixed(2)}</td>
                            <td class="py-2">
                                <button onclick="configuraMacchina(${macchina.id})" class="text-blue-500 hover:text-blue-700 mr-2">
                                    <i class="fas fa-cog"></i>
                                </button>
                                <button onclick="deleteMacchina(${macchina.id})" class="text-red-500 hover:text-red-700">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </td>
                        `;
                        tbody.appendChild(row);
                    });
                })
                .catch(error => {
                    console.error('Error loading macchine:', error);
                    alert('Errore nel caricamento delle macchine');
                });
        }
        
        // Add macchina
        function addMacchina() {
    		const istitutoId = document.getElementById('istitutoSelect').value;
    		const cassaMassima = document.getElementById('cassaMassima').value;

		    if (!istitutoId || !cassaMassima) {
		        alert('Compilare tutti i campi');
		        return;
		    }
		
		    axios.post(`${API_BASE_URL}/admin/macchine`, { istitutoId, cassaMassima })
		        .then(() => {
		            hideModal('addMacchinaModal');
		            loadMacchine();
		        })
		        .catch(error => {
		            console.error('Error adding machine:', error);
		            alert('Errore nell\'aggiunta della macchina');
		        });
		}
        
        // Modifica stato macchina
        function updateStatoMacchina(id, statoId) {
		    axios.put(`${API_BASE_URL}/admin/macchine/${id}/stato`, { statoId })
		        .then(() => {
		            loadMacchine();
		        })
		        .catch(error => {
		            console.error('Error updating machine status:', error);
		            alert('Errore nell\'aggiornamento dello stato della macchina');
		        });
		}
        
        // Delete macchina
        function deleteMacchina(id) {
		    if (confirm('Sei sicuro di voler eliminare questa macchina?')) {
		        axios.delete(`${API_BASE_URL}/admin/macchine/${id}`)
		            .then(() => {
		                loadMacchine();
		            })
		            .catch(error => {
		                console.error('Error deleting machine:', error);
		                alert('Errore nell\'eliminazione della macchina');
		            });
		    }
		}
        // Modifica Istituto
        function editIstituto(id) {
		    const nome = prompt('Nuovo nome istituto:');
		    const indirizzo = prompt('Nuovo indirizzo:');
		
		    if (nome && indirizzo) {
		        axios.put(`${API_BASE_URL}/admin/istituti/${id}`, { nome, indirizzo })
		            .then(() => {
		                loadIstituti();
		            })
		            .catch(error => {
		                console.error('Error updating istituto:', error);
		                alert('Errore nell\'aggiornamento dell\'istituto');
		            });
		    }
		}

        function deleteIstituto(id) {
            if (confirm('Sei sicuro di voler eliminare questo istituto?')) {
                axios.delete(`${API_BASE_URL}/admin/istituti/${id}`)
                    .then(() => {
                        loadIstituti();
                    })
                    .catch(error => {
                        console.error('Error deleting istituto:', error);
                        alert('Errore nell\'eliminazione dell\'istituto');
                    });
            }
        }

        // Gestione Macchine
        function configuraMacchina(id) {
            const statoId = prompt('Nuovo stato (1=Attiva, 2=Manutenzione, 3=Fuori servizio):');
            if (statoId) {
                axios.put(`${API_BASE_URL}/admin/macchine/${id}/stato`, { statoId: parseInt(statoId) })
                    .then(() => {
                    	loadMacchine();
                    	alert('Stato aggiornato correttamente!');
                    })
                    .catch(error => {
                        console.error('Error updating machine status:', error);
                        alert('Errore nell\'aggiornamento dello stato della macchina');
                    });
            }
        }

        // Add Bevanda
        function addBevanda() {
		    const nome = prompt('Nome bevanda:');
		    const prezzo = prompt('Prezzo:');
		
		    if (nome && prezzo) {
		        axios.post(`${API_BASE_URL}/admin/bevande`, { nome, prezzo })
		            .then(() => {
		                loadBevande();
		            })
		            .catch(error => {
		                console.error('Error adding beverage:', error);
		                alert('Errore nell\'aggiunta della bevanda');
		            });
		    }
		}
        
        // Aggiorna bevanda
        function updateBevanda(id) {
            const nome = prompt('Nuovo nome bevanda:');
            const prezzo = prompt('Nuovo prezzo:');

            if (nome && prezzo) {
                axios.put(`${API_BASE_URL}/admin/bevande/${id}`, { nome, prezzo })
                    .then(() => {
                        loadBevande();
                    })
                    .catch(error => {
                        console.error('Error updating beverage:', error);
                        alert('Errore nell\'aggiornamento della bevanda');
                    });
            }
        }
        // Elimina bevanda
        function deleteBevanda(id) {
            if (confirm('Sei sicuro di voler eliminare questa bevanda?')) {
                axios.delete(`${API_BASE_URL}/admin/bevande/${id}`)
                    .then(() => {
                        loadBevande();
                    })
                    .catch(error => {
                        console.error('Error deleting beverage:', error);
                        alert('Errore nell\'eliminazione della bevanda');
                    });
            }
        }

        // Gestione Manutenzioni
        function loadManutenzioni() {
            axios.get(`${API_BASE_URL}/manutenzioni`)
                .then(response => {
                    const manutenzioni = response.data;
                    // Implementare la visualizzazione delle manutenzioni
                })
                .catch(error => {
                    console.error('Error loading maintenance data:', error);
                    alert('Errore nel caricamento delle manutenzioni');
                });
        }

        function iniziaManutenzione(macchinaId) {
            axios.post(`${API_BASE_URL}/manutenzione`, { macchinaId })
                .then(() => {
                    loadManutenzioni();
                })
                .catch(error => {
                    console.error('Error starting maintenance:', error);
                    alert('Errore nell\'avvio della manutenzione');
                });
        }

        function completaManutenzione(id) {
            axios.put(`${API_BASE_URL}/manutenzione/${id}/completa`)
                .then(() => {
                    loadManutenzioni();
                })
                .catch(error => {
                    console.error('Error completing maintenance:', error);
                    alert('Errore nel completamento della manutenzione');
                });
        }

        function setFuoriServizio(macchinaId) {
            axios.put(`${API_BASE_URL}/manutenzione/${macchinaId}/fuori-servizio`)
                .then(() => {
                    loadMacchine();
                })
                .catch(error => {
                    console.error('Error setting machine out of service:', error);
                    alert('Errore nell\'impostazione fuori servizio');
                });
        }
        
        function loadMagazzino() {
            // Carica le scorte di cialde
            axios.get(`${API_BASE_URL}/bevande`)
                .then(response => {
                    const bevande = response.data;
                    const scorteCialde = document.getElementById('scorteCialde');
                    scorteCialde.innerHTML = '';

                    bevande.forEach(bevanda => {
                        const div = document.createElement('div');
                        div.className = 'mb-2';
                        div.innerHTML = `
                            <span class="font-medium">${bevanda.nome}</span>: 
                            <span class="text-gray-600">${bevanda.cialdeDisponibili} cialde disponibili</span>
                        `;
                        scorteCialde.appendChild(div);
                    });
                })
                .catch(error => {
                    console.error('Error loading bevande:', error);
                    alert('Errore nel caricamento delle scorte di cialde');
                });

            // Carica i rifornimenti necessari
            axios.get(`${API_BASE_URL}/bevande/rifornimenti`)
                .then(response => {
                    const rifornimenti = response.data;
                    const rifornimentiList = document.getElementById('rifornimentiList');
                    rifornimentiList.innerHTML = '';

                    rifornimenti.forEach(rifornimento => {
                        const div = document.createElement('div');
                        div.className = 'mb-2';
                        div.innerHTML = `
                            <span class="font-medium">${rifornimento.nome}</span>: 
                            <span class="text-gray-600">${rifornimento.quantitaNecessaria} cialde necessarie</span>
                        `;
                        rifornimentiList.appendChild(div);
                    });
                })
                .catch(error => {
                    console.error('Error loading rifornimenti:', error);
                    alert('Errore nel caricamento dei rifornimenti necessari');
                });
        }
        
        function loadFinanze() {
            // Carica i ricavi totali
            axios.get(`${API_BASE_URL}/ricavi`)
                .then(response => {
                    const ricavi = response.data;
                    const ricaviCtx = document.getElementById('ricaviChart').getContext('2d');
                    new Chart(ricaviCtx, {
                        type: 'line',
                        data: {
                            labels: ricavi.labels, // Supponiamo che i dati includano etichette per i mesi
                            datasets: [{
                                label: 'Ricavi Mensili',
                                data: ricavi.data, // Supponiamo che i dati includano i valori dei ricavi
                                borderColor: 'rgb(59, 130, 246)',
                                tension: 0.1
                            }]
                        },
                        options: {
                            responsive: true,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                })
                .catch(error => {
                    console.error('Error loading ricavi:', error);
                    alert('Errore nel caricamento dei ricavi');
                });

            // Carica le transazioni recenti
            axios.get(`${API_BASE_URL}/transazioni`)
            .then(response => {
                const transazioni = response.data;
                const transazioniList = document.getElementById('transazioniList');
                transazioniList.innerHTML = '';

                transazioni.forEach(transazione => {
                    const div = document.createElement('div');
                    div.className = 'mb-2';
                    div.innerHTML = `
                        <span class="font-medium">${transazione.bevandaNome}</span>: 
                        <span class="text-gray-600">€${transazione.importo.toFixed(2)} - ${transazione.dataOra}</span>
                    `;
                    transazioniList.appendChild(div);
                });
            })
            .catch(error => {
                console.error('Error loading transazioni:', error);
                alert('Errore nel caricamento delle transazioni');
            });
        }
        
        function loadUtenti() {
            axios.get(`${API_BASE_URL}/admin/utenti`)
                .then(response => {
                    const utenti = response.data;
                    const tbody = document.getElementById('utentiList');
                    tbody.innerHTML = '';

                    utenti.forEach(utente => {
                        const row = document.createElement('tr');
                        row.innerHTML = `
                        	
                            <td class="py-2">${utente.nome}</td>
                            <td class="py-2">${utente.ruolo}</td>
                            <td class="py-2">${utente.ultimoAccesso}</td>
                            <td class="py-2">
                                <button onclick="editUtente(${utente.id})" class="text-blue-500 hover:text-blue-700 mr-2">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button onclick="deleteUtente(${utente.id})" class="text-red-500 hover:text-red-700">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </td>
                        `;
                        tbody.appendChild(row);
                    });
                })
                .catch(error => {
                    console.error('Error loading utenti:', error);
                    alert('Errore nel caricamento degli utenti');
                });
        }
        
        function addUser() {
            const nome = document.getElementById('nomeUtente').value;
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            const ruolo = document.getElementById('ruoloSelect').value;

            if (!nome || !username || !password || !ruolo) {
                alert('Compilare tutti i campi');
                return;
            }

            axios.post(`${API_BASE_URL}/admin/utenti`, { nome, username, password, ruolo })
                .then(() => {
                    hideModal('addUserModal');
                    loadUtenti();
                })
                .catch(error => {
                    console.error('Error adding user:', error);
                    alert('Errore nell\'aggiunta dell\'utente');
                });
        }
        
        function editUtente(id) {
            const nome = prompt('Nuovo nome utente:');
            const ruolo = prompt('Nuovo ruolo (Amministratore, Tecnico, Operatore):');

            if (nome && ruolo) {
                axios.put(`${API_BASE_URL}/admin/utenti/${id}`, { nome, ruolo })
                    .then(() => {
                        loadUtenti();
                    })
                    .catch(error => {
                        console.error('Error updating user:', error);
                        alert('Errore nell\'aggiornamento dell\'utente');
                    });
            }
        }
        
        function deleteUtente(id) {
            if (confirm('Sei sicuro di voler eliminare questo utente?')) {
                axios.delete(`${API_BASE_URL}/admin/utenti/${id}`)
                    .then(() => {
                        loadUtenti();
                    })
                    .catch(error => {
                        console.error('Error deleting user:', error);
                        alert('Errore nell\'eliminazione dell\'utente');
                    });
            }
        }
        
        function loadMonitoraggio() {
            // Carica lo stato del sistema
            axios.get(`${API_BASE_URL}/monitoraggio/stato`)
                .then(response => {
                    const statoSistema = response.data;
                    const statoSistemaDiv = document.getElementById('statoSistema');
                    statoSistemaDiv.innerHTML = `
                        <div class="text-lg">${statoSistema.stato}</div>
                        <div class="text-gray-600">${statoSistema.descrizione}</div>
                    `;
                })
                .catch(error => {
                    console.error('Error loading stato sistema:', error);
                    alert('Errore nel caricamento dello stato del sistema');
                });

            // Carica gli allarmi attivi
            axios.get(`${API_BASE_URL}/monitoraggio/allarmi`)
                .then(response => {
                    const allarmi = response.data;
                    const allarmiList = document.getElementById('allarmiList');
                    allarmiList.innerHTML = '';

                    allarmi.forEach(allarme => {
                        const div = document.createElement('div');
                        div.className = 'mb-2';
                        div.innerHTML = `
                            <span class="font-medium">${allarme.tipo}</span>: 
                            <span class="text-gray-600">${allarme.descrizione}</span>
                        `;
                        allarmiList.appendChild(div);
                    });
                })
                .catch(error => {
                    console.error('Error loading allarmi:', error);
                    alert('Errore nel caricamento degli allarmi');
                });

            // Carica le performance delle macchine
            axios.get(`${API_BASE_URL}/monitoraggio/performance`)
                .then(response => {
                    const performance = response.data;
                    const perfCtx = document.getElementById('performanceChart').getContext('2d');
                    new Chart(perfCtx, {
                        type: 'doughnut',
                        data: {
                            labels: ['Attive', 'In Manutenzione', 'Fuori Servizio'],
                            datasets: [{
                                data: [performance.attive, performance.inManutenzione, performance.fuoriServizio],
                                backgroundColor: [
                                    'rgb(34, 197, 94)',
                                    'rgb(234, 179, 8)',
                                    'rgb(239, 68, 68)'
                                ]
                            }]
                        },
                        options: {
                            responsive: true
                        }
                    });
                })
                .catch(error => {
                    console.error('Error loading performance:', error);
                    alert('Errore nel caricamento delle performance');
                });
        }

        function getStatoClass(statoId) {
            switch(statoId) {
                case 1: return 'bg-green-100 text-green-800'; // Attiva
                case 2: return 'bg-yellow-100 text-yellow-800'; // In manutenzione
                case 3: return 'bg-red-100 text-red-800'; // Fuori servizio
                default: return 'bg-gray-100 text-gray-800';
            }
        }

        // Initialize Charts
        function initCharts() {
            // Ricavi Chart
            const ricaviCtx = document.getElementById('ricaviChart').getContext('2d');
            new Chart(ricaviCtx, {
                type: 'line',
                data: {
                    labels: ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu'],
                    datasets: [{
                        label: 'Ricavi Mensili',
                        data: [12000, 19000, 15000, 17000, 22000, 20000],
                        borderColor: 'rgb(59, 130, 246)',
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });

            // Performance Chart
            const perfCtx = document.getElementById('performanceChart').getContext('2d');
            new Chart(perfCtx, {
                type: 'doughnut',
                data: {
                    labels: ['Attive', 'In Manutenzione', 'Fuori Servizio'],
                    datasets: [{
                        data: [75, 15, 10],
                        backgroundColor: [
                            'rgb(34, 197, 94)',
                            'rgb(234, 179, 8)',
                            'rgb(239, 68, 68)'
                        ]
                    }]
                },
                options: {
                    responsive: true
                }
            });
        }

        // Initialize Application
        document.addEventListener('DOMContentLoaded', () => {
            checkAuth();
            showTab('istituti');
            initCharts();
        });
    </script>
</body>
</html>

================
File: src/main/resources/public/pages/admin/dash_impiegati.html
================
<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Impiegati - Sistema Distributori</title>
    <link rel="stylesheet" href="../../css/style.css">
</head>

<body>
    <div class="top-nav">
        <div class="nav-content">
            <div class="nav-brand">
                <span class="brand-text">Dashboard Impiegati</span>
            </div>
            <div class="nav-brand">
                <a class="btn btn-primary" href="/index.html">Home</a>
            </div>
            <div class="nav-actions">
                <span id="userInfo" class="mr-3"></span>
                <button onclick="logout()" class="btn btn-secondary">Logout</button>
            </div>
        </div>
    </div>
    <div class="main-container">
        <main class="content-area container">
            <!-- Sezione Istituti -->
            <div class="card mb-4" id="institutesSection" style="width:1500px; margin-top:15px">
                <div class="card-header">
                    <h2>Istituti Gestiti</h2>
                </div>
                <div class="card-body">
                    <div class="institutes-grid" id="institutesGrid"></div>
                </div>
            </div>

            <!-- Sezione Macchine -->
            <div class="card mb-4" id="machinesSection" style="display: none;width:1500px; margin-top:15px">
                <div class="card-header">
                    <div class="d-flex justify-content-between align-items-center">
                        <h3>Macchine - <span id="selectedInstituteName"></span></h3>
                        <button class="btn btn-secondary" onclick="backToInstitutes()">← Torna agli Istituti</button>
                    </div>
                </div>
                <div class="card-body">
                    <div class="machines-grid" id="machinesList"></div>
                </div>
            </div>

            <!-- Sezione Manutenzione -->
            <div class="card mb-4" id="maintenanceSection" style="display: none;">
                <div class="card-header">
                    <div class="d-flex justify-content-between align-items-center">
                        <h3>Dettagli Macchina #<span id="selectedMachineId"></span></h3>
                        <button class="btn btn-secondary" onclick="backToMachines()">← Torna alle Macchine</button>
                    </div>
                </div>
                <div class="card-body">
                    <div id="maintenanceDetails"></div>
                    <div class="form-group mt-3">
                        <button class="btn btn-primary" onclick="sendTechnician()">Invia Tecnico</button>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <div id="toastContainer" class="toast-container"></div>

    <script type="module">
        import auth from '../../js/common/authentication.js';
        let globalInstitutes = [];

        document.addEventListener('DOMContentLoaded', function () {
            checkAuthorization();
            loadInstitutes();
            displayUserInfo();
        });

        function checkAuthorization() {
            if (!auth.isEmployee()) {
                showToast('Non sei autorizzato a vedere questa pagina', 'error');
                setTimeout(() => window.location.href = '/index.html', 20000);
            }
        }

        function displayUserInfo() {
            const userName = localStorage.getItem('user_name');
            if (userName) {
                document.getElementById('userInfo').textContent = `Benvenuto, ${userName}`;
            }
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.getElementById('toastContainer').appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        async function loadInstitutes() {
            try {
                const response = await fetch('/istituti', {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('jwt_token')}`
                    }
                });
                if (!response.ok) throw new Error('Errore nel caricamento degli istituti');
                const institutes = await response.json();
                displayInstitutes(institutes);
            } catch (error) {
                showToast(error.message, 'error');
            }
        }

        // Rendiamo le funzioni disponibili globalmente
        window.displayInstitutes = function (institutes) {
            // Salviamo gli istituti globalmente
            window.globalInstitutes = institutes;

            const grid = document.getElementById('institutesGrid');
            grid.innerHTML = institutes.map(institute => `
        <div class="institute-card" onclick="window.showMachinesById(${institute.ID_istituto})">
            <h3>${institute.nome}</h3>
            <p class="address">${institute.indirizzo}</p><hr>
            <div class="machines-count">
                <span class="badge">Macchine disponibili: ${countMachines(institute)}</span><br>
				<span class="badge">Macchine attive: ${countActiveMachines(institute)}</span><br>
				<span class="badge">Macchine fuori uso: ${countMachinesNonActive(institute)}</span>
            </div>
        </div>
    `).join('');
        }

        function countActiveMachines(institute) {
            return institute.macchine ? institute.macchine.filter(m => m.statoId === 1).length : 0;
        }

        function countMachines(institute) {
            return institute.macchine ? institute.macchine.length : 0;
        }
        function countMachinesNonActive(institute) {
            return institute.macchine ? institute.macchine.filter(m => m.statoId !== 1).length : 0;
        }

        function showMachinesById(instituteId) {
            const institute = globalInstitutes.find(inst => inst.ID_istituto === instituteId);
            if (institute) {
                showMachines(institute.ID_istituto, institute.nome, institute.macchine);
            } else {
                showToast('Istituto non trovato', 'error');
            }
        }

        window.showMachinesById = function (instituteId) {
            const institute = window.globalInstitutes.find(inst => inst.ID_istituto === instituteId);
            if (institute) {
                window.showMachines(institute.ID_istituto, institute.nome, institute.macchine);
            } else {
                window.showToast('Istituto non trovato', 'error');
            }
        }
        window.showMachines = function (instituteId, instituteName, machines) {
            try {
                // Aggiorna la UI
                document.getElementById('institutesSection').style.display = 'none';
                document.getElementById('machinesSection').style.display = 'block';
                document.getElementById('selectedInstituteName').textContent = instituteName;

                // Mostra le macchine
                window.displayMachines(machines || []);
            } catch (error) {
                window.showToast(error.message, 'error');
            }
        }

        window.displayMachines = function (machines) {
            const machinesList = document.getElementById('machinesList');
            machinesList.innerHTML = machines.map(machine => `
        <div class="machine-card" onclick="window.showMaintenance(${machine.id})">
            <div class="machine-header">
                <div class="status-badge ${getStatusClass(machine.statoId)}"></div>
                <h4>Macchina #${machine.id}</h4>
            </div>
            <div class="machine-info">
                <p>Stato: ${machine.statoDescrizione}</p>
                <p>Cassa: €${machine.cassaAttuale.toFixed(2)} / €${machine.cassaMassima.toFixed(2)}</p>
            </div>
        </div>
    `).join('');
        }

        window.getStatusClass = function (statoId) {
            const classi = {
                1: 'status-available',
                2: 'status-maintenance',
                3: 'status-inactive'
            };
            return classi[statoId] || 'status-unknown';
        }

        function getStatusClass(stato) {
            const classi = {
                1: 'status-available',
                2: 'status-maintenance',
                3: 'status-inactive'
            };
            return classi[stato] || 'status-unknown';
        }

        async function showMaintenance(machineId) {
            try {
                document.getElementById('machinesSection').style.display = 'none';
                document.getElementById('maintenanceSection').style.display = 'block';
                document.getElementById('selectedMachineId').textContent = machineId;

                const [stateResponse, podsResponse] = await Promise.all([
                    fetch(`/api/macchine/${machineId}/stato`),
                    fetch(`/api/ad/manutenzioni/macchine/${machineId}`)
                ]);

                if (!stateResponse.ok || !podsResponse.ok) {
                    throw new Error('Errore nel caricamento dei dati di manutenzione');
                }

                const stateData = await stateResponse.json();
                const podsData = await podsResponse.json();

                displayMaintenanceDetails(stateData, podsData);
            } catch (error) {
                showToast(error.message, 'error');
            }
        }

        function displayMaintenanceDetails(stateData, podsData) {
            const maintenanceDetails = document.getElementById('maintenanceDetails');
            maintenanceDetails.innerHTML = `
            <div class="maintenance-info">
                <h4>Stato Macchina</h4>
                <p>Stato: ${getStatoDescrizione(stateData.Stato)}</p>
                <p>Ultimo intervento: ${stateData.ultimaManutenzione || 'Nessun intervento recente'}</p>
                
                <h4 class="mt-4">Livelli Cialde</h4>
                ${renderPodsStatus(podsData)}
                
                <h4 class="mt-4">Segnalazioni Attive</h4>
                <p>${stateData.segnalazioniAttive ? `${stateData.segnalazioniAttive} segnalazioni` : 'Nessuna segnalazione'}</p>
            </div>
        `;
        }

        function renderPodsStatus(podsData) {
            if (!podsData.cialde || podsData.cialde.length === 0) {
                return '<p>Nessun dato sulle cialde disponibile</p>';
            }

            return `
            <div class="pods-grid">
                ${podsData.cialde.map(cialda => `
                    <div class="pod-status ${cialda.Quantita < cialda.QuantitaMassima * 0.2 ? 'low-stock' : ''}">
                        <span>${cialda.NomeCialda}</span>
                        <div class="pod-level">
                            ${cialda.Quantita}/${cialda.QuantitaMassima}
                        </div>
                    </div>
                `).join('')}
            </div>
        `;
        }

        async function sendTechnician() {
            const machineId = document.getElementById('selectedMachineId').textContent;
            try {
                const response = await fetch('/api/ad/manutenzioni', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('jwt_token')}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        macchinaId: parseInt(machineId),
                        tipo: 'MANUTENZIONE_ORDINARIA',
                        descrizione: 'Intervento richiesto dall\'operatore'
                    })
                });

                if (!response.ok) throw new Error('Errore nell\'invio del tecnico');

                showToast('Tecnico inviato con successo', 'success');
                await showMaintenance(machineId);
            } catch (error) {
                showToast(error.message, 'error');
            }
        }

        function backToInstitutes() {
            document.getElementById('machinesSection').style.display = 'none';
            document.getElementById('institutesSection').style.display = 'block';
        }

        function backToMachines() {
            document.getElementById('maintenanceSection').style.display = 'none';
            document.getElementById('machinesSection').style.display = 'block';
        }

        function logout() {
            localStorage.removeItem('jwt_token');
            localStorage.removeItem('user_role');
            localStorage.removeItem('user_name');
            window.location.href = '/index.html';
        }

        // Funzione per tornare alla vista degli istituti
        window.backToInstitutes = function () {
            document.getElementById('machinesSection').style.display = 'none';
            document.getElementById('institutesSection').style.display = 'block';
        }

        // Funzione per tornare alla vista delle macchine
        window.backToMachines = function () {
            document.getElementById('maintenanceSection').style.display = 'none';
            document.getElementById('machinesSection').style.display = 'block';
        }
        if (!window.showToast) {
            window.showToast = function (message, type = 'info') {
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.textContent = message;
                document.getElementById('toastContainer').appendChild(toast);
                setTimeout(() => toast.remove(), 3000);
            }
        }
    </script>
</body>

</html>

================
File: src/main/resources/public/pages/admin/dashboard.html
================
<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Dashboard amministrativa</title>

    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="../../css/admin.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js"></script>
    <script src="../../js/common/utils.js" type="module"></script>
    <script src="../../js/common/mqtt.js" type="module"></script>
    <script src="../../js/common/authentication.js" type="module"></script>
    <script src="../../js/admin/dashboard.js" type="module"></script>

</head>
<body>
    <div class="admin-container">
        <!-- Header -->
        <header class="admin-header">
            <div class="header-title">
                <h1>Dashboard</h1>
            </div>
            <div class="header-actions">
                <span class="user-info">
                    <i class="fas fa-user"></i>
                    <span id="userName"></span>
                </span>
                <button class="btn-logout" onclick="auth.logout()">
                    <i class="fas fa-sign-out-alt"></i> Esci
                </button>
            </div>
        </header>

        <!-- Sidebar -->
        <nav class="admin-sidebar" id="adminNav">
            <a href="dashboard.html" class="nav-item active">
                <i class="fas fa-tachometer-alt"></i> Dashboard
            </a>
            <a href="machines.html" class="nav-item">
                <i class="fas fa-coffee"></i> Macchine
            </a>
            <a href="maintenance.html" class="nav-item">
                <i class="fas fa-tools"></i> Manutenzione
            </a>
            <a href="institutes.html" class="nav-item">
                <i class="fas fa-building"></i> Istituti
            </a>
            <a href="reports.html" class="nav-item">
                <i class="fas fa-chart-bar"></i> Report
            </a>
            <a href="pods.html" class="nav-item">
                <i class="fas fa-box"></i> Prodotti
            </a>
        </nav>

        <!-- Main Content -->
        <main class="admin-content">
            <!-- Vista Admin -->
            <div id="adminView">
                <!-- Stats Grid -->
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="card-title">Macchine Attive</div>
                        <div class="card-value" id="activeMachines">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="card-title">In Manutenzione</div>
                        <div class="card-value" id="maintenanceCount">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="card-title">Ricavi Oggi</div>
                        <div class="card-value" id="todayRevenue">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="card-title">Prodotti Erogati Oggi</div>
                        <div class="card-value" id="todayDispensed">-</div>
                    </div>
                </div>

                <!-- Charts Section -->
                <div class="dashboard-charts">
                    <!-- Revenue Chart -->
                    <div class="chart-container">
                        <div class="chart-header">
                            <h2>Andamento Ricavi</h2>
                            <div class="chart-controls">
                                <select id="chartPeriod">
                                    <option value="day">Oggi</option>
                                    <option value="week">Ultima Settimana</option>
                                    <option value="month" selected>Ultimo Mese</option>
                                </select>
                            </div>
                        </div>
                        <canvas id="revenueChart"></canvas>
                    </div>
                </div>

                <!-- Machine Status -->
                <div class="dashboard-section">
                    <h2>Stato Macchine</h2>
                    <div class="status-list" id="machineStatusList">
                        <!-- Machine status will be loaded dynamically -->
                    </div>
                </div>

                <!-- Active Alerts -->
                <div class="dashboard-section">
                    <h2>Allarmi Attivi</h2>
                    <div class="alerts-list" id="alertsList">
                        <!-- Alerts will be loaded dynamically -->
                    </div>
                </div>
            </div>

            <!-- Vista Ospite -->
            <div id="guestView" class="hidden">
                <h2>Accesso non autorizzato</h2>
                <p>Effettua il login per accedere alla dashboard.</p>
            </div>
        </main>
    </div>
</body>
</html>

================
File: src/main/resources/public/pages/admin/institutes.html
================
<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestione Istituti - Sistema Gestione Distributori</title>
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="../../css/admin.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <script src="../../js/common/utils.js" type="module"></script>
    <script src="../../js/common/authentication.js" type="module"></script>
    <script src="../../js/admin/institutes.js" type="module"></script>
</head>
<body>
    <div class="admin-container">
        <!-- Header -->
        <header class="admin-header">
            <div class="header-title">
                <h1>Gestione Istituti</h1>
            </div>
            <div class="header-actions">
                <span class="user-info">
                    <i class="fas fa-user"></i>
                    <span id="userName"></span>
                </span>
                <button class="btn-logout" onclick="auth.logout()">
                    <i class="fas fa-sign-out-alt"></i> Esci
                </button>
            </div>
        </header>

        <!-- Sidebar -->
        <nav class="admin-sidebar">
            <a href="dashboard.html" class="nav-item">
                <i class="fas fa-tachometer-alt"></i> Dashboard
            </a>
            <a href="machines.html" class="nav-item">
                <i class="fas fa-coffee"></i> Macchine
            </a>
            <a href="maintenance.html" class="nav-item">
                <i class="fas fa-tools"></i> Manutenzione
            </a>
            <a href="institutes.html" class="nav-item active">
                <i class="fas fa-building"></i> Istituti
            </a>
            <a href="reports.html" class="nav-item">
                <i class="fas fa-chart-bar"></i> Report
            </a>
            <a href="pods.html" class="nav-item">
                <i class="fas fa-box"></i> Prodotti
            </a>
        </nav>

        <!-- Main Content -->
        <main class="admin-content">
            <!-- Summary -->
            <div class="summary-grid" id="machinesSummary">
                <!-- Summary will be loaded dynamically -->
            </div>

            <!-- Filters and Actions -->
            <div class="content-header">
                <div class="search-box">
                    <input type="text" id="searchInstitute" placeholder="Cerca istituto...">
                    <i class="fas fa-search"></i>
                </div>
                <div class="action-buttons">
                    <button class="btn-secondary" onclick="instituteManager.handleImportCSV()">
                        <i class="fas fa-file-import"></i> Importa CSV
                    </button>
                    <button class="btn-secondary" onclick="instituteManager.handleExportCSV()">
                        <i class="fas fa-file-export"></i> Esporta CSV
                    </button>
                    <button class="btn-primary" onclick="instituteManager.openAddInstituteModal()">
                        <i class="fas fa-plus"></i> Nuovo Istituto
                    </button>
                </div>
            </div>

            <!-- Institutes List -->
            <div class="institutes-grid" id="institutesList">
                <!-- Institutes will be loaded dynamically -->
            </div>

            <!-- Pagination -->
            <div class="pagination" id="institutesPagination">
                <!-- Pagination will be generated dynamically -->
            </div>
        </main>
    </div>

    <!-- Add Institute Modal -->
    <div class="modal hidden" id="addInstituteModal">
        <div class="modal-content">
            <h2>Aggiungi Nuovo Istituto</h2>
            <form id="addInstituteForm">
                <div class="form-group">
                    <label for="name">Nome:</label>
                    <input type="text" id="name" name="name" required>
                </div>
                <div class="form-group">
                    <label for="address">Indirizzo:</label>
                    <input type="text" id="address" name="address" required>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="city">Città:</label>
                        <input type="text" id="city" name="city" required>
                    </div>
                    <div class="form-group">
                        <label for="province">Provincia:</label>
                        <input type="text" id="province" name="province" required maxlength="2">
                    </div>
                    <div class="form-group">
                        <label for="zipCode">CAP:</label>
                        <input type="text" id="zipCode" name="zipCode" required pattern="\\d{5}">
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="phone">Telefono:</label>
                        <input type="tel" id="phone" name="phone">
                    </div>
                    <div class="form-group">
                        <label for="email">Email:</label>
                        <input type="email" id="email" name="email">
                    </div>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn-secondary" onclick="instituteManager.closeModals()">
                        Annulla
                    </button>
                    <button type="submit" class="btn-primary">
                        Aggiungi
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Edit Institute Modal -->
    <div class="modal hidden" id="editInstituteModal">
        <div class="modal-content">
            <!-- Content will be loaded dynamically -->
        </div>
    </div>

    <!-- Hidden File Input for CSV Import -->
    <input type="file" id="csvFileInput" accept=".csv" style="display: none;" onchange="instituteManager.handleCSVFileSelect(event)">
</body>
</html>

================
File: src/main/resources/public/pages/admin/machines.html
================
<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestione Macchine</title>

    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="../../css/admin.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <script src="../../js/common/utils.js" type="module"></script>
    <script src="../../js/common/mqtt.js" type="module"></script>
    <script src="../../js/common/authentication.js" type="module"></script>
    <script src="../../js/admin/machines.js" type="module"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js"></script>
</head>
<body>
    <div class="admin-container">
        <!-- Header -->
        <header class="admin-header">
            <div class="header-title">
                <h1>Gestione Macchine</h1>
            </div>
            <div class="header-actions">
                <span class="user-info">
                    <i class="fas fa-user"></i>
                    <span id="userName"></span>
                </span>
                <button class="btn-logout" onclick="auth.logout()">
                    <i class="fas fa-sign-out-alt"></i> Esci
                </button>
            </div>
        </header>

        <!-- Sidebar -->
        <nav class="admin-sidebar">
            <a href="dashboard.html" class="nav-item">
                <i class="fas fa-tachometer-alt"></i> Dashboard
            </a>
            <a href="machines.html" class="nav-item active">
                <i class="fas fa-coffee"></i> Macchine
            </a>
            <a href="maintenance.html" class="nav-item">
                <i class="fas fa-tools"></i> Manutenzione
            </a>
            <a href="institutes.html" class="nav-item">
                <i class="fas fa-building"></i> Istituti
            </a>
            <a href="reports.html" class="nav-item">
                <i class="fas fa-chart-bar"></i> Report
            </a>
            <a href="pods.html" class="nav-item">
                <i class="fas fa-box"></i> Prodotti
            </a>
        </nav>

        <!-- Main Content -->
        <main class="admin-content">
            <!-- Filters and Actions -->
            <div class="content-header">
                <div class="filters">
                    <div class="search-box">
                        <input type="text" id="searchMachine" placeholder="Cerca macchina...">
                        <i class="fas fa-search"></i>
                    </div>
                    <select id="filterInstitute">
                        <option value="">Tutti gli istituti</option>
                    </select>
                    <select id="filterStatus">
                        <option value="">Tutti gli stati</option>
                        <option value="1">Attive</option>
                        <option value="2">In Manutenzione</option>
                        <option value="3">Fuori Servizio</option>
                    </select>
                </div>
                <button class="btn-primary" onclick="machineManager.openAddMachineModal()">
                    <i class="fas fa-plus"></i> Nuova Macchina
                </button>
            </div>

            <!-- Machines List -->
            <div class="machines-grid" id="machinesList">
                <!-- Machines will be loaded dynamically -->
            </div>

            <!-- Pagination -->
            <div class="pagination" id="machinesPagination">
                <!-- Pagination will be generated dynamically -->
            </div>
        </main>
    </div>

    <!-- Add Machine Modal -->
    <div class="modal hidden" id="addMachineModal">
        <div class="modal-content">
            <h2>Aggiungi Nuova Macchina</h2>
            <form id="addMachineForm">
                <div class="form-group">
                    <label for="institute">Istituto:</label>
                    <select id="institute" name="institute" required>
                        <!-- Institutes will be loaded dynamically -->
                    </select>
                </div>
                <div class="form-group">
                    <label for="maxCash">Capacità Massima Cassa (€):</label>
                    <input type="number" id="maxCash" name="maxCash" min="0" step="0.01" required>
                </div>
                <div class="form-group">
                    <label for="podCapacity">Capacità Cialde:</label>
                    <input type="number" id="podCapacity" name="podCapacity" min="1" required>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn-secondary" onclick="machineManager.closeModals()">
                        Annulla
                    </button>
                    <button type="submit" class="btn-primary">
                        Aggiungi
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Edit Machine Modal -->
    <div class="modal hidden" id="editMachineModal">
        <div class="modal-content">
            <!-- Content will be loaded dynamically -->
        </div>
    </div>
</body>
</html>

================
File: src/main/resources/public/pages/admin/maintenance.html
================
<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestione Manutenzioni - Sistema Gestione Distributori</title>

    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="../../css/admin.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <script src="../../js/common/utils.js" type="module"></script>
    <script src="../../js/common/mqtt.js" type="module"></script>
    <script src="../../js/common/authentication.js" type="module"></script>
    <script src="../../js/admin/maintenance.js" type="module"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js"></script>
</head>
<body>
    <div class="admin-container">
        <!-- Header -->
        <header class="admin-header">
            <div class="header-title">
                <h1>Gestione Manutenzioni</h1>
            </div>
            <div class="header-actions">
                <span class="user-info">
                    <i class="fas fa-user"></i>
                    <span id="userName"></span>
                </span>
                <button class="btn-logout" onclick="auth.logout()">
                    <i class="fas fa-sign-out-alt"></i> Esci
                </button>
            </div>
        </header>

        <!-- Sidebar -->
        <nav class="admin-sidebar">
            <a href="dashboard.html" class="nav-item">
                <i class="fas fa-tachometer-alt"></i> Dashboard
            </a>
            <a href="machines.html" class="nav-item">
                <i class="fas fa-coffee"></i> Macchine
            </a>
            <a href="maintenance.html" class="nav-item active">
                <i class="fas fa-tools"></i> Manutenzione
            </a>
            <a href="institutes.html" class="nav-item">
                <i class="fas fa-building"></i> Istituti
            </a>
            <a href="reports.html" class="nav-item">
                <i class="fas fa-chart-bar"></i> Report
            </a>
            <a href="pods.html" class="nav-item">
                <i class="fas fa-box"></i> Prodotti
            </a>
        </nav>

        <!-- Main Content -->
        <main class="admin-content">
            <!-- Filters and Actions -->
            <div class="content-header">
                <div class="filters" id="reportFilters">
                    <div class="search-box">
                        <input type="text" id="searchMaintenance" placeholder="Cerca manutenzione...">
                        <i class="fas fa-search"></i>
                    </div>
                    <select id="filterStatus">
                        <option value="">Tutti gli stati</option>
                        <option value="in_attesa">In Attesa</option>
                        <option value="assegnata">Assegnata</option>
                        <option value="in_corso">In Corso</option>
                        <option value="completata">Completata</option>
                    </select>
                    <select id="filterTechnician">
                        <option value="">Tutti i tecnici</option>
                    </select>
                    <select id="filterPriority">
                        <option value="">Tutte le priorità</option>
                        <option value="alta">Alta</option>
                        <option value="media">Media</option>
                        <option value="bassa">Bassa</option>
                    </select>
                </div>
            </div>

            <!-- Active Maintenance Requests -->
            <div class="section">
                <h2>Richieste di Manutenzione Attive</h2>
                <div class="maintenance-grid" id="maintenanceList">
                    <!-- Maintenance requests will be loaded dynamically -->
                </div>
            </div>

            <!-- Completed Maintenance -->
            <div class="section">
                <h2>Manutenzioni Completate</h2>
                <div class="completed-maintenance" id="completedList">
                    <!-- Completed maintenance will be loaded dynamically -->
                </div>
            </div>

            <!-- Pagination -->
            <div class="pagination" id="maintenancePagination">
                <!-- Pagination will be generated dynamically -->
            </div>
        </main>
    </div>

    <!-- Assign Technician Modal -->
    <div class="modal hidden" id="assignTechnicianModal">
        <div class="modal-content">
            <h2>Assegna Tecnico</h2>
            <form id="assignTechnicianForm">
                <div class="form-group">
                    <label for="technicianId">Tecnico:</label>
                    <select id="technicianId" name="technicianId" required>
                        <!-- Technicians will be loaded dynamically -->
                    </select>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn-secondary" onclick="maintenanceManager.closeModals()">
                        Annulla
                    </button>
                    <button type="submit" class="btn-primary">
                        Assegna
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Complete Maintenance Modal -->
    <div class="modal hidden" id="completeMaintenanceModal">
        <div class="modal-content">
            <h2>Completa Manutenzione</h2>
            <form id="completeMaintenanceForm">
                <div class="form-group">
                    <label for="notes">Note:</label>
                    <textarea id="notes" name="notes" required></textarea>
                </div>
                <div class="form-group">
                    <label for="partsReplaced">Parti Sostituite:</label>
                    <textarea id="partsReplaced" name="partsReplaced"></textarea>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn-secondary" onclick="maintenanceManager.closeModals()">
                        Annulla
                    </button>
                    <button type="submit" class="btn-primary">
                        Completa
                    </button>
                </div>
            </form>
        </div>
    </div>
</body>
</html>

================
File: src/main/resources/public/pages/admin/MonitorMacchine.html
================
<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monitoraggio IoT - Distributori</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <!-- MQTT.js client -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mqtt/4.3.7/mqtt.min.js"></script>
</head>
<body class="bg-gray-100">
    <!-- Header -->
    <header class="bg-blue-600 text-white p-4">
        <div class="container mx-auto">
            <h1 class="text-2xl font-bold">Monitoraggio IoT Distributori</h1>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container mx-auto p-4">
        <!-- Status Bar -->
        <div class="bg-white rounded-lg shadow p-4 mb-6">
            <div class="flex justify-between items-center">
                <div class="flex items-center">
                    <i id="mqttStatus" class="fas fa-signal mr-2 text-red-500"></i>
                    <span id="mqttStatusText">MQTT: Disconnesso</span>
                </div>
                <div class="flex space-x-6">
                    <div class="flex items-center">
                        <i class="fas fa-check-circle text-green-500 mr-2"></i>
                        <span>Attive: <span id="activeCount">0</span></span>
                    </div>
                    <div class="flex items-center">
                        <i class="fas fa-wrench text-yellow-500 mr-2"></i>
                        <span>In Manutenzione: <span id="maintenanceCount">0</span></span>
                    </div>
                    <div class="flex items-center">
                        <i class="fas fa-exclamation-circle text-red-500 mr-2"></i>
                        <span>Errori: <span id="errorCount">0</span></span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Machines Grid -->
        <div id="machinesGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
            <!-- Populated by JavaScript -->
        </div>

        <!-- Alerts Section -->
        <div class="bg-white rounded-lg shadow p-4">
            <h2 class="text-xl font-bold mb-4">Ultimi Allarmi</h2>
            <div id="alertsList" class="space-y-4">
                <!-- Populated by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const MQTT_CONFIG = {
            host: 'localhost',
            port: 8883,
            protocol: 'wss',
            path: '/mqtt',
            username: '20019309',
            password: 'Pissir2024!'
        };

        // State
        let machines = {};
        let alerts = [];
        let client = null;

        // Initialize MQTT Connection
        function initMQTT() {
            const clientId = 'dashboard_' + Math.random().toString(16).substring(2, 8);
            const connectUrl = `${MQTT_CONFIG.protocol}://${MQTT_CONFIG.host}:${MQTT_CONFIG.port}${MQTT_CONFIG.path}`;

            client = mqtt.connect(connectUrl, {
                clientId,
                clean: true,
                username: MQTT_CONFIG.username,
                password: MQTT_CONFIG.password,
                rejectUnauthorized: false
            });

            client.on('connect', onConnect);
            client.on('message', onMessage);
            client.on('error', onError);
            client.on('close', onClose);
        }

        // MQTT Event Handlers
        function onConnect() {
            updateMQTTStatus('connected');
            
            // Subscribe to topics
            client.subscribe('macchine/+/stato');
            client.subscribe('macchine/+/allarmi');
            client.subscribe('macchine/+/manutenzione');
            
            console.log('Connected to MQTT broker');
        }

        function onMessage(topic, message) {
            const payload = JSON.parse(message.toString());
            const topicParts = topic.split('/');
            const machineId = topicParts[1];

            if (topic.endsWith('/stato')) {
                updateMachineStatus(machineId, payload);
            } else if (topic.endsWith('/allarmi')) {
                handleAlert(machineId, payload);
            }
        }

        function onError(error) {
            console.error('MQTT Error:', error);
            updateMQTTStatus('error');
        }

        function onClose() {
            updateMQTTStatus('disconnected');
            // Attempt to reconnect after 5 seconds
            setTimeout(initMQTT, 5000);
        }

        // UI Update Functions
        function updateMQTTStatus(status) {
            const statusIcon = document.getElementById('mqttStatus');
            const statusText = document.getElementById('mqttStatusText');

            switch(status) {
                case 'connected':
                    statusIcon.className = 'fas fa-signal mr-2 text-green-500';
                    statusText.textContent = 'MQTT: Connesso';
                    break;
                case 'disconnected':
                    statusIcon.className = 'fas fa-signal mr-2 text-red-500';
                    statusText.textContent = 'MQTT: Disconnesso';
                    break;
                case 'error':
                    statusIcon.className = 'fas fa-exclamation-triangle mr-2 text-red-500';
                    statusText.textContent = 'MQTT: Errore';
                    break;
            }
        }

        function updateMachineStatus(machineId, status) {
            machines[machineId] = status;
            updateMachineCard(machineId);
            updateStatusCounts();
        }

        function updateMachineCard(machineId) {
            const machine = machines[machineId];
            const existingCard = document.getElementById(`machine-${machineId}`);
            
            const cardHTML = `
                <div class="bg-white p-4 rounded-lg shadow">
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-lg font-semibold">Macchina #${machineId}</h3>
                        <span class="px-2 py-1 rounded-full text-sm ${getStatusClass(machine.status)}">
                            ${getStatusText(machine.status)}
                        </span>
                    </div>
                    <div class="space-y-2">
                        <p>Ultima attività: ${new Date(machine.lastUpdate).toLocaleString()}</p>
                        <div class="flex items-center">
                            <div class="w-full bg-gray-200 rounded-full h-2.5">
                                <div class="bg-blue-600 h-2.5 rounded-full" style="width: ${machine.podLevel}%"></div>
                            </div>
                            <span class="ml-2">Cialde: ${machine.podLevel}%</span>
                        </div>
                        <p>Cassa: €${machine.cashLevel.toFixed(2)}</p>
                    </div>
                </div>
            `;

            if (existingCard) {
                existingCard.innerHTML = cardHTML;
            } else {
                const machinesGrid = document.getElementById('machinesGrid');
                const newCard = document.createElement('div');
                newCard.id = `machine-${machineId}`;
                newCard.innerHTML = cardHTML;
                machinesGrid.appendChild(newCard);
            }
        }

        function handleAlert(machineId, alert) {
            alerts.unshift({...alert, machineId});
            alerts = alerts.slice(0, 10); // Keep only last 10 alerts
            updateAlertsList();

            // Desktop notification
            if (Notification.permission === 'granted') {
                new Notification(`Allarme Macchina #${machineId}`, {
                    body: alert.message,
                    icon: '/alert-icon.png'
                });
            }
        }

        function updateAlertsList() {
            const alertsList = document.getElementById('alertsList');
            alertsList.innerHTML = alerts.map(alert => `
                <div class="border-l-4 ${getAlertClass(alert.severity)} p-4">
                    <div class="flex items-center">
                        <i class="fas fa-exclamation-triangle mr-2"></i>
                        <div class="flex-1">
                            <p class="font-bold">Macchina #${alert.machineId} - ${alert.type}</p>
                            <p class="text-sm">${alert.message}</p>
                            <p class="text-xs text-gray-500 mt-1">
                                ${new Date(alert.timestamp).toLocaleString()}
                            </p>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function updateStatusCounts() {
            const counts = Object.values(machines).reduce((acc, machine) => {
                acc[machine.status]++;
                return acc;
            }, { active: 0, maintenance: 0, error: 0 });

            document.getElementById('activeCount').textContent = counts.active;
            document.getElementById('maintenanceCount').textContent = counts.maintenance;
            document.getElementById('errorCount').textContent = counts.error;
        }

        // Utility Functions
        function getStatusClass(status) {
            switch(status) {
                case 'active': return 'bg-green-100 text-green-800';
                case 'maintenance': return 'bg-yellow-100 text-yellow-800';
                case 'error': return 'bg-red-100 text-red-800';
                default: return 'bg-gray-100 text-gray-800';
            }
        }

        function getStatusText(status) {
            switch(status) {
                case 'active': return 'Attiva';
                case 'maintenance': return 'In Manutenzione';
                case 'error': return 'Errore';
                default: return 'Sconosciuto';
            }
        }

        function getAlertClass(severity) {
            switch(severity) {
                case 'error': return 'border-red-500 bg-red-50';
                case 'warning': return 'border-yellow-500 bg-yellow-50';
                case 'info': return 'border-blue-500 bg-blue-50';
                default: return 'border-gray-500 bg-gray-50';
            }
        }

        // Request desktop notification permission
        function requestNotificationPermission() {
            if (Notification.permission !== 'granted') {
                Notification.requestPermission();
            }
        }

        // Initialize application
        document.addEventListener('DOMContentLoaded', () => {
            initMQTT();
            requestNotificationPermission();
        });
    </script>
</body>
</html>

================
File: src/main/resources/public/pages/admin/pods.html
================
<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestione Cialde e Prodotti - Sistema Gestione Distributori</title>
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="stylesheet" href="/css/admin.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js"></script>
</head>
<body>
    <div class="admin-container">
        <!-- Header -->
        <header class="admin-header">
            <div class="header-title">
                <h1>Gestione Cialde e Prodotti</h1>
            </div>
            <div class="header-actions">
                <span class="user-info">
                    <i class="fas fa-user"></i>
                    <span id="userName"></span>
                </span>
                <button class="btn-logout" onclick="auth.logout()">
                    <i class="fas fa-sign-out-alt"></i> Esci
                </button>
            </div>
        </header>

        <!-- Sidebar -->
        <nav class="admin-sidebar">
            <a href="/pages/admin/dashboard.html" class="nav-item">
                <i class="fas fa-tachometer-alt"></i> Dashboard
            </a>
            <a href="/pages/admin/machines.html" class="nav-item">
                <i class="fas fa-coffee"></i> Macchine
            </a>
            <a href="/pages/admin/maintenance.html" class="nav-item">
                <i class="fas fa-tools"></i> Manutenzione
            </a>
            <a href="/pages/admin/institutes.html" class="nav-item">
                <i class="fas fa-building"></i> Istituti
            </a>
            <a href="/pages/admin/reports.html" class="nav-item">
                <i class="fas fa-chart-bar"></i> Report
            </a>
            <a href="/pages/admin/pods.html" class="nav-item active">
                <i class="fas fa-box"></i> Prodotti
            </a>
        </nav>

        <!-- Main Content -->
        <main class="admin-content">
            <!-- Tabs -->
            <div class="content-tabs">
                <button class="tab-button active" data-tab="pods">
                    <i class="fas fa-box"></i> Cialde
                </button>
                <button class="tab-button" data-tab="products">
                    <i class="fas fa-coffee"></i> Prodotti
                </button>
            </div>

            <!-- Cialde Tab -->
            <div class="tab-content active" id="podsTab">
                <!-- Filtri e Azioni -->
                <div class="content-header">
                    <div class="filters">
                        <div class="search-box">
                            <input type="text" id="searchPod" placeholder="Cerca cialda...">
                            <i class="fas fa-search"></i>
                        </div>
                        <select id="filterType">
                            <option value="">Tutti i tipi</option>
                            <option value="coffee">Caffè</option>
                            <option value="tea">Tè</option>
                            <option value="chocolate">Cioccolata</option>
                            <option value="milk">Latte</option>
                        </select>
                        <select id="sortSelect">
                            <option value="name-asc">Nome (A-Z)</option>
                            <option value="name-desc">Nome (Z-A)</option>
                            <option value="stock-asc">Scorte (Min-Max)</option>
                            <option value="stock-desc">Scorte (Max-Min)</option>
                            <option value="price-asc">Prezzo (Min-Max)</option>
                            <option value="price-desc">Prezzo (Max-Min)</option>
                        </select>
                    </div>
                    <button class="btn-primary" onclick="podManager.openAddPodModal()">
                        <i class="fas fa-plus"></i> Nuova Cialda
                    </button>
                </div>

                <!-- Impostazioni Scorte -->
                <div class="stock-settings">
                    <label for="stockWarningLevel">Soglia avviso scorte (%):</label>
                    <input type="number" id="stockWarningLevel" min="1" max="100" value="20">
                </div>

                <!-- Lista Cialde -->
                <div class="pods-grid" id="podsList">
                    <!-- Le cialde verranno caricate dinamicamente -->
                </div>
            </div>

            <!-- Prodotti Tab -->
            <div class="tab-content" id="productsTab">
                <!-- Lista Prodotti -->
                <div class="content-header">
                    <button class="btn-primary" onclick="podManager.openAddProductModal()">
                        <i class="fas fa-plus"></i> Nuovo Prodotto
                    </button>
                </div>

                <div class="products-grid" id="productsGrid">
                    <!-- I prodotti verranno caricati dinamicamente -->
                </div>
            </div>

            <!-- Modali -->
            <!-- Modal Aggiungi Cialda -->
            <div class="modal hidden" id="addPodModal">
                <div class="modal-content">
                    <h2>Aggiungi Nuova Cialda</h2>
                    <form id="addPodForm">
                        <div class="form-group">
                            <label for="name">Nome:</label>
                            <input type="text" id="name" name="name" required>
                        </div>
                        <div class="form-group">
                            <label for="type">Tipo:</label>
                            <select id="type" name="type" required>
                                <option value="coffee">Caffè</option>
                                <option value="tea">Tè</option>
                                <option value="chocolate">Cioccolata</option>
                                <option value="milk">Latte</option>
                            </select>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label for="stock">Scorta iniziale:</label>
                                <input type="number" id="stock" name="stock" min="0" required>
                            </div>
                            <div class="form-group">
                                <label for="minStock">Scorta minima:</label>
                                <input type="number" id="minStock" name="minStock" min="0" required>
                            </div>
                            <div class="form-group">
                                <label for="maxStock">Scorta massima:</label>
                                <input type="number" id="maxStock" name="maxStock" min="0" required>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="price">Prezzo unitario (€):</label>
                            <input type="number" id="price" name="price" min="0" step="0.01" required>
                        </div>
                        <div class="form-actions">
                            <button type="button" class="btn-secondary" onclick="podManager.closeModals()">
                                Annulla
                            </button>
                            <button type="submit" class="btn-primary">
                                Aggiungi
                            </button>
                        </div>
                    </form>
                </div>
            </div>

            <!-- Modal Aggiungi Prodotto -->
            <div class="modal hidden" id="addProductModal">
                <div class="modal-content">
                    <h2>Aggiungi Nuovo Prodotto</h2>
                    <form id="addProductForm">
                        <div class="form-group">
                            <label for="productName">Nome:</label>
                            <input type="text" id="productName" name="name" required>
                        </div>
                        <div class="form-group">
                            <label for="description">Descrizione:</label>
                            <textarea id="description" name="description" required></textarea>
                        </div>
                        <div class="form-group">
                            <label for="productPrice">Prezzo (€):</label>
                            <input type="number" id="productPrice" name="price" min="0" step="0.01" required>
                        </div>
                        <div class="form-group">
                            <label>Composizione:</label>
                            <div id="podsComposition">
                                <!-- Le opzioni delle cialde verranno caricate dinamicamente -->
                            </div>
                            <button type="button" class="btn-secondary" onclick="podManager.addPodToComposition()">
                                <i class="fas fa-plus"></i> Aggiungi Cialda
                            </button>
                        </div>
                        <div class="form-actions">
                            <button type="button" class="btn-secondary" onclick="podManager.closeModals()">
                                Annulla
                            </button>
                            <button type="submit" class="btn-primary">
                                Aggiungi
                            </button>
                        </div>
                    </form>
                </div>
            </div>

            <!-- Modal Modifica -->
            <div class="modal hidden" id="editPodModal">
                <div class="modal-content">
                    <!-- Il contenuto verrà caricato dinamicamente -->
                </div>
            </div>

            <!-- Modal Modifica Prodotto -->
            <div class="modal hidden" id="editProductModal">
                <div class="modal-content">
                    <!-- Il contenuto verrà caricato dinamicamente -->
                </div>
            </div>
        </main>
    </div>

    <script src="/js/common/utils.js" type="module"></script>
    <script src="/js/common/mqtt.js" type="module"></script>
    <script src="/js/common/authentication.js" type="module"></script>
    <script src="/js/admin/pods.js" type="module"></script>
</body>
</html>

================
File: src/main/resources/public/pages/admin/reports.html
================
<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Report e Statistiche - Sistema Gestione Distributori</title>
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="../../css/admin.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/daterangepicker/3.1.0/daterangepicker.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/daterangepicker/3.1.0/daterangepicker.min.js"></script>
    <script src="../../js/common/utils.js" type="module"></script>
    <script src="../../js/common/authentication.js" type="module"></script>
    <script src="../../js/admin/reports.js" type="module"></script>
</head>
<body>
    <div class="admin-container">
        <!-- Header -->
        <header class="admin-header">
            <div class="header-title">
                <h1>Report e Statistiche</h1>
            </div>
            <div class="header-actions">
                <span class="user-info">
                    <i class="fas fa-user"></i>
                    <span id="userName"></span>
                </span>
                <button class="btn-logout" onclick="auth.logout()">
                    <i class="fas fa-sign-out-alt"></i> Esci
                </button>
            </div>
        </header>

        <!-- Sidebar
        <nav class="admin-sidebar">
            <a href="dashboard.html" class="nav-item">
                <i class="fas fa-tachometer-alt"></i> Dashboard
            </a>
            <a href="machines.html" class="nav-item">
                <i class="fas fa-coffee"></i> Macchine
            </a>
            <a href="maintenance.html" class="nav-item">
                <i class="fas fa-tools"></i> Manutenzione
            </a>
            <a href="institutes.html" class="nav-item">
                <i class="fas fa-building"></i> Istituti
            </a>
            <a href="reports.html" class="nav-item active">
                <i class="fas fa-chart-bar"></i> Report
            </a>
            <a href="pods.html" class="nav-item">
                <i class="fas fa-box"></i> Prodotti
            </a>
        </nav>-->

        <!-- Main Content -->
        <main class="admin-content">
            <!-- Filters -->
            <div class="report-filters" id="reportFilters">
                <div class="filter-group">
                    <label for="dateRangeFilter">Periodo:</label>
                    <input type="text" id="dateRangeFilter" class="date-range-picker">
                </div>
                <div class="filter-group">
                    <label for="instituteFilter">Istituto:</label>
                    <select id="instituteFilter">
                        <option value="all">Tutti gli istituti</option>
                    </select>
                </div>
                <div class="report-actions">
                    <button class="btn-secondary" id="exportButton">
                        <i class="fas fa-file-export"></i> Esporta PDF
                    </button>
                    <button class="btn-secondary" id="printButton">
                        <i class="fas fa-print"></i> Stampa
                    </button>
                </div>
            </div>

            <!-- Statistics Grid -->
            <div class="stats-grid" id="statsGrid">
                <!-- Statistics will be loaded dynamically -->
            </div>

            <!-- Charts Section -->
            <div class="charts-section">
                <!-- Revenue Chart -->
                <div class="chart-container">
                    <div class="chart-header">
                        <h2>Andamento Ricavi</h2>
                    </div>
                    <canvas id="revenueChart"></canvas>
                </div>

                <!-- Products Chart -->
                <div class="chart-container">
                    <div class="chart-header">
                        <h2>Vendite per Prodotto</h2>
                    </div>
                    <canvas id="productChart"></canvas>
                </div>

                <!-- Maintenance Chart -->
                <div class="chart-container">
                    <div class="chart-header">
                        <h2>Tipologie Manutenzioni</h2>
                    </div>
                    <canvas id="maintenanceChart"></canvas>
                </div>
            </div>

            <!-- Detailed Reports -->
            <div class="report-sections">
                <!-- Vendite per Prodotto -->
                <div class="report-section">
                    <h2>Dettaglio Vendite per Prodotto</h2>
                    <table class="report-table">
                        <thead>
                            <tr>
                                <th>Prodotto</th>
                                <th>Quantità</th>
                                <th>Ricavo</th>
                                <th>% sul Totale</th>
                            </tr>
                        </thead>
                        <tbody id="productsSalesTable">
                            <!-- Data will be loaded dynamically -->
                        </tbody>
                    </table>
                </div>

                <!-- Manutenzioni per Macchina -->
                <div class="report-section">
                    <h2>Dettaglio Manutenzioni per Macchina</h2>
                    <table class="report-table">
                        <thead>
                            <tr>
                                <th>Macchina</th>
                                <th>Interventi</th>
                                <th>Tempo Medio</th>
                                <th>Costo Totale</th>
                            </tr>
                        </thead>
                        <tbody id="maintenanceStatsTable">
                            <!-- Data will be loaded dynamically -->
                        </tbody>
                    </table>
                </div>

                <!-- Performance Istituti -->
                <div class="report-section">
                    <h2>Performance Istituti</h2>
                    <table class="report-table">
                        <thead>
                            <tr>
                                <th>Istituto</th>
                                <th>Macchine Attive</th>
                                <th>Ricavi</th>
                                <th>Manutenzioni</th>
                            </tr>
                        </thead>
                        <tbody id="instituteStatsTable">
                            <!-- Data will be loaded dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>
        </main>
    </div>
</body>
</html>

================
File: src/main/resources/public/pages/admin/reports1.html
================
<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Report e statistiche del sistema di gestione distributori">
    <title>Report e Statistiche</title>
    
    <!-- CSS -->
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="../../css/admin.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/daterangepicker/3.1.0/daterangepicker.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <!-- Flatpickr per la selezione date -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/material_blue.css">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/it.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/daterangepicker/3.1.0/daterangepicker.min.js"></script>
    <script src="../../js/common/utils.js" type="module"></script>
    <script src="../../js/common/authentication.js" type="module"></script>
    <script src="../../js/admin/reports.js" type="module"></script>

</head>
<body class="bg-gradient">
    <!-- Header -->
    <nav class="top-nav">
        <div class="nav-content container">
            <div class="nav-brand">
                <span class="brand-text">Report e Statistiche</span>
            </div>
            <div class="nav-actions">
                <button id="printButton" class="btn btn-secondary" title="Stampa Report">
                    <i class="fas fa-print"></i>
                    <span>Stampa</span>
                </button>
                <button id="exportButton" class="btn btn-primary" title="Esporta in PDF">
                    <i class="fas fa-file-pdf"></i>
                    <span>Esporta PDF</span>
                </button>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="container mt-4">
        <!-- Filtri Report -->
        <section id="reportFilters" class="filters-section card">
            <div class="card-body">
                <div class="filters-grid">
                    <!-- Date Range -->
                    <div class="filter-group">
                        <label for="dateRangeStart">Data Inizio</label>
                        <input type="date" id="dateRangeStart" class="form-input">
                    </div>
                    <div class="filter-group">
                        <label for="dateRangeEnd">Data Fine</label>
                        <input type="date" id="dateRangeEnd" class="form-input">
                    </div>
                    
                    <!-- Istituto -->
                    <div class="filter-group">
                        <label for="instituteFilter">Istituto</label>
                        <select id="instituteFilter" class="form-select">
                            <option value="all">Tutti gli istituti</option>
                        </select>
                    </div>
                </div>
            </div>
        </section>

        <!-- Statistiche Rapide -->
        <section id="statsGrid" class="stats-section mt-4"></section>

        <!-- Grafici -->
        <div class="charts-grid mt-4">
            <!-- Grafico Ricavi -->
            <section class="chart-card card">
                <div class="card-header">
                    <h3>Andamento Ricavi</h3>
                </div>
                <div class="card-body">
                    <canvas id="revenueChart" height="300"></canvas>
                </div>
            </section>

            <!-- Grafico Prodotti -->
            <section class="chart-card card">
                <div class="card-header">
                    <h3>Vendite per Prodotto</h3>
                </div>
                <div class="card-body">
                    <canvas id="productChart" height="300"></canvas>
                </div>
            </section>

            <!-- Grafico Manutenzioni -->
            <section class="chart-card card">
                <div class="card-header">
                    <h3>Manutenzioni</h3>
                </div>
                <div class="card-body">
                    <canvas id="maintenanceChart" height="300"></canvas>
                </div>
            </section>
        </div>

        <!-- Dettagli Aggiuntivi -->
        <section class="details-section mt-4">
            <!-- Tabella Manutenzioni per Macchina -->
            <div class="card">
                <div class="card-header">
                    <h3>Dettaglio Manutenzioni per Macchina</h3>
                </div>
                <div class="card-body">
                    <div class="table-responsive">
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>Macchina</th>
                                    <th>Interventi</th>
                                    <th>Tempo Medio (ore)</th>
                                    <th>Efficienza</th>
                                </tr>
                            </thead>
                            <tbody id="maintenanceTableBody">
                                <!-- Popolato dinamicamente -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay hidden">
        <div class="spinner"></div>
        <p>Caricamento in corso...</p>
    </div>

    <!-- Toast Container -->
    <div id="toastContainer" class="toast-container"></div>

    <!-- Stili Aggiuntivi -->
    <style>
        .filters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5rem;
        }

        .chart-card {
            background: white;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            transition: transform 0.2s ease;
        }

        .chart-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .card-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .card-body {
            padding: 1.5rem;
        }

        .table-responsive {
            overflow-x: auto;
            margin: 0 -1.5rem;
            padding: 0 1.5rem;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
        }

        .table th,
        .table td {
            padding: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            text-align: left;
        }

        .table th {
            background-color: var(--background-alt);
            font-weight: 500;
        }

        @media print {
            .top-nav,
            .filters-section,
            #loadingOverlay,
            #toastContainer {
                display: none !important;
            }

            .container {
                max-width: none;
                padding: 0;
                margin: 0;
            }

            .chart-card {
                break-inside: avoid;
                page-break-inside: avoid;
            }
        }

        @media (max-width: 768px) {
            .charts-grid {
                grid-template-columns: 1fr;
            }

            .nav-actions {
                display: none;
            }

            .card-header {
                padding: 1rem;
            }

            .card-body {
                padding: 1rem;
            }
        }
    </style>
</body>
</html>

================
File: src/main/resources/public/pages/client/beverageInterface.html
================
<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Selezione Bevande</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js"></script>
    <!-- Includi Axios -->
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

    <style>
        .status-indicator {
            padding: 0.5rem;
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-active {
            background-color: #10B981;
            color: white;
        }

        .status-maintenance {
            background-color: #F59E0B;
            color: white;
        }

        .status-error {
            background-color: #EF4444;
            color: white;
        }

        .status-unknown {
            background-color: #6B7280;
            color: white;
        }

        .beverage-card {
            border: 2px solid #E5E7EB;
            border-radius: 0.5rem;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .beverage-card:hover {
            border-color: #3B82F6;
        }

        .beverage-card.selected {
            border-color: #3B82F6;
            background-color: #EFF6FF;
        }

        .beverage-card.unavailable {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .coin-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            background-color: #F3F4F6;
            transition: all 0.2s;
        }

        .coin-btn:hover {
            background-color: #E5E7EB;
        }

        .sugar-btn {
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            background-color: #F3F4F6;
        }

        .sugar-btn.active {
            background-color: #3B82F6;
            color: white;
        }

        .hidden {
            display: none;
        }
    </style>
</head>

<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <!-- Header -->
        <header class="mb-8">
            <div class="flex justify-between items-center">
                <h1 class="text-2xl font-bold">Distributore Automatico <span id="machineNumber" class="text-blue-600"></span></h1>
                <!-- Indicatore di stato della macchina -->
                <div id="statusIndicator" class="status-indicator status-unknown">
                    <div class="w-3 h-3 rounded-full bg-current"></div>
                    <span class="status-text">Stato Sconosciuto</span>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
            <!-- Bevande -->
            <div class="md:col-span-2">
                <!-- Categorie -->
                <div id="categoriesTabs" class="flex gap-4 mb-6">
                    <button class="tab-button px-4 py-2 rounded-lg bg-blue-600 text-white" data-category="all">Tutte</button>
                    <button class="tab-button px-4 py-2 rounded-lg bg-gray-200" data-category="coffee">Caffè</button>
                    <button class="tab-button px-4 py-2 rounded-lg bg-gray-200" data-category="hot">Bevande Calde</button>
                </div>

                <!-- Lista Bevande -->
                <div id="beveragesList" class="grid grid-cols-2 md:grid-cols-3 gap-4">
                    <!-- Bevande dinamiche qui -->
                </div>
            </div>

            <!-- Pannello Controllo -->
            <div class="bg-white rounded-lg p-6 shadow-lg">
                <!-- Credito -->
                <div class="mb-8">
                    <h2 class="text-xl font-semibold mb-4">Credito Inserito</h2>
                    <div class="text-3xl font-bold text-blue-600 mb-4">
                        € <span id="currentCredit">0.00</span>
                    </div>

                    <!-- Monete -->
                    <div class="grid grid-cols-3 gap-4">
                        <button class="coin-btn" data-value="0.10">€0.10</button>
                        <button class="coin-btn" data-value="0.20">€0.20</button>
                        <button class="coin-btn" data-value="0.50">€0.50</button>
                        <button class="coin-btn" data-value="1.00">€1.00</button>
                        <button class="coin-btn" data-value="2.00">€2.00</button>
                    </div>
                </div>

                <!-- Prodotto Selezionato -->
                <div id="customizationOptions" class="mb-8 hidden">
                    <!-- Controllo Zucchero -->
                    <div id="sugarControl" class="flex flex-col gap-2">
                        <label class="text-sm text-gray-600">Zucchero</label>
                        <div class="flex gap-2">
                            <button class="sugar-btn" data-level="0">No</button>
                            <button class="sugar-btn" data-level="1">Poco</button>
                            <button class="sugar-btn active" data-level="2">Medio</button>
                            <button class="sugar-btn" data-level="3">Molto</button>
                        </div>
                    </div>
                </div>

                <!-- Pulsanti Azione -->
                <div class="flex gap-4">
                    <button id="dispenseButton" class="flex-1 px-6 py-3 bg-blue-600 text-white rounded-lg disabled:opacity-50 disabled:cursor-not-allowed">Eroga</button>
                    <button id="returnCreditButton" class="px-6 py-3 bg-gray-200 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed">Resto</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Overlay Erogazione -->
    <div id="dispensingOverlay" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center">
        <div class="bg-white p-8 rounded-lg text-center">
            <h3 class="text-xl font-bold mb-4">Erogazione in Corso</h3>
            <p id="dispensingStatus" class="text-gray-600">Preparazione bevanda...</p>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center">
        <div class="bg-white p-8 rounded-lg">
            <div class="animate-spin rounded-full h-12 w-12 border-4 border-blue-600 border-t-transparent"></div>
        </div>
    </div>

    <!-- Script principale -->
    <script>
        const API_BASE_URL = 'http://localhost:8080/api';
        let currentMachineId = 1;
        let currentCredit = 0;
        let selectedBeverage = null;
        let sugarLevel = 2;
        let client = null;

        const machineNumberElement = document.getElementById('machineNumber');
        const statusIndicatorElement = document.getElementById('statusIndicator');
        const beveragesListElement = document.getElementById('beveragesList');
        const currentCreditElement = document.getElementById('currentCredit');
        const dispenseButton = document.getElementById('dispenseButton');
        const returnCreditButton = document.getElementById('returnCreditButton');
        const dispensingOverlay = document.getElementById('dispensingOverlay');
        const dispensingStatusElement = document.getElementById('dispensingStatus');

        // Configurazione MQTT
        const mqttConfig = {
            host: 'localhost',
            port: 8883,
            path: '/mqtt',
            clientId: 'client_' + Math.random().toString(16).substr(2, 8),
            username: '20019309',
            password: 'Pissir2024!',
            useSSL: true,
            keepaliveInterval: 30,
            connectTimeout: 10,
            reconnectDelay: 5000,
            maxReconnectAttempts: 5
        };

        function connectToBroker() {
            // Creazione del client MQTT
            client = new Paho.MQTT.Client(
                mqttConfig.host,
                mqttConfig.port,
                mqttConfig.clientId
            );

            // Impostazione dei callback
            client.onConnectionLost = onConnectionLost;
            client.onMessageArrived = onMessageArrived;

            // Connessione al broker
            client.connect({
                onSuccess: onConnect,
                onFailure: onFailure,
                useSSL: mqttConfig.useSSL,
                userName: mqttConfig.username,
                password: mqttConfig.password,
                keepAliveInterval: mqttConfig.keepaliveInterval,
                timeout: mqttConfig.connectTimeout
            });
        }

        function onConnect() {
            console.log('Connesso al broker MQTT');
            
            // Sottoscrizione ai topic necessari
            client.subscribe(`macchine/${currentMachineId}/stato`);
            client.subscribe(`macchine/${currentMachineId}/bevande/erogazione`);
        }

        function onFailure(error) {
            console.error('Errore di connessione MQTT:', error);
            
            // Tentativo di riconnessione dopo il delay specificato
            setTimeout(connectToBroker, mqttConfig.reconnectDelay);
        }

        function onConnectionLost(responseObject) {
            if (responseObject.errorCode !== 0) {
                console.log('Connessione MQTT persa:', responseObject.errorMessage);
                // Tentativo di riconnessione
                setTimeout(connectToBroker, mqttConfig.reconnectDelay);
            }
        }

        function onMessageArrived(message) {
            const topic = message.destinationName;
            const payload = JSON.parse(message.payloadString);

            if (topic === `macchine/${currentMachineId}/stato`) {
                updateMachineStatus(payload.statoId);
            } else if (topic === `macchine/${currentMachineId}/bevande/erogazione`) {
                if (payload.success) {
                    dispensingStatusElement.textContent = 'Bevanda erogata con successo!';
                    currentCredit = 0;
                    currentCreditElement.textContent = '0.00';
                    selectedBeverage = null;
                    setTimeout(() => dispensingOverlay.classList.add('hidden'), 2000);
                } else {
                    dispensingStatusElement.textContent = 'Errore durante l\'erogazione.';
                }
            }
        }

        function publishMessage(topic, message) {
            if (!client || !client.isConnected()) {
                console.error('Client MQTT non connesso');
                return;
            }

            const mqttMessage = new Paho.MQTT.Message(JSON.stringify(message));
            mqttMessage.destinationName = topic;
            client.send(mqttMessage);
        }

        async function fetchMachineInfo(machineId) {
            try {
                const response = await axios.get(`${API_BASE_URL}/macchine/${machineId}`);
                const machine = response.data;
                machineNumberElement.textContent = `#${machine.id}`;
                updateMachineStatus(machine.statoId);
                fetchBeverages(machineId);
            } catch (error) {
                console.error('Errore nel recupero delle informazioni della macchina:', error);
                alert('Impossibile caricare le informazioni della macchina.');
            }
        }

        function updateMachineStatus(statusId) {
            const statusMap = {
                1: { text: 'Attiva', class: 'status-active' },
                2: { text: 'Manutenzione', class: 'status-maintenance' },
                3: { text: 'Fuori Servizio', class: 'status-error' },
                default: { text: 'Sconosciuto', class: 'status-unknown' }
            };

            const status = statusMap[statusId] || statusMap.default;
            statusIndicatorElement.className = `status-indicator ${status.class}`;
            statusIndicatorElement.querySelector('.status-text').textContent = status.text;
        }

        async function fetchBeverages(machineId) {
            try {
                const response = await axios.get(`${API_BASE_URL}/macchine/${machineId}/bevande`);
                const beverages = response.data;
                renderBeverages(beverages);
            } catch (error) {
                console.error('Errore nel recupero delle bevande:', error);
                alert('Impossibile caricare le bevande disponibili.');
            }
        }

        function renderBeverages(beverages) {
            beveragesListElement.innerHTML = beverages.map(beverage => `
                <div class="beverage-card ${beverage.disponibile ? '' : 'unavailable'}" 
                     data-id="${beverage.id}" 
                     data-price="${beverage.prezzo}" 
                     onclick="selectBeverage(${beverage.id}, ${beverage.prezzo}, ${beverage.disponibile})">
                    <h3 class="font-bold">${beverage.nome}</h3>
                    <p class="text-gray-600">€${beverage.prezzo.toFixed(2)}</p>
                    ${beverage.disponibile ? '' : '<p class="text-red-600">Esaurito</p>'}
                </div>
            `).join('');
        }

        function selectBeverage(beverageId, price, isAvailable) {
            if (!isAvailable) return;
            selectedBeverage = { id: beverageId, price };
            document.querySelectorAll('.beverage-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.querySelector(`.beverage-card[data-id="${beverageId}"]`).classList.add('selected');
            document.getElementById('customizationOptions').classList.remove('hidden');
            dispenseButton.disabled = currentCredit < price;
        }

        // Gestione dei pulsanti per lo zucchero
        document.querySelectorAll('.sugar-btn').forEach(button => {
            button.addEventListener('click', () => {
                document.querySelectorAll('.sugar-btn').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                sugarLevel = parseInt(button.getAttribute('data-level'));
            });
        });

        // Gestione dei pulsanti per le monete
        document.querySelectorAll('.coin-btn').forEach(button => {
            button.addEventListener('click', () => {
                const value = parseFloat(button.getAttribute('data-value'));
                currentCredit += value;
                currentCreditElement.textContent = currentCredit.toFixed(2);
                if (selectedBeverage && currentCredit >= selectedBeverage.price) {
                    dispenseButton.disabled = false;
                }
            });
        });

        // Gestione del pulsante di erogazione
        dispenseButton.addEventListener('click', async () => {
            if (!selectedBeverage || currentCredit < selectedBeverage.price) return;
            dispensingOverlay.classList.remove('hidden');
            dispensingStatusElement.textContent = 'Preparazione bevanda...';
            
            const topic = `macchine/${currentMachineId}/bevande/richiesta`;
            const message = {
                bevandaId: selectedBeverage.id,
                importo: selectedBeverage.price,
                zucchero: sugarLevel,
                timestamp: Date.now()
            };
            
            publishMessage(topic, message);
        });

        // Gestione del pulsante per il resto
        returnCreditButton.addEventListener('click', async () => {
            const topic = `macchine/${currentMachineId}/cassa/restituzione`;
            publishMessage(topic, {});
            currentCredit = 0;
            currentCreditElement.textContent = '0.00';
            alert('Credito restituito con successo.');
        });

        // Gestione delle categorie
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.classList.remove('bg-blue-600', 'text-white');
                    btn.classList.add('bg-gray-200');
                });
                button.classList.remove('bg-gray-200');
                button.classList.add('bg-blue-600', 'text-white');
            });
        });

        // Inizializzazione al caricamento della pagina
        document.addEventListener('DOMContentLoaded', () => {
            connectToBroker();
            fetchMachineInfo(currentMachineId);
        });
    </script>
</body>
</html>

================
File: src/main/resources/public/pages/client/login.html
================
<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Login</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
</head>

<body class="bg-gray-100">
    <div class="min-h-screen flex items-center justify-center">
        <div class="bg-white p-8 rounded-lg shadow-md w-96">
            <div class="text-center mb-8">
                <h1 class="text-2xl font-bold text-gray-800">Login</h1>
                <p class="text-gray-600">Sistema Gestione Distributori</p>
            </div>

            <form id="loginForm" class="space-y-6">
                <div>
                    <label class="block text-sm font-medium text-gray-700">Username</label>
                    <input type="text" id="username"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border" required>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700">Password</label>
                    <input type="password" id="password"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border" required>
                </div>

                <div id="errorMessage" class="text-red-500 text-sm hidden"></div>

                <button type="submit"
                    class="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none">
                    Accedi
                </button>
            </form>
        </div>
    </div>

    <!-- Includi il modulo AuthenticationService -->
    <script type="module">
        import auth from '../../js/common/authentication.js';

        const loginForm = document.getElementById('loginForm');
        const errorMessage = document.getElementById('errorMessage');

        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;

            try {
                const loginSuccess = await auth.login(username, password);

                if (loginSuccess) {
                    // Reindirizza in base al ruolo
                    if (auth.isAdmin()) {
                        window.location.href = '/pages/admin/dash_admin.html';
                    } else if (auth.isEmployee()) {
                        window.location.href = '/pages/admin/dash_impiegati.html';
                    } else {
                        window.location.href = '/pages/client/machineSelection.html';
                    }
                } else {
                    throw new Error('Username o password non validi');
                }
            } catch (error) {
                errorMessage.textContent = error.message;
                errorMessage.classList.remove('hidden');
            }
        });
    </script>
</body>

</html>

================
File: src/main/resources/public/pages/client/machineSelection.html
================
<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Sistema di selezione distributori automatici">
    <title>Selezione Distributore</title>

    <!-- CSS -->
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="../../css/client.css">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <!-- Scripts -->
    <script src="../../js/common/mqtt.js" type="module"></script>
    <script src="../../js/common/utils.js" type="module"></script>
    <script src="../../js/client/machineSelection.js" type="module"></script>

</head>

<body style="padding-top: 70px;">

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay hidden" aria-hidden="true">
        <div class="spinner" role="status"></div>
        <p>Caricamento in corso...</p>
    </div>

    <!-- Toast Container -->
    <div id="toastContainer" class="toast-container" aria-live="polite"></div>

    <!-- Navbar fissa in alto -->
    <div class="top-nav" style="position: fixed; top: 0; left: 0; right: 0; z-index: 1000; background-color: white;">
        <div class="nav-content">
            <div class="nav-brand">
                <span class="brand-text">Distributori disponibili</span>
            </div>
            <div class="nav-brand">
                <a class="btn btn-primary" href="/index.html">Home</a>
            </div>
            <div class="nav-actions">
                <span id="userInfo" class="mr-3"></span>
                <button onclick="logout()" class="btn btn-secondary">Logout</button>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div id="main-content" class="container mt-5" role="main">

        <!-- Machines List -->
        <hr><br>
        <section class="machines-section" aria-labelledby="machines-title">
            <h2 id="machines-title" style="margin: 0; text-align: center;">Elenco Distributori</h2><br>

            <div id="machinesList" class="machines-grid" role="list" aria-label="Elenco dei distributori disponibili">
                <!-- I distributori verranno caricati dinamicamente -->
            </div>

            <!-- No Results Message -->
            <div id="noResults" class="no-results hidden" role="alert">
                <i class="fas fa-search" aria-hidden="true"></i>
                <p>Nessun distributore trovato con i criteri selezionati</p>
                <button class="btn-reset" onclick="window.location.reload()">
                    Reimposta ricerca
                </button>
            </div>
        </section>
        <br><br><br>
        <hr><br>
        <!-- Institutes List -->
        <section class="institutes-section" aria-labelledby="institutes-title">
            <h2 id="institutes-title" style="margin: 0; text-align: center;">Elenco Istituti</h2><br>

            <div id="institutesList" class="institutes-grid" role="list" aria-label="Elenco degli istituti disponibili">
                <!-- Gli istituti verranno caricati dinamicamente -->
            </div>
        </section>
    </div>

    <!-- Footer -->
    <footer class="client-footer" role="contentinfo">
        <br>
        <hr>
        <p style="text-align:center!important">© 2025 Edoardo Giovanni Fracchia - Sistema Distributori Automatici</p>
    </footer>
</body>

</html>

================
File: src/main/resources/public/pages/client/register.html
================
<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Registrazione - Sistema Distributori</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
</head>

<body class="bg-gray-100">
    <div class="min-h-screen flex items-center justify-center">
        <div class="bg-white p-8 rounded-lg shadow-lg w-full max-w-md">
            <h2 class="text-2xl font-bold mb-6 text-center text-gray-800">Registrazione Utente</h2>

            <form id="registrationForm" class="space-y-4">
                <div>
                    <label for="nome" class="block text-sm font-medium text-gray-700">Nome Completo</label>
                    <input type="text" id="nome" name="nome" required
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                </div>

                <div>
                    <label for="username" class="block text-sm font-medium text-gray-700">Username</label>
                    <input type="text" id="username" name="username" required
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                </div>

                <div>
                    <label for="password" class="block text-sm font-medium text-gray-700">Password</label>
                    <input type="password" id="password" name="password" required
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                    <p class="mt-1 text-xs text-gray-500">La password deve contenere almeno 8 caratteri, una maiuscola,
                        una minuscola, un numero e un carattere speciale</p>
                </div>

                <div>
                    <label for="ruolo" class="block text-sm font-medium text-gray-700">Ruolo</label>
                    <select id="ruolo" name="ruolo" required
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                        <option value="">Seleziona un ruolo</option>
                        <option value="amministratore">Amministratore</option>
                        <option value="tecnico">Tecnico</option>
                        <option value="operatore">Operatore</option>
                    </select>
                </div>

                <div id="alertBox" class="hidden rounded-md p-4 mt-4"></div>

                <button type="submit"
                    class="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                    Registra
                </button>
            </form>

            <div class="mt-4 text-center">
                <a href="login.html" class="text-sm text-blue-600 hover:text-blue-500">
                    Hai già un account? Accedi
                </a>
            </div>
        </div>
    </div>

    <script>
        document.getElementById('registrationForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            const alertBox = document.getElementById('alertBox');

            try {
                // Raccolta dati dal form
                const formData = {
                    nome: document.getElementById('nome').value,
                    username: document.getElementById('username').value,
                    password: document.getElementById('password').value,
                    ruolo: document.getElementById('ruolo').value
                };

                // Validazione password
                const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
                if (!passwordRegex.test(formData.password)) {
                    throw new Error('La password non rispetta i requisiti di sicurezza');
                }

                // Invio dati all'API
                const response = await fetch('/api/auth/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(formData)
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.errore || 'Errore durante la registrazione');
                }

                // Registrazione riuscita
                alertBox.className = 'rounded-md p-4 mt-4 bg-green-100 text-green-700';
                alertBox.textContent = 'Registrazione completata con successo! Reindirizzamento...';
                alertBox.style.display = 'block';

                // Reindirizza alla pagina di login dopo 2 secondi
                setTimeout(() => {
                    window.location.href = 'login.html';
                }, 2000);

            } catch (error) {
                // Gestione errori
                alertBox.className = 'rounded-md p-4 mt-4 bg-red-100 text-red-700';
                alertBox.textContent = error.message;
                alertBox.style.display = 'block';
            }
        });

        // Funzione per validare i campi in tempo reale
        function validateField(field) {
            const value = field.value.trim();

            switch (field.id) {
                case 'nome':
                    return value.length >= 3;
                case 'username':
                    return value.length >= 4;
                case 'password':
                    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
                    return passwordRegex.test(value);
                case 'ruolo':
                    return value !== '';
                default:
                    return true;
            }
        }

        // Aggiungi validazione in tempo reale per tutti i campi
        document.querySelectorAll('input, select').forEach(field => {
            field.addEventListener('input', () => {
                if (validateField(field)) {
                    field.classList.remove('border-red-500');
                    field.classList.add('border-gray-300');
                } else {
                    field.classList.remove('border-gray-300');
                    field.classList.add('border-red-500');
                }
            });
        });
    </script>
</body>

</html>
